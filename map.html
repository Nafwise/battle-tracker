<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Akashic Atlas | 3D Voxel Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ADDED touch-action: none to body to prevent browser gestures */
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: ui-sans-serif, system-ui, sans-serif; user-select: none; touch-action: none; -webkit-touch-callout: none; overscroll-behavior: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; transition: opacity 0.2s; }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: rgba(255, 255, 255, 0.9); }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: rgba(255, 255, 255, 0.9); }
        /* Added touch-action: none here as well */
        .hotbar-slot { transition: all 0.15s ease-out; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); touch-action: none; }
        .hotbar-slot.active { border-color: #38BDF8; box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); transform: translateY(-4px); z-index: 20; }
        #tooltip { position: absolute; display: none; transform: translate(-50%, -120%); backdrop-filter: blur(8px); z-index: 50; pointer-events: none; }
        .token-item { transition: all 0.2s; }
        .token-item:hover { transform: translateX(4px); background: rgba(51, 65, 85, 0.8); }
        .mode-switch { position: relative; display: flex; background: #0f172a; border-radius: 8px; padding: 4px; border: 1px solid #334155; gap: 4px; flex-wrap: wrap; justify-content: center; }
        .mode-btn { padding: 4px 12px; font-size: 12px; font-weight: bold; border-radius: 6px; color: #94a3b8; transition: all 0.2s; }
        .mode-btn.active { background: #38BDF8; color: #0f172a; box-shadow: 0 0 10px rgba(56, 189, 248, 0.3); }
        #move-badge { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #6ee7b7; font-weight: bold; padding: 6px 16px; border-radius: 20px; backdrop-filter: blur(4px); display: none; text-shadow: 0 1px 2px black; }
        
        #save-indicator { position: absolute; bottom: 80px; right: 20px; background: rgba(0,0,0,0.7); color: #aaa; padding: 5px 10px; border-radius: 5px; font-size: 12px; pointer-events: none; transition: opacity 0.5s; opacity: 0; }
        #save-indicator.visible { opacity: 1; }
        
        #slots-modal { display: none; }
        #slots-modal.open { display: flex; }

        /* Focus Navigation Controls */
        #focus-controls { display: none; position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%); gap: 10px; align-items: center; pointer-events: auto; }
        #focus-controls.visible { display: flex; }
        .focus-nav-btn { background: rgba(15, 23, 42, 0.9); color: white; border: 1px solid #334155; width: 40px; height: 40px; border-radius: 50%; display: flex; items-center; justify-content: center; font-weight: bold; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .focus-nav-btn:hover { background: #38BDF8; color: #0f172a; transform: scale(1.1); }
        .focus-label { background: rgba(15, 23, 42, 0.9); color: white; padding: 8px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; border: 1px solid #334155; min-width: 150px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }

        /* Next Turn Button */
        #next-turn-btn { 
            position: absolute; top: 130px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            border: 2px solid #a5b4fc;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
            padding: 8px 24px; border-radius: 99px;
            color: white; font-weight: bold; font-size: 14px;
            display: flex; align-items: center; gap: 8px;
            cursor: pointer; transition: all 0.2s;
            z-index: 50;
            touch-action: none; /* Prevent gestures */
        }
        #next-turn-btn:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 25px rgba(99, 102, 241, 0.8); }
        #next-turn-btn.hidden { display: none; }
        .turn-active-glow { box-shadow: 0 0 30px 10px rgba(255, 215, 0, 0.6); }

        /* Dropdown Styles */
        .dropdown-content { display: none; position: absolute; right: 0; top: 100%; background-color: #1e293b; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 50; border-radius: 0.5rem; border: 1px solid #334155; margin-top: 0.5rem;}
        .dropdown-content.show { display: block; }
        .dropdown-content a { text-decoration: none; display: flex; align-items: center; gap: 8px; font-size: 0.75rem; font-weight: 700; padding: 8px; }
        
        /* App Links */
        .app-link-btn { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background-color: #1e293b; color: #94a3b8; border: 1px solid #334155; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 700; transition: all 0.2s; width: 100%; margin-bottom: 4px; }
        .app-link-btn:last-child { margin-bottom: 0; }
        .app-link-btn:hover { background-color: #334155; color: #fff; border-color: #475569; }
        .app-link-tome:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-homebrew:hover { border-color: #f59e0b; color: #fcd34d; }
        .app-link-loot:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-campaign:hover { border-color: #10b981; color: #6ee7b7; }

        /* Mobile specific adjustments */
        @media (max-width: 1024px) { 
            #ui-layer { padding: 10px; }
            .mode-switch { justify-content: space-between; }
            .mode-btn { padding: 6px 8px; font-size: 10px; flex-grow: 1; text-align: center; }
            #instructions { display: none !important; } /* Hide heavy instructions on mobile */
            /* FIX: Ensure hotbar wrapper is above mobile controls (z-index 40) */
            #hotbar-wrapper { bottom: 10px; z-index: 60; position: relative; }
            .hotbar-slot { width: 40px; height: 40px; }
            #next-turn-btn { top: auto; bottom: 200px; }
            #sidebar-container { display: none; } /* Hide sidebar on mobile */
            .header-controls { flex-wrap: wrap; justify-content: center; gap: 5px; }
            .header-controls button { padding: 6px 10px; font-size: 10px; }
            #move-badge { bottom: 140px; }
        }

        /* UPDATED MOBILE CONTROLS */
        #mobile-controls { 
            display: none; 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; /* Let clicks pass through generally */
            z-index: 40; 
        }
        /* Mobile controls visibility is now handled by JS logic */

        /* The invisible touch zones */
        .touch-zone-left { position: absolute; top: 60px; bottom: 0; left: 0; width: 50%; pointer-events: auto; touch-action: none; }
        .touch-zone-right { position: absolute; top: 60px; bottom: 0; right: 0; width: 50%; pointer-events: auto; touch-action: none; }

        /* The Visual Joystick */
        #joystick-ui { 
            position: absolute; 
            width: 100px; height: 100px; 
            border: 2px solid rgba(255, 255, 255, 0.2); 
            border-radius: 50%; 
            display: none; /* Hidden until touched */
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #joystick-knob {
            position: absolute; left: 50%; top: 50%;
            width: 40px; height: 40px;
            background: rgba(56, 189, 248, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
        }

        /* Build Actions Position */
        #mobile-build-actions { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            pointer-events: auto; 
            position: absolute; 
            bottom: 140px; 
            right: 20px; 
            z-index: 50; 
        }
        
        /* Enforce touch-action none on buttons to stop weird ghost clicks/zooms */
        .build-btn { width: 60px; height: 60px; background: rgba(30, 41, 59, 0.95); border: 2px solid #475569; border-radius: 50%; color: white; display: flex; items-center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.1s; touch-action: none; }
        .build-btn:active { transform: scale(0.95); }
        .build-btn.place-btn { border-color: #10b981; color: #10b981; background: rgba(6, 78, 59, 0.9); }
        .build-btn.break-btn { border-color: #ef4444; color: #ef4444; background: rgba(127, 29, 29, 0.9); }
        .build-btn.fly-btn { border-color: #eab308; color: #fef08a; background: rgba(113, 63, 18, 0.9); font-size: 10px; font-weight: bold; }
        .build-btn.fly-btn.active { background: #eab308; color: black; box-shadow: 0 0 15px rgba(234, 179, 8, 0.6); }

        /* Vertical movement controls for Fly Mode */
        #mobile-vertical-controls { display: none; flex-direction: column; gap: 10px; position: absolute; bottom: 160px; left: 160px; pointer-events: auto; z-index: 50; }
        
        .vert-btn { width: 50px; height: 50px; background: rgba(15, 23, 42, 0.8); border: 2px solid #64748b; border-radius: 12px; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5); touch-action: none; }
        .vert-btn:active { background: #38BDF8; color: black; }

        /* CONTROL SCHEME MODAL */
        #controls-modal { display: none; }
        #controls-modal.open { display: flex; }
    </style>
</head>
<body>
    <div id="ui-layer" class="flex flex-col justify-between h-full p-4">
        <!-- HEADER -->
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="interactive bg-slate-900/90 border border-slate-700 p-3 rounded-xl shadow-xl backdrop-blur-sm flex flex-col gap-2 w-full md:w-auto">
                <div class="flex items-center justify-between gap-4">
                    <h1 class="text-xl font-bold text-white flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22d3ee" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
                        <span class="hidden md:inline">Akashic Atlas</span>
                        <span class="md:hidden">Atlas</span>
                    </h1>
                    <!-- Mode Switch -->
                    <div class="mode-switch">
                        <button id="mode-build" class="mode-btn active">BUILD</button>
                        <button id="mode-dm" class="mode-btn">DM</button>
                        <button id="mode-players" class="mode-btn text-blue-400">PLAYERS</button>
                        <button id="mode-enemies" class="mode-btn text-red-400">ENEMIES</button>
                    </div>
                </div>
                <div class="text-xs text-slate-400 font-mono flex gap-3 justify-center md:justify-start">
                    <span id="coord-display">0, 0, 0</span> | <span id="block-count">0 Blocks</span> | <span id="current-map-name" class="text-amber-400 font-bold">Default Map</span>
                </div>
            </div>

            <!-- CONTROLS -->
            <div class="header-controls flex gap-2 relative flex-wrap justify-end w-full md:w-auto">
                <button id="btn-input-toggle" class="interactive bg-slate-800 border border-slate-600 p-2 rounded-lg text-slate-400 hover:text-white transition-colors shadow-lg" title="Change Controls"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg></button>
                <button id="btn-atmosphere" class="interactive bg-slate-800 border border-amber-500/50 p-2 rounded-lg text-amber-400 hover:bg-slate-700 transition-colors shadow-lg" title="Toggle Day/Night"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button>
                <div class="w-px h-10 bg-slate-700/50 mx-1 hidden md:block"></div>
                <button id="btn-sync" class="interactive bg-indigo-600 hover:bg-indigo-500 border border-indigo-400 text-white text-xs font-bold px-4 py-2 rounded-lg shadow-lg transition-all flex items-center gap-2">Sync</button>
                <button id="btn-slots" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-amber-400 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg> Maps</button>
                <button id="btn-export" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Export</button>
                <button id="btn-import" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Import</button>
                <button id="btn-clear" class="interactive bg-red-900/30 hover:bg-red-900/80 border border-red-800/50 text-red-200 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Clear</button>
                <input type="file" id="file-input" accept=".json" class="hidden">
                
                <!-- DROPDOWN MENU -->
                <div class="dropdown interactive relative">
                    <button id="btn-apps-dropdown" class="bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2">
                        Apps <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                    </button>
                    <div id="apps-dropdown-content" class="dropdown-content p-2">
                        <a href="tome.html" target="_blank" class="app-link-btn app-link-tome"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></svg> Tome</a>
                        <a href="homebrew.html" target="_blank" class="app-link-btn app-link-homebrew"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"/><path d="M8.5 2h7"/><path d="M7 16h10"/></svg> Homebrew</a>
                        <a href="loot.html" target="_blank" class="app-link-btn app-link-loot"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></svg> Loot</a>
                        <a href="campaign.html" target="_blank" class="app-link-btn app-link-campaign"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg> Campaign</a>
                    </div>
                </div>
            </div>
        </div>
        <div id="sidebar-container" class="absolute left-4 top-32 bottom-32 w-64 interactive overflow-y-auto pr-2 hidden sm:block"></div>
        
        <!-- Focus Navigation UI -->
        <div id="focus-controls" class="interactive">
            <button id="focus-prev" class="focus-nav-btn">&lt;</button>
            <div id="focus-label" class="focus-label">No Target</div>
            <button id="focus-next" class="focus-nav-btn">&gt;</button>
        </div>

        <!-- Next Turn Button -->
        <button id="next-turn-btn" class="interactive hidden">
            <span>Next</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>
        </button>

        <div id="instructions" class="interactive absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-900/95 border border-cyan-500/50 p-8 rounded-2xl text-center shadow-[0_0_50px_rgba(6,182,212,0.2)] backdrop-blur-md cursor-pointer hover:border-cyan-400 transition-all z-50 group">
            <h2 class="text-3xl font-bold text-white mb-2 group-hover:scale-105 transition-transform">Click to Enter</h2>
            <div id="instr-build" class="space-y-2 text-slate-300 text-sm mt-4 text-left grid grid-cols-2 gap-x-6">
                <div><span class="text-cyan-400 font-bold">WASD</span> Move</div>
                <div><span class="text-cyan-400 font-bold">Space / C</span> Fly</div>
                <div><span class="text-red-400 font-bold">L-Click</span> Delete</div>
                <div><span class="text-cyan-400 font-bold">R-Click</span> Place</div>
                <div><span class="text-indigo-400 font-bold">Shift + R</span> Focus</div>
                <div><span class="text-yellow-400 font-bold">F</span> Toggle Fly</div>
            </div>
            <div id="instr-dm" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">WASD</span> Free Cam</div>
                <div><span class="text-indigo-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Select</div>
                <div><span class="text-red-400 font-bold">Esc</span> Release</div>
            </div>
            <div id="instr-focus" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Move</div>
                <div><span class="text-indigo-400 font-bold">Tab</span> Snap</div>
                <div><span class="text-amber-400 font-bold">Scroll</span> Zoom</div>
            </div>
        </div>
        <div id="mouse-mode-badge" class="absolute top-32 left-1/2 -translate-x-1/2 bg-yellow-500/20 border border-yellow-500 text-yellow-200 px-4 py-1 rounded-full text-xs font-bold uppercase tracking-wider backdrop-blur hidden">Mouse Cursor Active (Tab)</div>
        <div id="move-badge">Movement: 30ft</div>
        
        <!-- NEW MOBILE CONTROLS -->
        <div id="mobile-controls">
            <!-- Touch Zones -->
            <div id="zone-move" class="touch-zone-left"></div>
            <div id="zone-look" class="touch-zone-right"></div>
            
            <!-- Visual Feedback -->
            <div id="joystick-ui">
                <div id="joystick-knob"></div>
            </div>

            <div id="mobile-vertical-controls">
                <button id="mob-up" class="vert-btn">â–²</button>
                <button id="mob-down" class="vert-btn">â–¼</button>
            </div>
            <div id="mobile-build-actions">
                <button id="mob-place" class="build-btn place-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg></button>
                <button id="mob-break" class="build-btn break-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                <button id="mob-fly" class="build-btn fly-btn">FLY</button>
            </div>
        </div>

        <div id="save-indicator">Saving...</div>

        <div class="interactive mt-auto w-full flex flex-col items-center" id="hotbar-wrapper">
            <div class="bg-black/80 text-slate-400 text-[10px] uppercase tracking-widest px-3 py-1 rounded-t-lg font-bold border-t border-x border-slate-800/50">Hold # & Scroll / Touch</div>
            <div id="hotbar" class="flex gap-2 p-3 bg-slate-900/90 border border-slate-700 rounded-2xl shadow-2xl backdrop-blur-md overflow-x-auto max-w-full"></div>
        </div>
    </div>

    <!-- MAP SLOTS MODAL -->
    <div id="slots-modal" class="interactive fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 shadow-2xl flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> Select Map</h2>
                <button id="close-slots" class="text-slate-400 hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
            </div>
            <div class="p-4 overflow-y-auto space-y-2 flex-1" id="slots-list"></div>
            <div class="p-4 border-t border-slate-700 bg-slate-800 rounded-b-xl">
                <div class="flex gap-2">
                    <input type="text" id="new-map-name" placeholder="New Map Name" class="flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm text-white focus:outline-none focus:border-indigo-500">
                    <button id="create-map-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded text-sm">Create</button>
                </div>
            </div>
        </div>
    </div>

    <!-- CONTROL SCHEME MODAL -->
    <div id="controls-modal" class="interactive fixed inset-0 z-[110] bg-black/90 backdrop-blur-md flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-lg rounded-2xl border-2 border-indigo-500/50 shadow-[0_0_50px_rgba(99,102,241,0.2)] p-8 text-center">
            <h2 class="text-2xl font-bold text-white mb-2">Select Control Scheme</h2>
            <p class="text-slate-400 mb-8">Choose how you want to interact with the world.</p>
            
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                <button id="scheme-mouse" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-indigo-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-400 group-hover:scale-110 transition-transform"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Keyboard & Mouse</div>
                        <div class="text-xs text-slate-400 mt-1">WASD to Move<br>Pointer Lock Look</div>
                    </div>
                </button>

                <button id="scheme-touch" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-cyan-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-cyan-400 group-hover:scale-110 transition-transform"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Touchscreen</div>
                        <div class="text-xs text-slate-400 mt-1">Virtual Joystick<br>Swipe to Look</div>
                    </div>
                </button>
            </div>
            <p class="text-[10px] text-slate-500">You can change this later from the top menu.</p>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="tooltip" class="bg-slate-900/95 border border-slate-600 rounded-lg p-3 text-white shadow-xl min-w-[150px]"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            worldSize: 64,
            colors: { 
                bgNight: 0x020617, bgDay: 0x87CEEB, highlight: 0x38BDF8, delete: 0xEF4444, valid: 0x10b981, invalid: 0xEF4444,
                monster: 0xef4444, player: 0x3b82f6
            },
            moveSpeed: 30, blockSize: 5
        };

        const CONDITION_COLORS = { "Blinded":0x525252,"Charmed":0xdb2777,"Deafened":0x94a3b8,"Frightened":0x7c3aed,"Grappled":0xf97316,"Incapacitated":0xdc2626,"Invisible":0xffffff,"Paralyzed":0xfacc15,"Petrified":0x475569,"Poisoned":0x16a34a,"Prone":0x78350f,"Restrained":0x9a3412,"Stunned":0xf59e0b,"Unconscious":0x000000,"Exhaustion":0x7f1d1d,"Default":0x38BDF8 };
        const MATERIALS = [
            { id: 0, name: "Grass", color: 0x4b6e32, type: 'solid' }, { id: 1, name: "Dirt", color: 0x5c3c28, type: 'solid' }, { id: 2, name: "Stone", color: 0x64748b, type: 'solid' }, { id: 3, name: "Wood", color: 0x8B4513, type: 'solid' },
            { id: 4, name: "Sand", color: 0xE6C288, type: 'solid' }, { id: 5, name: "Snow", color: 0xf1f5f9, type: 'solid' }, { id: 6, name: "Dungeon", color: 0x1e293b, type: 'solid' },
            { id: 7, name: "Water", color: 0x38BDF8, type: 'liquid', opacity: 0.6 }, { id: 8, name: "Lava", color: 0xea580c, type: 'liquid', opacity: 0.8 }, { id: 9, name: "Acid", color: 0x84cc16, type: 'liquid', opacity: 0.6 },
            { id: 10, name: "Poison", color: 0x14532d, type: 'liquid', opacity: 0.7 }, { id: 11, name: "Force", color: 0xa855f7, type: 'liquid', opacity: 0.5 }
        ];
        const CATEGORIES = [
            { key: '1', label: 'Solid', type: 'block', items: [0, 1, 2, 3, 4, 5, 6] }, { key: '2', label: 'Liquid', type: 'block', items: [7, 8, 9, 10, 11] },
            { key: '3', label: 'Players', type: 'token', subType: 'player', items: [] }, { key: '4', label: 'Enemies', type: 'token', subType: 'monster', items: [] },
            { key: '5', label: 'Loot', type: 'loot', items: [] }, { key: '6', label: '-', type: 'none', items: [] },
            { key: '7', label: '-', type: 'none', items: [] }, { key: '8', label: '-', type: 'none', items: [] }, { key: '9', label: '-', type: 'none', items: [] }, { key: '0', label: '-', type: 'none', items: [] }
        ];
        const DIRS = [ {x:1,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:-1,z:0}, {x:0,y:0,z:1}, {x:0,y:0,z:-1} ];

        const state = { 
            gameMode: 'build', activeCategoryIdx: 0, subSelections: new Array(10).fill(0), 
            isAtmosphereDay: false, heldKeys: {}, mapData: new Map(), tokenData: new Map(), 
            mode: 'view', dragStart: null, controlledToken: null, focusedToken: null, moveBudget: 30,
            currentMapId: 'default', currentMapName: 'Default Map', autoSaveTimer: null,
            focusIndex: 0, focusList: [], 
            currentTurnIndex: 0,
            isTouch: false, // Updated: controlled by selection
            moveVector: { x: 0, z: 0 }, 
            touch: { id: null, startX: 0, startY: 0, moveX: 0, moveY: 0 } 
        };

        const scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bgNight); scene.fog = new THREE.Fog(CONFIG.colors.bgNight, 10, 60);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 5, 10);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5); dirLight.position.set(50, 100, 50); scene.add(dirLight);
        const torchLight = new THREE.PointLight(0xffaa00, 1.5, 20); camera.add(torchLight); scene.add(camera);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(64, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({visible:false})); plane.name = "ground"; scene.add(plane);
        scene.add(new THREE.GridHelper(64, 64, 0x334155, 0x1e293b));

        // MOUSE AND ROTATION TRACKING
        const mouse = new THREE.Vector2();
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        const GeometryManager = {
            cache: new Map(),
            init: () => {
                const base = new THREE.BoxGeometry(1,1,1); const pos = base.attributes.position, norm = base.attributes.normal, uv = base.attributes.uv, idx = base.index;
                for (let m=0; m<64; m++) {
                    const indices = [];
                    for (let f=0; f<6; f++) if ((m & (1<<f)) === 0) for (let i=0; i<6; i++) indices.push(idx.array[f*6+i]);
                    const g = new THREE.BufferGeometry(); g.setAttribute('position', pos); g.setAttribute('normal', norm); g.setAttribute('uv', uv); g.setIndex(indices);
                    GeometryManager.cache.set(m, g);
                }
            },
            get: (m) => GeometryManager.cache.get(m) || GeometryManager.cache.get(0)
        }; GeometryManager.init();

        const materials = MATERIALS.map(m => {
            const matConfig = {
                color: m.color,
                transparent: !!m.opacity,
                opacity: m.opacity || 1
            };
            if (m.type === 'liquid') {
                matConfig.depthWrite = false; 
                matConfig.side = THREE.FrontSide;
            }
            return new THREE.MeshLambertMaterial(matConfig);
        });
        const tokenGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
        const lootGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);

        const RangeRingManager = {
            group: new THREE.Group(),
            init: () => { scene.add(RangeRingManager.group); RangeRingManager.group.visible = false; },
            update: (targetToken, type = 'movement') => {
                while(RangeRingManager.group.children.length) RangeRingManager.group.remove(RangeRingManager.group.children[0]);
                if(!targetToken) { RangeRingManager.group.visible = false; return; }
                RangeRingManager.group.visible = true;
                RangeRingManager.group.position.copy(targetToken.position);
                RangeRingManager.group.position.y = targetToken.position.y - 0.1 + 0.02;
                
                const data = targetToken.userData.data;
                const radius = (state.moveBudget / 5); 
                
                // Base Ring
                const baseRing = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, opacity: 0.8, transparent: true}));
                RangeRingManager.group.add(baseRing);

                if (type === 'movement' && radius > 0) {
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(Math.max(0.1, radius-0.2), radius, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0x38BDF8, side: THREE.DoubleSide, transparent: true, opacity: 0.4}));
                    RangeRingManager.group.add(mesh);
                } else if (type === 'conditions' || type === 'focus') {
                    const moveRadius = 6; // 30ft default vis
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(moveRadius-0.1, moveRadius, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({ color: 0x10b981, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
                    RangeRingManager.group.add(mesh);
                }
            }
        }; RangeRingManager.init();

        // --- MAP STORAGE MANAGER ---
        const MapStorageManager = {
            getKeys: () => { try { return JSON.parse(localStorage.getItem('akashic_map_index')) || { 'default': 'Default Map' }; } catch { return { 'default': 'Default Map' }; } },
            saveIndex: (idx) => localStorage.setItem('akashic_map_index', JSON.stringify(idx)),
            loadMap: (id) => {
                const idx = MapStorageManager.getKeys();
                if (!idx[id]) return false;
                state.currentMapId = id; state.currentMapName = idx[id];
                
                const mapNameEl = document.getElementById('current-map-name');
                if (mapNameEl) mapNameEl.innerText = state.currentMapName;
                
                try {
                    const raw = localStorage.getItem(`akashic_map_${id}_voxels`);
                    WorldManager.clear(false); 
                    if (raw) { JSON.parse(raw).forEach(b => WorldManager.add(b.x, b.y, b.z, b.c, false)); }
                } catch(e) { console.error("Map Load Error", e); }
                try {
                    const posRaw = localStorage.getItem(`akashic_map_${id}_positions`);
                    const posData = posRaw ? JSON.parse(posRaw) : {};
                    state.tokenData.forEach((mesh, tokenId) => {
                        if (posData[tokenId]) mesh.position.set(posData[tokenId].x, posData[tokenId].y, posData[tokenId].z);
                        else mesh.position.set(0, 2, 0); 
                    });
                } catch(e) {}
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                return true;
            },
            saveMap: () => {
                const voxelData = []; state.mapData.forEach(m => voxelData.push({x:m.position.x, y:m.position.y, z:m.position.z, c:m.userData.matIndex}));
                localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(voxelData));
                const posData = {}; state.tokenData.forEach((m, id) => { posData[id] = {x:m.position.x, y:m.position.y, z:m.position.z}; });
                localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(posData));
                const ind = document.getElementById('save-indicator'); ind.classList.add('visible'); setTimeout(() => ind.classList.remove('visible'), 1000);
            },
            createMap: (name) => { const id = Date.now().toString(36); const idx = MapStorageManager.getKeys(); idx[id] = name; MapStorageManager.saveIndex(idx); return id; },
            deleteMap: (id) => { if (id === 'default') { alert("Cannot delete default map."); return; } if (!confirm("Delete this map forever?")) return; const idx = MapStorageManager.getKeys(); delete idx[id]; MapStorageManager.saveIndex(idx); localStorage.removeItem(`akashic_map_${id}_voxels`); localStorage.removeItem(`akashic_map_${id}_positions`); if (state.currentMapId === id) MapStorageManager.loadMap('default'); UIManager.renderSlots(); },
            triggerAutoSave: () => { if (state.autoSaveTimer) clearTimeout(state.autoSaveTimer); state.autoSaveTimer = setTimeout(MapStorageManager.saveMap, 2000); }
        };

        const WorldManager = {
            add: (x,y,z,mat, updateGeo=true) => { const k = `${x},${y},${z}`; if(state.mapData.has(k)) return; const m = new THREE.Mesh(GeometryManager.get(0), materials[mat]); m.position.set(x,y,z); m.userData={isVoxel:true, matIndex:mat}; scene.add(m); state.mapData.set(k, m); if(updateGeo) { WorldManager.updateGeo(x,y,z); DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; MapStorageManager.triggerAutoSave(); } },
            remove: (m) => { const {x,y,z} = m.position; scene.remove(m); state.mapData.delete(`${x},${y},${z}`); DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; MapStorageManager.triggerAutoSave(); },
            updateGeo: (x,y,z) => { const m = state.mapData.get(`${x},${y},${z}`); if(!m) return; let mask = 0; DIRS.forEach((d,i) => { const n = state.mapData.get(`${x+d.x},${y+d.y},${z+d.z}`); if(n && n.userData.matIndex === m.userData.matIndex) mask |= (1<<i); }); m.geometry = GeometryManager.get(mask); },
            clear: (updateUI=true) => { state.mapData.forEach(m=>scene.remove(m)); state.mapData.clear(); if(updateUI) { document.getElementById('block-count').innerText = `0 Blocks`; MapStorageManager.triggerAutoSave(); } }
        };

        const EntityManager = {
            sync: () => {
                try {
                    const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters')||'[]');
                    if(!mons.length) { mons.push({id:'p1', name:'Hero', type:'player', currentHp:20, maxHp:20, conditions:['Poisoned']}); mons.push({id:'e1', name:'Goblin', type:'monster', currentHp:7, maxHp:7, conditions:[]}); }
                    CATEGORIES[2].items = mons.filter(c=>c.type==='player'); CATEGORIES[3].items = mons.filter(c=>c.type==='monster');
                    const loot = JSON.parse(localStorage.getItem('dm-loot') || '[]'); if (!loot.length) loot.push({id:'l1', name:'Gold', icon:'ðŸ’°'}, {id:'l2', name:'Sword', icon:'âš”ï¸'}, {id:'l3', name:'Potion', icon:'ðŸ§ª'}); CATEGORIES[4].items = loot;
                    
                    state.tokenData.forEach((m,id) => { if(!m.userData.isLoot && !mons.find(c=>c.id===id)) { scene.remove(m); state.tokenData.delete(id); } });
                    
                    mons.forEach((c,i) => { 
                        let m = state.tokenData.get(c.id); 
                        const col = c.type==='monster' ? CONFIG.colors.monster : CONFIG.colors.player; 
                        if(!m) { 
                            m = new THREE.Mesh(tokenGeo, new THREE.MeshLambertMaterial({color:col})); 
                            m.add(new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshLambertMaterial({color:0xffffff})).translateY(0.4)); 
                            m.userData={isToken:true, id:c.id, data:c}; scene.add(m); state.tokenData.set(c.id, m); m.position.set(i*2, 2, 0); 
                        } else { m.material.color.setHex(col); m.userData.data=c; } 
                    });
                    
                    UIManager.renderHotbar(); UIManager.renderSidebar();
                    EntityManager.updateTurnVisuals();
                } catch(e) { console.error(e); }
            },
            advanceTurn: () => {
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                if (mons.length === 0) return;
                let turn = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                turn = (turn + 1) % mons.length;
                localStorage.setItem('dm-tracker-turn-index', turn);
                state.currentTurnIndex = turn;
                const activeId = mons[turn].id;
                const token = state.tokenData.get(activeId);
                if (token) {
                    const tokenType = mons[turn].type; 
                    if (tokenType === 'player') {
                        setMode('players');
                        state.focusIndex = state.focusList.indexOf(token);
                        snapCameraTo(token);
                    } else if (tokenType === 'monster') {
                        setMode('enemies');
                        state.focusIndex = state.focusList.indexOf(token);
                        snapCameraTo(token);
                    }
                }
                EntityManager.updateTurnVisuals();
            },
            updateTurnVisuals: () => {
                state.tokenData.forEach(m => { if (m.userData.glow) { m.remove(m.userData.glow); m.userData.glow = null; } });
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                const turnIndex = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                if (mons.length > 0 && mons[turnIndex]) {
                    const activeId = mons[turnIndex].id;
                    const token = state.tokenData.get(activeId);
                    if (token) {
                        const glowGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
                        const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.5 });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        glow.position.y = -0.1;
                        token.add(glow);
                        token.userData.glow = glow;
                        const btn = document.getElementById('next-turn-btn');
                        btn.classList.remove('hidden');
                        btn.innerHTML = `<span>Next Turn (${mons[turnIndex].name})</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>`;
                        
                        // Prevent camera movement on this button
                        btn.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});
                    }
                }
            }
        };

        const UIManager = {
            renderHotbar: () => {
                const el = document.getElementById('hotbar'); el.innerHTML='';
                CATEGORIES.forEach((c,i) => {
                    const div = document.createElement('div');
                    div.className = `hotbar-slot w-12 h-12 bg-slate-800 border-2 rounded-lg flex flex-col items-center justify-center cursor-pointer relative ${i===state.activeCategoryIdx?'active border-sky-400':'border-slate-600 opacity-80'} shrink-0`;
                    const item = c.items[state.subSelections[i]||0];
                    let inr = '';
                    if(item !== undefined) {
                        if(c.type==='block') { const h = MATERIALS[item].color.toString(16).padStart(6,'0'); inr=`<div style="width:24px;height:24px;background:#${h};border:1px solid #fff;border-radius:4px"></div>`; }
                        else if(c.type==='token') { const cl = c.subType==='monster'?'#ef4444':'#3b82f6'; inr=`<div style="width:12px;height:12px;background:${cl};border-radius:50%"></div><span class="text-[9px] text-white truncate w-full text-center">${item.name}</span>`; }
                        else if(c.type==='loot') inr=`<span style="font-size:20px">${item.icon}</span>`;
                    }
                    div.innerHTML = `<span class="absolute -top-3 left-1/2 -translate-x-1/2 bg-slate-900 text-slate-400 text-[9px] px-1.5 rounded border border-slate-700">${(i+1)%10}</span>${inr}`;
                    
                    // Prevent camera movement when touching hotbar
                    div.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});

                    // Cycle logic on click/tap
                    div.onclick = (e) => { 
                        e.stopPropagation();
                        if (state.activeCategoryIdx === i) {
                            // Already active, cycle sub-selection
                            const count = c.items.length;
                            if (count > 1) {
                                let s = (state.subSelections[i] || 0) + 1;
                                if (s >= count) s = 0;
                                state.subSelections[i] = s;
                            }
                        } else {
                            state.activeCategoryIdx = i; 
                        }
                        UIManager.renderHotbar(); 
                    }; 
                    el.appendChild(div);
                });
            },
            renderSidebar: () => {
                const el = document.getElementById('sidebar-container'); el.innerHTML='';
                const parts = [ {l:'Heroes', d:CATEGORIES[2].items}, {l:'Enemies', d:CATEGORIES[3].items} ];
                parts.forEach(p => {
                    if(!p.d.length) return;
                    el.innerHTML += `<div class="text-[10px] font-bold text-slate-400 mt-2 mb-1 border-b border-slate-700">${p.l}</div>`;
                    p.d.forEach(t => {
                        const r = document.createElement('div'); r.className='token-item flex items-center gap-2 bg-slate-800/50 p-2 rounded mb-1 cursor-pointer';
                        r.innerHTML = `<div class="w-2 h-2 rounded-full ${p.l==='Heroes'?'bg-blue-500':'bg-red-500'}"></div><div class="text-xs text-slate-200">${t.name}</div>`;
                        r.onclick = () => { const m = state.tokenData.get(t.id); if(m) { controls.getObject().position.set(m.position.x, m.position.y+5, m.position.z+5); controls.getObject().lookAt(m.position); } };
                        el.appendChild(r);
                    });
                });
            },
            updateTooltip: (o) => {
                const t = document.getElementById('tooltip');
                if(!o) { t.style.display='none'; return; }
                t.style.display='block';
                if(o.userData.isVoxel) t.innerHTML = `<div class="font-bold text-sm">${MATERIALS[o.userData.matIndex].name}</div>`;
                else if(o.userData.isToken) t.innerHTML = `<div class="font-bold text-indigo-300 text-lg">${o.userData.data.name}</div><div class="text-xs">HP: ${o.userData.data.currentHp}/${o.userData.data.maxHp}</div><div class="text-[9px] text-slate-400">${o.userData.data.conditions?.join(',')||''}</div>`;
                else if(o.userData.isLoot) t.innerHTML = `<div class="font-bold text-amber-400">${o.userData.data.icon} ${o.userData.data.name}</div>`;
            },
            renderSlots: () => {
                const idx = MapStorageManager.getKeys();
                const list = document.getElementById('slots-list');
                list.innerHTML = '';
                Object.keys(idx).forEach(id => {
                    const row = document.createElement('div'); row.className = `flex justify-between items-center p-3 rounded mb-2 cursor-pointer transition-colors ${state.currentMapId === id ? 'bg-indigo-900/50 border border-indigo-500' : 'bg-slate-800 border border-slate-700 hover:bg-slate-700'}`; row.innerHTML = `<span class="font-bold text-sm text-white">${idx[id]}</span>`;
                    const actions = document.createElement('div'); actions.className = 'flex gap-2';
                    if (id !== state.currentMapId) { const loadBtn = document.createElement('button'); loadBtn.innerText = "Load"; loadBtn.className = "text-xs bg-green-700 hover:bg-green-600 text-white px-2 py-1 rounded"; loadBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.loadMap(id); document.getElementById('slots-modal').classList.remove('open'); }; actions.appendChild(loadBtn); } else { const activeBadge = document.createElement('span'); activeBadge.innerText = "Active"; activeBadge.className = "text-[10px] bg-indigo-600 text-white px-2 py-1 rounded"; actions.appendChild(activeBadge); }
                    if (id !== 'default') { const delBtn = document.createElement('button'); delBtn.innerText = "X"; delBtn.className = "text-xs bg-red-900/50 hover:bg-red-700 text-red-200 px-2 py-1 rounded"; delBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.deleteMap(id); }; actions.appendChild(delBtn); }
                    row.appendChild(actions); list.appendChild(row);
                });
            }
        };

        const controls = new PointerLockControls(camera, document.body);
        const raycaster = new THREE.Raycaster();
        const move = { f:false, b:false, l:false, r:false, u:false, d:false };
        let canJump=false, isFlying=false, velocity = new THREE.Vector3(), prevTime = performance.now();

        const rollover = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), new THREE.MeshBasicMaterial({color:0x38BDF8, wireframe:true, opacity:0.5, transparent:true})); scene.add(rollover);
        const tokenRoll = new THREE.Mesh(tokenGeo, new THREE.MeshBasicMaterial({color:0xFCD34D, wireframe:true})); tokenRoll.visible=false; scene.add(tokenRoll);

        function getVoxelPos(pt, norm, mode) { const p = pt.clone(); if(mode==='build') p.add(norm.clone().multiplyScalar(0.5)); else p.add(norm.clone().multiplyScalar(-0.1)); return p.floor().addScalar(0.5); }
        function checkCollision(pos) {
            if(state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies' || isFlying) return false;
            const r=0.3, h=1.6, minX=Math.floor(pos.x-r), maxX=Math.ceil(pos.x+r), minY=Math.floor(pos.y-h), maxY=Math.ceil(pos.y), minZ=Math.floor(pos.z-r), maxZ=Math.ceil(pos.z+r);
            for(let x=minX; x<maxX; x++) for(let y=minY; y<maxY; y++) for(let z=minZ; z<maxZ; z++) { if(state.mapData.has(`${x},${y},${z}`) && (pos.x-r < x+0.5 && pos.x+r > x-0.5 && pos.y-h < y+0.5 && pos.y > y-0.5 && pos.z-r < z+0.5 && pos.z+r > z-0.5)) return true; }
            return false;
        }

        function snapCameraTo(token) {
            if(!token) return;
            const targetPos = token.position.clone();
            const camOffset = new THREE.Vector3(0, 10, 8); 
            camera.position.copy(targetPos).add(camOffset);
            camera.up.set(0, 1, 0);
            camera.lookAt(targetPos);
            RangeRingManager.update(token, 'focus');
            document.getElementById('focus-label').innerText = token.userData.data.name;
        }

        function updateFocusMode(mode) {
            state.focusList = [];
            state.tokenData.forEach(t => {
                if (t.userData.isToken) {
                    if (mode === 'players' && t.userData.data.type === 'player') state.focusList.push(t);
                    if (mode === 'enemies' && t.userData.data.type === 'monster') state.focusList.push(t);
                }
            });
            
            if (state.focusList.length > 0) {
                if (state.controlledToken && state.focusList.includes(state.controlledToken)) {
                    state.focusIndex = state.focusList.indexOf(state.controlledToken);
                } else {
                    state.focusIndex = 0;
                }
                snapCameraTo(state.focusList[state.focusIndex]);
                state.controlledToken = state.focusList[state.focusIndex];
                state.moveBudget = 30; 
                RangeRingManager.update(state.controlledToken, 'movement');
                document.getElementById('move-badge').style.display = 'block';
                document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
            } else {
                RangeRingManager.update(null);
                state.controlledToken = null;
                document.getElementById('focus-label').innerText = "No Targets";
            }
        }

        function cycleFocus(direction) {
            if (state.focusList.length === 0) return;
            state.focusIndex += direction;
            if (state.focusIndex >= state.focusList.length) state.focusIndex = 0;
            if (state.focusIndex < 0) state.focusIndex = state.focusList.length - 1;
            
            const token = state.focusList[state.focusIndex];
            snapCameraTo(token);
            state.controlledToken = token;
            state.moveBudget = 30;
            RangeRingManager.update(state.controlledToken, 'movement');
            document.getElementById('move-badge').style.display = 'block';
            document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
        }

        function handleRaycast() {
            if(!controls.isLocked && !state.isTouch && state.mode!=='view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            
            if (controls.isLocked || state.isTouch) { // CHANGED: Always center raycast for touch OR pointer lock
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            } else {
                raycaster.setFromCamera(mouse, camera);
            }
            
            const hits = raycaster.intersectObjects([...state.mapData.values(), ...state.tokenData.values(), scene.getObjectByName('ground')]);
            
            rollover.visible = false; 
            tokenRoll.visible = false;
            UIManager.updateTooltip(null);

            if(hits.length) {
                const hit = hits[0]; 
                UIManager.updateTooltip(hit.object.name==='ground'?null:hit.object);
                
                if (state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies') {
                    if (state.controlledToken) {
                         if(hit.object.userData.isVoxel || hit.object.name === 'ground') {
                            rollover.visible = true;
                            let floorY = hit.object.name === 'ground' ? 0 : Math.round(hit.point.y);
                            if (hit.face.normal.y < 0.9 && hit.object.userData.isVoxel) floorY = Math.floor(hit.point.y); 
                            const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                            const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                            const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                            rollover.scale.set(1, 0.1, 1); rollover.position.set(tx, floorY+0.05, tz);
                            if (cost <= state.moveBudget) { rollover.material.color.setHex(CONFIG.colors.valid); document.getElementById('tooltip').innerHTML = `<div class="text-green-400 font-bold">Move: ${cost}ft</div>`; }
                            else { rollover.material.color.setHex(CONFIG.colors.invalid); document.getElementById('tooltip').innerHTML = `<div class="text-red-400 font-bold">Far: ${cost}ft</div>`; }
                            document.getElementById('tooltip').style.display = 'block';
                        }
                    }
                    return {hit, interactable:true};
                }
                
                if (state.gameMode === 'build') {
                    const cat = CATEGORIES[state.activeCategoryIdx];
                    if(cat.type === 'block') {
                        rollover.visible = true;
                        if(state.dragStart) {
                            const s = state.dragStart.pos, e = getVoxelPos(hit.point, hit.face.normal, state.dragStart.mode);
                            const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                            rollover.scale.set(maxX-minX+1, maxY-minY+1, maxZ-minZ+1); rollover.position.set(minX+(maxX-minX+1)/2-0.5, minY+(maxY-minY+1)/2-0.5, minZ+(maxZ-minZ+1)/2-0.5);
                            rollover.material.color.setHex(state.dragStart.mode==='delete' ? CONFIG.colors.delete : CONFIG.colors.highlight);
                        } else { const p = hit.point.clone().add(hit.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5); rollover.scale.set(1,1,1); rollover.position.copy(p); rollover.material.color.setHex(CONFIG.colors.highlight); }
                    } else if (cat.type === 'token' || cat.type === 'loot') {
                        tokenRoll.visible = true;
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        let fy = hit.object.name==='ground'?0:(hit.face.normal.y>0.9?Math.round(hit.point.y):Math.floor(hit.point.y));
                        tokenRoll.position.set(tx, fy+(cat.type==='loot'?0.2:0.1), tz);
                    }
                    return {hit, interactable:true};
                }
            } 
            
            return {interactable:false};
        }

        // --- MOUSE MOVEMENT TRACKING FOR UNLOCKED CURSOR ---
        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isRightMouseDown && !controls.isLocked) {
                const movementX = event.clientX - lastMouseX;
                const movementY = event.clientY - lastMouseY;
                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, camera.rotation.x ) );
            }
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        // Add camera rotation via touch drag
        document.addEventListener('touchmove', (e) => {
             // FIXED: Ensure we don't catch events from UI buttons by checking event target closest
             // Actually, touchstart on those buttons calls stopPropagation, so it shouldn't reach here if started on button
             // But we need to make sure we don't accidentally rotate if a multi-touch gesture happens
             
             if (touchState.moveId !== null || touchState.lookId !== null) return;
             
             // If this is a single touch drag on background (not buttons), rotate camera
             // But usually on mobile touch scheme, we use joystick. 
             // This fallback is for "Mouse Scheme" on a touch device if user selected that.
             
             if (!state.isTouch && e.touches.length === 1) {
                 const touch = e.touches[0];
                 if (lastMouseX && lastMouseY) {
                     const movementX = touch.clientX - lastMouseX;
                     const movementY = touch.clientY - lastMouseY;
                     const obj = controls.getObject();
                     obj.rotation.y -= movementX * 0.005;
                     camera.rotation.x -= movementY * 0.005;
                     camera.rotation.x = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, camera.rotation.x ) );
                 }
                 lastMouseX = touch.clientX;
                 lastMouseY = touch.clientY;
             }
        }, { passive: true });
        
        document.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1) {
                 lastMouseX = e.touches[0].clientX;
                 lastMouseY = e.touches[0].clientY;
             }
        }, { passive: true });

        // --- NEW TOUCH CONTROLS ---
        const touchState = {
            moveId: null,
            moveStart: { x: 0, y: 0 },
            lookId: null,
            lookLast: { x: 0, y: 0 }
        };

        const joyUI = document.getElementById('joystick-ui');
        const joyKnob = document.getElementById('joystick-knob');

        const zoneMove = document.getElementById('zone-move');
        zoneMove.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            if(touchState.moveId === null) {
                touchState.moveId = touch.identifier;
                touchState.moveStart = { x: touch.clientX, y: touch.clientY };
                joyUI.style.display = 'block';
                joyUI.style.left = touch.clientX + 'px';
                joyUI.style.top = touch.clientY + 'px';
                joyKnob.style.transform = `translate(-50%, -50%)`;
            }
        }, { passive: false });

        zoneMove.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.moveId) {
                    const maxDist = 50;
                    let dx = touch.clientX - touchState.moveStart.x;
                    let dy = touch.clientY - touchState.moveStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) { const ratio = maxDist / dist; dx *= ratio; dy *= ratio; }
                    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    state.moveVector.x = dx / maxDist; 
                    state.moveVector.z = dy / maxDist; 
                }
            }
        }, { passive: false });

        const endMove = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchState.moveId) {
                    touchState.moveId = null;
                    state.moveVector = { x: 0, z: 0 };
                    joyUI.style.display = 'none';
                }
            }
        };
        zoneMove.addEventListener('touchend', endMove);
        zoneMove.addEventListener('touchcancel', endMove);

        const zoneLook = document.getElementById('zone-look');
        zoneLook.addEventListener('touchstart', (e) => {
            const touch = e.changedTouches[0];
            if(touchState.lookId === null) {
                touchState.lookId = touch.identifier;
                touchState.lookLast = { x: touch.clientX, y: touch.clientY };
            }
        }, { passive: false });

        zoneLook.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.lookId) {
                    const dx = touch.clientX - touchState.lookLast.x;
                    const dy = touch.clientY - touchState.lookLast.y;
                    
                    // FIXED: Use Euler order YXZ to prevent roll/yaw coupling (gimbal lock flipping)
                    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                    euler.setFromQuaternion(camera.quaternion);
                    euler.y -= dx * 0.005;
                    euler.x -= dy * 0.005;
                    euler.x = Math.max(- Math.PI / 2, Math.min( Math.PI / 2, euler.x ));
                    camera.quaternion.setFromEuler(euler);
                    
                    touchState.lookLast = { x: touch.clientX, y: touch.clientY };
                }
            }
        }, { passive: false });

        const endLook = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchState.lookId) {
                    touchState.lookId = null;
                }
            }
        };
        zoneLook.addEventListener('touchend', endLook);
        zoneLook.addEventListener('touchcancel', endLook);
        
        const simulateClick = (btn, type) => {
            const event = new MouseEvent(type, { bubbles: true, cancelable: true, view: window, button: btn });
            document.dispatchEvent(event);
        };

        const touchBtns = ['mob-place', 'mob-break', 'mob-fly', 'mob-up', 'mob-down'];
        touchBtns.forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    e.stopPropagation(); // CRITICAL: Stop event from bubbling to camera controls
                    if (id === 'mob-place') { simulateClick(2, 'mousedown'); setTimeout(() => simulateClick(2, 'mouseup'), 50); } 
                    else if (id === 'mob-break') { simulateClick(0, 'mousedown'); setTimeout(() => simulateClick(0, 'mouseup'), 50); } 
                    else if (id === 'mob-fly') { isFlying = !isFlying; velocity.y = 0; el.classList.toggle('bg-yellow-700'); const vControls = document.getElementById('mobile-vertical-controls'); if(vControls) vControls.style.display = isFlying ? 'flex' : 'none'; } 
                    else if (id === 'mob-up') { move.u = true; } 
                    else if (id === 'mob-down') { move.d = true; }
                }, { passive: false });
                el.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    e.stopPropagation(); // CRITICAL
                    if (id === 'mob-up') move.u = false; 
                    if (id === 'mob-down') move.d = false; 
                });
            }
        });

        document.addEventListener('keydown', e => {
            if(e.repeat) return;
            if(e.code === 'KeyW') move.f=true; if(e.code === 'KeyS') move.b=true; if(e.code === 'KeyA') move.l=true; if(e.code === 'KeyD') move.r=true;
            if(e.code === 'Space') { if(isFlying || state.gameMode === 'dm') move.u=true; else if(canJump) { velocity.y+=15; canJump=false; } }
            if(e.code === 'KeyC') { if(isFlying || state.gameMode === 'dm') move.d=true; } 
            if(e.code === 'KeyF') { isFlying=!isFlying; velocity.y=0; }
            if(e.code === 'Tab') {
                e.preventDefault();
                if (state.gameMode === 'players' || state.gameMode === 'enemies') {
                    if (state.focusList && state.focusList.length > 0) { snapCameraTo(state.focusList[state.focusIndex]); }
                } else {
                    if(controls.isLocked) { controls.unlock(); state.mode='menu'; document.getElementById('mouse-mode-badge').style.display='block'; } else { if (!state.isTouch) controls.lock(); state.mode='view'; document.getElementById('mouse-mode-badge').style.display='none'; }
                }
            }
            if(e.code === 'Escape') { if(state.controlledToken) { state.controlledToken = null; state.moveBudget = 30; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } }
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=true; state.activeCategoryIdx=i; UIManager.renderHotbar(); }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') move.f=false; if(e.code === 'KeyS') move.b=false; if(e.code === 'KeyA') move.l=false; if(e.code === 'KeyD') move.r=false;
            if(e.code === 'Space') move.u=false; if(e.code === 'KeyC') move.d=false;
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=false; }
        });

        document.addEventListener('mousedown', e => {
            if (e.button === 2) { isRightMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; }
            if(!controls.isLocked && state.mode !== 'view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            const res = handleRaycast();
            if(!res.interactable) { if(e.button===0) { state.controlledToken = null; state.focusedToken = null; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } return; }
            const {hit} = res;
            if (state.gameMode === 'players' || state.gameMode === 'enemies' || state.gameMode === 'dm') {
                if (e.button === 0) { 
                    if (state.controlledToken && (hit.object.userData.isVoxel || hit.object.name === 'ground')) {
                        let floorY = hit.object.name==='ground'?0:Math.round(hit.point.y); if(hit.face.normal.y<0.9 && hit.object.userData.isVoxel) floorY=Math.floor(hit.point.y);
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                        const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                        if (cost <= state.moveBudget) { 
                            state.controlledToken.position.copy(targetPos); 
                            state.moveBudget -= cost; 
                            document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`; 
                            RangeRingManager.update(state.controlledToken, 'movement'); 
                            MapStorageManager.saveMap();
                        }
                    }
                    return;
                }
            }
            if (e.shiftKey && e.button === 2 && hit.object.userData.isToken) { state.focusedToken = hit.object; RangeRingManager.update(state.focusedToken, 'conditions'); const p = hit.object.position; controls.getObject().position.set(p.x, p.y+5, p.z+5); controls.getObject().lookAt(p); return; }
            if (state.gameMode === 'build') {
                const cat = CATEGORIES[state.activeCategoryIdx];
                if(e.button === 2) {
                    if(cat.type==='block') state.dragStart = {pos:getVoxelPos(hit.point, hit.face.normal, 'build'), mode:'build'};
                    else if(cat.type==='token' || cat.type==='loot') {
                        const d = cat.items[state.subSelections[state.activeCategoryIdx]];
                        if(d) {
                             const p = tokenRoll.position.clone();
                             if(cat.type==='token') { if(state.tokenData.has(d.id)) state.tokenData.get(d.id).position.copy(p); } 
                             else { const m = new THREE.Mesh(lootGeo, new THREE.MeshLambertMaterial({color:0xFFD700})); m.position.copy(tokenRoll.position); m.userData={isLoot:true, id:`l${Date.now()}`, data:d}; scene.add(m); state.tokenData.set(m.userData.id, m); }
                             MapStorageManager.saveMap();
                        }
                    }
                } else if(e.button===0) {
                    if(cat.type==='block' && hit.object.userData.isVoxel) state.dragStart={pos:getVoxelPos(hit.point, hit.face.normal, 'delete'), mode:'delete'};
                    else if(hit.object.userData.isLoot) { scene.remove(hit.object); state.tokenData.delete(hit.object.userData.id); MapStorageManager.saveMap(); }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) isRightMouseDown = false;
            if(!state.dragStart) return;
            const res = handleRaycast();
            if(res.interactable) {
                const s = state.dragStart.pos, e = getVoxelPos(res.hit.point, res.hit.face.normal, state.dragStart.mode);
                const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                const mat = CATEGORIES[state.activeCategoryIdx].items[state.subSelections[state.activeCategoryIdx]];
                if((maxX-minX)*(maxY-minY)*(maxZ-minZ) > 5000) { alert("Too big"); state.dragStart=null; rollover.scale.set(1,1,1); return; }
                let chg=0;
                for(let x=minX; x<=maxX; x++) for(let y=minY; y<=maxY; y++) for(let z=minZ; z<=maxZ; z++) {
                    if(state.dragStart.mode==='build') { if(mat!==undefined){WorldManager.add(x,y,z,mat,false); chg++;} } 
                    else { const m=state.mapData.get(`${x},${y},${z}`); if(m){WorldManager.remove(m); chg++;} }
                }
                for(let x=minX-1; x<=maxX+1; x++) for(let y=minY-1; y<=maxY+1; y++) for(let z=minZ-1; z<=maxZ+1; z++) WorldManager.updateGeo(x,y,z);
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                if(chg) MapStorageManager.saveMap();
            }
            state.dragStart=null; rollover.scale.set(1,1,1);
        });

        document.addEventListener('wheel', e => {
            if (state.gameMode === 'players' || state.gameMode === 'enemies') {
                const zoomSpeed = 0.5; const zoomDir = new THREE.Vector3(); camera.getWorldDirection(zoomDir);
                if (e.deltaY > 0) zoomDir.negate();
                camera.position.add(zoomDir.multiplyScalar(zoomSpeed));
                return;
            }
            const i = Object.keys(state.heldKeys).find(k=>state.heldKeys[k]);
            const target = i !== undefined ? i : state.activeCategoryIdx;
            const c = CATEGORIES[target]; if(!c.items.length) return;
            let s = state.subSelections[target] + (e.deltaY>0?1:-1); if(s<0) s=c.items.length-1; if(s>=c.items.length) s=0;
            state.subSelections[target] = s; UIManager.renderHotbar();
        });

        // Dropdown toggle logic
        document.getElementById('btn-apps-dropdown').onclick = (e) => { e.stopPropagation(); document.getElementById('apps-dropdown-content').classList.toggle('show'); };
        window.onclick = (e) => {
            if (!e.target.matches('#btn-apps-dropdown') && !e.target.closest('#btn-apps-dropdown')) {
                const dropdowns = document.getElementsByClassName("dropdown-content");
                for (let i = 0; i < dropdowns.length; i++) { if (dropdowns[i].classList.contains('show')) dropdowns[i].classList.remove('show'); }
            }
        };

        // --- INSTRUCTIONS CLICK ---
        document.getElementById('instructions').onclick = () => {
            if (state.gameMode === 'players' || state.gameMode === 'enemies') {
                document.getElementById('instructions').style.display='none';
                document.getElementById('ui-layer').classList.add('interactive');
            } else {
                if (!state.isTouch) controls.lock();
                else document.getElementById('instructions').style.display='none';
            }
        };

        controls.addEventListener('lock', () => { document.getElementById('instructions').style.display='none'; document.getElementById('ui-layer').classList.remove('interactive'); });
        controls.addEventListener('unlock', () => { 
            if(state.mode==='menu' || state.gameMode === 'players' || state.gameMode === 'enemies' || state.gameMode === 'dm') {
                document.getElementById('ui-layer').classList.add('interactive'); 
            } else {
                if(!state.isTouch) document.getElementById('instructions').style.display='block'; 
            }
        });
        
        document.getElementById('mode-build').onclick = () => setMode('build'); 
        document.getElementById('mode-dm').onclick = () => setMode('dm');
        document.getElementById('mode-players').onclick = () => setMode('players');
        document.getElementById('mode-enemies').onclick = () => setMode('enemies');
        
        document.getElementById('focus-next').onclick = () => cycleFocus(1);
        document.getElementById('focus-prev').onclick = () => cycleFocus(-1);
        
        document.getElementById('next-turn-btn').onclick = () => { EntityManager.advanceTurn(); };

        // --- NEW SLOTS LOGIC ---
        document.getElementById('btn-slots').onclick = () => { UIManager.renderSlots(); document.getElementById('slots-modal').classList.add('open'); };
        document.getElementById('close-slots').onclick = () => document.getElementById('slots-modal').classList.remove('open');
        document.getElementById('create-map-btn').onclick = () => {
            const name = document.getElementById('new-map-name').value;
            if(name) {
                const id = MapStorageManager.createMap(name);
                MapStorageManager.loadMap(id);
                WorldManager.clear(true);
                UIManager.renderSlots();
                document.getElementById('new-map-name').value = '';
            }
        };

        // --- INPUT SCHEME LOGIC ---
        function applyInputScheme(mode) {
            state.isTouch = (mode === 'touch');
            localStorage.setItem('akashic_input_scheme', mode);
            
            const mobControls = document.getElementById('mobile-controls');
            const instructions = document.getElementById('instructions');
            
            if (state.isTouch) {
                mobControls.style.display = 'block';
                instructions.style.display = 'none'; // Don't need click-to-lock on mobile
            } else {
                mobControls.style.display = 'none';
                if(state.gameMode === 'build' && !controls.isLocked) instructions.style.display = 'block';
            }
            document.getElementById('controls-modal').classList.remove('open');
        }

        function initInputScheme() {
            const saved = localStorage.getItem('akashic_input_scheme');
            if (saved) {
                applyInputScheme(saved);
            } else {
                // If no save, check capability but still show modal for choice
                const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                // Optional: Auto-select if confident? No, user requested selection on startup.
                document.getElementById('controls-modal').classList.add('open');
            }
        }

        document.getElementById('scheme-mouse').onclick = () => applyInputScheme('mouse');
        document.getElementById('scheme-touch').onclick = () => applyInputScheme('touch');
        document.getElementById('btn-input-toggle').onclick = () => document.getElementById('controls-modal').classList.add('open');

        function setMode(m) {
            state.gameMode = m; 
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${m}`).classList.add('active');
            
            document.getElementById('instr-build').style.display = m==='build'?'grid':'none'; 
            document.getElementById('instr-dm').style.display = m==='dm'?'grid':'none';
            document.getElementById('instr-focus').style.display = (m==='players'||m==='enemies')?'grid':'none';
            
            const focusControls = document.getElementById('focus-controls');
            if (m === 'players' || m === 'enemies') {
                focusControls.classList.add('visible');
                updateFocusMode(m);
            } else {
                focusControls.classList.remove('visible');
                RangeRingManager.update(null);
                if(m==='dm') { isFlying=true; velocity.y=0; }
                
                if (m === 'build') {
                    camera.rotation.z = 0;
                    camera.rotation.x = 0;
                    camera.up.set(0, 1, 0);
                    if (!state.isTouch) controls.lock(); 
                }
            }
            UIManager.renderHotbar();
        }
        document.getElementById('btn-sync').onclick = EntityManager.sync; 
        document.getElementById('btn-clear').onclick = () => { if(confirm("Nuke this map?")) { WorldManager.clear(); MapStorageManager.saveMap(); } };
        
        document.getElementById('btn-export').onclick = () => { 
            const data = {
                voxels: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_voxels`)),
                positions: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_positions`))
            };
            const b=new Blob([JSON.stringify(data)],{type:'application/json'}); 
            const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=`map_${state.currentMapId}.json`; a.click(); 
        };
        document.getElementById('btn-import').onclick = () => document.getElementById('file-input').click();
        document.getElementById('file-input').onchange = (e) => { 
            const r=new FileReader(); 
            r.onload=ev=>{
                try {
                    const d = JSON.parse(ev.target.result);
                    localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(d.voxels));
                    localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(d.positions));
                    MapStorageManager.loadMap(state.currentMapId);
                } catch(e) { alert("Invalid Map File"); }
            }; 
            r.readAsText(e.target.files[0]); 
        };

        function animate() {
            requestAnimationFrame(animate);
            const dt = (performance.now()-prevTime)/1000; prevTime=performance.now();
            
            const physicsEnabled = (controls.isLocked || state.isTouch) && state.gameMode !== 'players' && state.gameMode !== 'enemies';

            if(physicsEnabled) {
                velocity.x -= velocity.x * 10.0 * dt; 
                velocity.z -= velocity.z * 10.0 * dt;
                
                if (state.gameMode === 'dm') velocity.y -= velocity.y * 5.0 * dt; 
                else velocity.y -= isFlying ? velocity.y * 5.0 * dt : 9.8 * 2.0 * dt;

                const spd = isFlying || state.gameMode==='dm' ? 40 : 15;

                let inputX = 0;
                let inputZ = 0;

                if (state.isTouch) {
                    inputX = -state.moveVector.x;
                    inputZ = state.moveVector.z;
                } else {
                    inputZ = Number(move.f) - Number(move.b); 
                    inputX = Number(move.r) - Number(move.l);
                    inputZ = Number(move.b) - Number(move.f); 
                }
                
                if (inputZ !== 0 || inputX !== 0) {
                    velocity.z += inputZ * spd * 10.0 * dt; 
                    velocity.x += inputX * spd * 10.0 * dt;
                }

                if ((isFlying || state.gameMode==='dm')) { 
                    if (move.u) velocity.y += spd * 10.0 * dt; 
                    if (move.d) velocity.y -= spd * 10.0 * dt; 
                }

                const obj = controls.getObject(), startPos = obj.position.clone();
                controls.moveRight(-velocity.x * dt); if(checkCollision(obj.position)) obj.position.x = startPos.x;
                controls.moveForward(-velocity.z * dt); if(checkCollision(obj.position)) obj.position.z = startPos.z;
                obj.position.y += velocity.y * dt;
                if(checkCollision(obj.position) || (obj.position.y<2 && state.gameMode!=='dm')) { if(velocity.y<0) { canJump=true; obj.position.y = Math.ceil(obj.position.y); } else { obj.position.y = Math.floor(obj.position.y)-0.6; } velocity.y=0; if(obj.position.y < 2) obj.position.y = 2; }
                const p = obj.position; document.getElementById('coord-display').innerText = `${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;
                handleRaycast();
            }
            renderer.render(scene, camera);
        }

        // INIT LOAD
        if (!MapStorageManager.loadMap('default')) {
            MapStorageManager.saveIndex({'default': 'Default Map'});
            MapStorageManager.loadMap('default');
        }
        EntityManager.sync(); 
        UIManager.renderHotbar();
        initInputScheme(); // Start the selection process
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>
