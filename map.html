<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Akashic Atlas</title>
    
    <!-- PWA / Mobile App Configuration -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0F172A">

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Polyfills & Babel -->
    <script src="https://cdn.jsdelivr.net/npm/core-js-bundle@3.37.1/minified.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls (Essential for 3D navigation) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --astral-bg: #0F172A;
            --accent-cyan: #38BDF8;
            --accent-purple: #A855F7;
        }

        body {
             background-color: #020617; 
             margin: 0;
             overflow: hidden; /* Fullscreen 3D canvas */
             font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
             color: #F8FAFC;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-layer {
            position: absolute;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to 3D scene */
            width: 100%;
            height: 100%;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .interactive-ui {
            pointer-events: auto; /* Re-enable clicks for buttons */
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .animate-pulse-slow {
            animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS ---
        const Icon = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const MapIcon = (props) => <Icon {...props}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6" /><line x1="8" y1="2" x2="8" y2="18" /><line x1="16" y1="6" x2="16" y2="22" /></Icon>;
        const Home = (props) => <Icon {...props}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></Icon>;
        const RefreshCw = (props) => <Icon {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></Icon>;
        const Compass = (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/></Icon>;
        const Info = (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></Icon>;
        // New Icons for Navigation
        const CastleGate = (props) => (<Icon {...props}><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></Icon>);
        const Gem = (props) => <Icon {...props}><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></Icon>;
        const FlaskConical = (props) => <Icon {...props}><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2" /><path d="M8.5 2h7" /><path d="M7 16h10" /></Icon>;

        // --- THREE.JS COMPONENT ---
        const ThreeScene = ({ combatants, onSelectToken, selectedId }) => {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const tokensRef = useRef({}); // Store references to meshes by ID
            const raycaster = useRef(new THREE.Raycaster());
            const mouse = useRef(new THREE.Vector2());
            const dragPlaneRef = useRef(null); // Invisible plane for dragging
            const isDragging = useRef(false);
            const draggedToken = useRef(null);
            
            // Local storage for POSITIONS only
            const [positions, setPositions] = useState(() => {
                try { return JSON.parse(localStorage.getItem('akashic-map-coords')) || {}; } catch { return {}; }
            });

            // Save positions when they update
            useEffect(() => {
                localStorage.setItem('akashic-map-coords', JSON.stringify(positions));
            }, [positions]);

            // Initialize Scene
            useEffect(() => {
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                // 1. Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020617); // Deep space blue
                scene.fog = new THREE.FogExp2(0x020617, 0.015);
                sceneRef.current = scene;

                // 2. Camera
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(0, 20, 20); // Isometric-ish view
                cameraRef.current = camera;

                // 3. Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // 4. Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xA855F7, 0.8); // Purple tinted light
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                scene.add(dirLight);
                
                const blueLight = new THREE.PointLight(0x38BDF8, 0.5); // Cyan point light
                blueLight.position.set(-10, 5, -10);
                scene.add(blueLight);

                // 5. Environment (Grid & Stars)
                const gridHelper = new THREE.GridHelper(50, 50, 0x38BDF8, 0x1E293B);
                gridHelper.position.y = -0.01;
                scene.add(gridHelper);

                // Invisible drag plane (ground)
                const planeGeo = new THREE.PlaneGeometry(100, 100);
                const planeMat = new THREE.MeshBasicMaterial({ visible: false });
                const dragPlane = new THREE.Mesh(planeGeo, planeMat);
                dragPlane.rotation.x = -Math.PI / 2;
                scene.add(dragPlane);
                dragPlaneRef.current = dragPlane;

                // Stars
                const starsGeo = new THREE.BufferGeometry();
                const starsCount = 1000;
                const posArray = new Float32Array(starsCount * 3);
                for(let i = 0; i < starsCount * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 100; // Spread stars
                }
                starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starsMat = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
                const starField = new THREE.Points(starsGeo, starsMat);
                scene.add(starField);

                // 6. Controls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground
                controls.minDistance = 5;
                controls.maxDistance = 50;
                controlsRef.current = controls;

                // 7. Animation Loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // 8. Resize Handler
                const handleResize = () => {
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    renderer.setSize(w, h);
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);

                // Cleanup
                return () => {
                    window.removeEventListener('resize', handleResize);
                    mountRef.current.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, []);

            // Handle Combatant Tokens (Create/Update/Delete)
            useEffect(() => {
                const scene = sceneRef.current;
                
                // Track current IDs to identify removals
                const currentIds = new Set(combatants.map(c => c.id));
                
                // Remove old tokens
                Object.keys(tokensRef.current).forEach(id => {
                    if (!currentIds.has(id)) {
                        scene.remove(tokensRef.current[id]);
                        delete tokensRef.current[id];
                    }
                });

                // Add/Update tokens
                combatants.forEach((c, index) => {
                    let mesh = tokensRef.current[c.id];
                    
                    // Default Position logic
                    let pos = positions[c.id];
                    if (!pos) {
                        // Arrange in a line if no saved position
                        const xOffset = c.type === 'player' ? -5 : 5;
                        const zSpacing = 2;
                        pos = { x: xOffset, y: 0, z: (index % 10) * zSpacing - 5 };
                    }

                    const isDead = c.currentHp <= 0;
                    const color = c.type === 'player' ? 0x38BDF8 : 0xF43F5E; // Cyan or Red
                    const finalColor = isDead ? 0x475569 : color; // Grey if dead

                    if (!mesh) {
                        // Create Mesh
                        const geometry = c.type === 'player' 
                            ? new THREE.CylinderGeometry(0.5, 0.7, 1.5, 32) // Pawn shapeish
                            : new THREE.BoxGeometry(1, 1.5, 1); // Box for monsters
                        
                        const material = new THREE.MeshStandardMaterial({ 
                            color: finalColor,
                            roughness: 0.7,
                            metalness: 0.1
                        });
                        
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        
                        // User Data for raycasting
                        mesh.userData = { id: c.id, isToken: true };
                        
                        // Initial Position
                        mesh.position.set(pos.x, 0.75, pos.z);
                        
                        scene.add(mesh);
                        tokensRef.current[c.id] = mesh;

                        // Add a "Ring" for selection highlight (initially invisible)
                        const ringGeo = new THREE.RingGeometry(0.8, 0.9, 32);
                        const ringMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.DoubleSide, visible: false });
                        const ring = new THREE.Mesh(ringGeo, ringMat);
                        ring.rotation.x = -Math.PI / 2;
                        ring.position.y = -0.74; // Just above ground relative to mesh center
                        ring.name = "selectionRing";
                        mesh.add(ring);
                    } else {
                        // Update existing mesh properties
                        mesh.material.color.setHex(finalColor);
                        // We don't force position update here to allow dragging, 
                        // unless it's a fresh load or external sync? 
                        // For now, let the local dragging state handle position.
                    }
                    
                    // Update Selection Ring
                    const ring = mesh.getObjectByName("selectionRing");
                    if (ring) ring.material.visible = (c.id === selectedId);
                });

            }, [combatants, selectedId, positions]);

            // INTERACTION HANDLERS (Raycasting & Dragging)
            useEffect(() => {
                const canvas = rendererRef.current.domElement;
                const camera = cameraRef.current;
                
                const onMouseDown = (event) => {
                    // Calculate mouse position
                    const rect = canvas.getBoundingClientRect();
                    mouse.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.current.setFromCamera(mouse.current, camera);
                    
                    // Intersect tokens
                    const tokenMeshes = Object.values(tokensRef.current);
                    const intersects = raycaster.current.intersectObjects(tokenMeshes);

                    if (intersects.length > 0) {
                        const hit = intersects[0].object;
                        // Disable controls while dragging
                        controlsRef.current.enabled = false;
                        isDragging.current = true;
                        draggedToken.current = hit;
                        onSelectToken(hit.userData.id);
                    } else {
                        // Deselect if clicking empty space
                         onSelectToken(null);
                    }
                };

                const onMouseMove = (event) => {
                    if (!isDragging.current || !draggedToken.current) return;

                    // Raycast to floor plane
                    const rect = canvas.getBoundingClientRect();
                    mouse.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.current.setFromCamera(mouse.current, camera);
                    const intersects = raycaster.current.intersectObject(dragPlaneRef.current);

                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        // Snap to grid (optional, lets do 0.5 snap)
                        const snap = 1; 
                        const x = Math.round(point.x / snap) * snap;
                        const z = Math.round(point.z / snap) * snap;
                        
                        draggedToken.current.position.set(x, 0.75, z);
                    }
                };

                const onMouseUp = () => {
                    if (isDragging.current && draggedToken.current) {
                        // Save new position
                        const id = draggedToken.current.userData.id;
                        const pos = draggedToken.current.position;
                        setPositions(prev => ({
                            ...prev,
                            [id]: { x: pos.x, y: pos.y, z: pos.z }
                        }));
                    }
                    isDragging.current = false;
                    draggedToken.current = null;
                    controlsRef.current.enabled = true;
                };

                canvas.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                
                // Touch support (Basic)
                canvas.addEventListener('touchstart', (e) => {
                    e.clientX = e.touches[0].clientX;
                    e.clientY = e.touches[0].clientY;
                    onMouseDown(e);
                }, {passive: false});

                return () => {
                    canvas.removeEventListener('mousedown', onMouseDown);
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                };
            }, [onSelectToken]);


            return <div ref={mountRef} id="canvas-container" />;
        };

        // --- MAIN APP UI ---
        const App = () => {
            const [combatants, setCombatants] = useState([]);
            const [selectedId, setSelectedId] = useState(null);
            const [lastSync, setLastSync] = useState(new Date());

            // SYNC FUNCTION: Reads from tome.html's storage
            const syncData = () => {
                try {
                    const raw = localStorage.getItem('dm-tracker-monsters');
                    if (raw) {
                        setCombatants(JSON.parse(raw));
                        setLastSync(new Date());
                    }
                } catch (e) {
                    console.error("Failed to sync", e);
                }
            };

            // Initial Sync + Interval Polling
            useEffect(() => {
                syncData();
                const interval = setInterval(syncData, 2000); // Auto-sync every 2s
                return () => clearInterval(interval);
            }, []);

            const selectedCombatant = useMemo(() => 
                combatants.find(c => c.id === selectedId), 
            [combatants, selectedId]);

            const getHealthColor = (current, max) => {
                const pct = (current / max);
                if (pct > 0.5) return 'text-green-400';
                if (pct > 0.25) return 'text-yellow-400';
                return 'text-red-500';
            };

            return (
                <div className="w-full h-screen relative overflow-hidden bg-slate-950">
                    
                    {/* 3D SCENE */}
                    <ThreeScene 
                        combatants={combatants} 
                        onSelectToken={setSelectedId} 
                        selectedId={selectedId}
                    />

                    {/* UI LAYER */}
                    <div className="ui-layer pointer-events-none">
                        
                        {/* HEADER */}
                        <header className="flex flex-col sm:flex-row justify-between items-start gap-3 interactive-ui">
                            <div className="glass-panel p-3 flex items-center gap-3">
                                <div className="bg-slate-900 p-2 rounded-lg border border-indigo-500/30">
                                    <MapIcon className="text-cyan-400 w-6 h-6" />
                                </div>
                                <div>
                                    <h1 className="text-xl font-bold tracking-tight text-white leading-none">Akashic Atlas</h1>
                                    <span className="text-[10px] text-slate-400 font-mono uppercase tracking-wider">Tactical View â€¢ v1.0</span>
                                </div>
                            </div>
                            
                            <div className="flex flex-wrap gap-2">
                                {/* Navigation Buttons */}
                                <a href="./tome.html" className="flex items-center gap-2 bg-purple-900 hover:bg-purple-800 text-white px-3 py-2 rounded-full text-xs font-bold transition-all shadow-[0_0_15px_rgba(147,51,234,0.5)] border border-purple-700 hover:border-purple-500 hover:shadow-[0_0_25px_rgba(147,51,234,0.8)] hover:scale-105 active:scale-95 no-underline">
                                    <CastleGate size={16} />
                                    <span className="hidden sm:inline">Tracker</span>
                                </a>
                                <a href="./loot.html" className="flex items-center gap-2 bg-yellow-600 hover:bg-yellow-500 text-white border-2 border-yellow-700 hover:border-yellow-400 px-3 py-1.5 rounded-full text-xs font-bold transition-all no-underline shadow-[0_0_15px_rgba(234,179,8,0.5)] hover:shadow-[0_0_25px_rgba(234,179,8,0.8)] hover:scale-105 active:scale-95">
                                    <div className="bg-black/30 rounded-full p-0.5"><Gem size={14} className="text-white" /></div>
                                    <span className="hidden sm:inline">Loot</span>
                                </a>
                                <a href="./homebrew.html" className="flex items-center gap-2 bg-green-900 hover:bg-green-800 text-white px-3 py-2 rounded-full text-xs font-bold transition-all shadow-[0_0_15px_rgba(22,163,74,0.5)] border border-green-700 hover:border-green-500 hover:shadow-[0_0_25px_rgba(22,163,74,0.8)] hover:scale-105 active:scale-95 no-underline">
                                    <FlaskConical size={14}/>
                                    <span className="hidden sm:inline">Workshop</span>
                                </a>

                                {/* Divider */}
                                <div className="w-px bg-slate-700 mx-1"></div>

                                {/* Controls */}
                                <button onClick={syncData} className="glass-panel p-3 text-slate-400 hover:text-white transition-colors active:scale-95" title="Force Sync">
                                    <RefreshCw size={20} />
                                </button>
                                <a href="./index.html" className="glass-panel p-3 text-slate-400 hover:text-white transition-colors active:scale-95 no-underline" title="Back to Hub">
                                    <Home size={20} />
                                </a>
                            </div>
                        </header>

                        {/* BOTTOM PANELS */}
                        <div className="flex justify-between items-end pb-4">
                            
                            {/* SELECTED ENTITY CARD */}
                            <div className={`transition-all duration-300 transform ${selectedCombatant ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0 pointer-events-none'}`}>
                                {selectedCombatant && (
                                    <div className="glass-panel p-4 w-64 interactive-ui border-l-4 border-l-cyan-500">
                                        <div className="flex justify-between items-start mb-2">
                                            <h2 className="text-lg font-bold text-white truncate">{selectedCombatant.name}</h2>
                                            <span className={`text-[10px] uppercase font-bold px-2 py-0.5 rounded ${selectedCombatant.type === 'player' ? 'bg-indigo-900 text-indigo-300' : 'bg-red-900 text-red-300'}`}>
                                                {selectedCombatant.type}
                                            </span>
                                        </div>
                                        
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center bg-slate-900/50 p-2 rounded">
                                                <span className="text-xs text-slate-400">Health</span>
                                                <span className={`text-sm font-mono font-bold ${getHealthColor(selectedCombatant.currentHp, selectedCombatant.maxHp)}`}>
                                                    {selectedCombatant.currentHp} / {selectedCombatant.maxHp}
                                                </span>
                                            </div>
                                            <div className="flex justify-between items-center bg-slate-900/50 p-2 rounded">
                                                <span className="text-xs text-slate-400">AC</span>
                                                <span className="text-sm font-mono font-bold text-slate-200">{selectedCombatant.ac}</span>
                                            </div>
                                            {selectedCombatant.conditions && selectedCombatant.conditions.length > 0 && (
                                                <div className="flex flex-wrap gap-1 mt-2">
                                                    {selectedCombatant.conditions.map(c => (
                                                        <span key={c} className="text-[10px] bg-yellow-900/30 text-yellow-500 border border-yellow-700/50 px-1.5 py-0.5 rounded">
                                                            {c}
                                                        </span>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* CONTROLS HINT */}
                            <div className="glass-panel px-4 py-2 interactive-ui hidden sm:flex items-center gap-4 text-xs text-slate-400">
                                <div className="flex items-center gap-2">
                                    <span className="w-4 h-4 border border-slate-500 rounded flex items-center justify-center">L</span> Select
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="w-4 h-4 border border-slate-500 rounded flex items-center justify-center">R</span> Rotate
                                </div>
                                <div className="flex items-center gap-2">
                                    <Compass size={12}/> Scroll to Zoom
                                </div>
                            </div>

                        </div>
                    </div>
                    
                    {/* LOADING OVERLAY (If no data) */}
                    {combatants.length === 0 && (
                        <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none">
                            <div className="text-center">
                                <div className="animate-pulse-slow text-slate-500 font-serif text-2xl mb-2">The Astral Void is Empty</div>
                                <div className="text-slate-600 text-sm">Add combatants in the <span className="text-red-400 font-bold">Tracker</span> to see them here.</div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>