<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Akashic Atlas | 3D Voxel Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: ui-sans-serif, system-ui, sans-serif; user-select: none; touch-action: none; -webkit-touch-callout: none; overscroll-behavior: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .interactive { pointer-events: auto; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; transition: opacity 0.2s; }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: rgba(255, 255, 255, 0.9); }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: rgba(255, 255, 255, 0.9); }
        .hotbar-slot { transition: all 0.15s ease-out; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); touch-action: none; }
        .hotbar-slot.active { border-color: #38BDF8; box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); transform: translateY(-4px); z-index: 20; }
        #tooltip { position: absolute; display: none; transform: translate(-50%, -120%); backdrop-filter: blur(8px); z-index: 50; pointer-events: none; }
        .token-item { transition: all 0.2s; }
        .token-item:hover { transform: translateX(4px); background: rgba(51, 65, 85, 0.8); }
        .mode-switch { position: relative; display: flex; background: #0f172a; border-radius: 8px; padding: 4px; border: 1px solid #334155; gap: 4px; flex-wrap: wrap; justify-content: center; }
        .mode-btn { padding: 4px 12px; font-size: 12px; font-weight: bold; border-radius: 6px; color: #94a3b8; transition: all 0.2s; }
        .mode-btn.active { background: #38BDF8; color: #0f172a; box-shadow: 0 0 10px rgba(56, 189, 248, 0.3); }
        #move-badge { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #6ee7b7; font-weight: bold; padding: 6px 16px; border-radius: 20px; backdrop-filter: blur(4px); display: none; text-shadow: 0 1px 2px black; }
        #save-indicator { position: absolute; bottom: 80px; right: 20px; background: rgba(0,0,0,0.7); color: #aaa; padding: 5px 10px; border-radius: 5px; font-size: 12px; pointer-events: none; transition: opacity 0.5s; opacity: 0; }
        #save-indicator.visible { opacity: 1; }
        #slots-modal { display: none; }
        #slots-modal.open { display: flex; }
        #focus-controls { display: none; position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%); gap: 10px; align-items: center; pointer-events: auto; }
        #focus-controls.visible { display: flex; }
        .focus-nav-btn { background: rgba(15, 23, 42, 0.9); color: white; border: 1px solid #334155; width: 40px; height: 40px; border-radius: 50%; display: flex; items-center; justify-content: center; font-weight: bold; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .focus-nav-btn:hover { background: #38BDF8; color: #0f172a; transform: scale(1.1); }
        .focus-label { background: rgba(15, 23, 42, 0.9); color: white; padding: 8px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; border: 1px solid #334155; min-width: 150px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #next-turn-btn { position: absolute; top: 130px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #4f46e5, #ec4899); border: 2px solid #a5b4fc; box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); padding: 8px 24px; border-radius: 99px; color: white; font-weight: bold; font-size: 14px; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: all 0.2s; z-index: 50; touch-action: none; }
        #next-turn-btn:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 25px rgba(99, 102, 241, 0.8); }
        #next-turn-btn.hidden { display: none; }
        .turn-active-glow { box-shadow: 0 0 30px 10px rgba(255, 215, 0, 0.6); }
        .dropdown-content { display: none; position: absolute; right: 0; top: 100%; background-color: #1e293b; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 50; border-radius: 0.5rem; border: 1px solid #334155; margin-top: 0.5rem;}
        .dropdown-content.show { display: block; }
        .dropdown-content a { text-decoration: none; display: flex; align-items: center; gap: 8px; font-size: 0.75rem; font-weight: 700; padding: 8px; }
        .app-link-btn { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background-color: #1e293b; color: #94a3b8; border: 1px solid #334155; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 700; transition: all 0.2s; width: 100%; margin-bottom: 4px; }
        .app-link-btn:last-child { margin-bottom: 0; }
        .app-link-btn:hover { background-color: #334155; color: #fff; border-color: #475569; }
        .app-link-tome:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-homebrew:hover { border-color: #f59e0b; color: #fcd34d; }
        .app-link-loot:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-campaign:hover { border-color: #10b981; color: #6ee7b7; }
        @media (max-width: 1024px) { 
            #ui-layer { padding: 10px; }
            .mode-switch { justify-content: space-between; }
            .mode-btn { padding: 6px 8px; font-size: 10px; flex-grow: 1; text-align: center; }
            #instructions { display: none !important; }
            #hotbar-wrapper { bottom: 10px; z-index: 60; position: relative; }
            .hotbar-slot { width: 40px; height: 40px; }
            #next-turn-btn { top: auto; bottom: 200px; }
            #sidebar-container { display: none; }
            .header-controls { flex-wrap: wrap; justify-content: center; gap: 5px; }
            .header-controls button { padding: 6px 10px; font-size: 10px; }
            #move-badge { bottom: 140px; }
        }
        
        @media (max-height: 500px) and (orientation: landscape) {
            #mobile-build-actions {
                bottom: 10px !important;
                right: 20px !important;
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 8px !important;
            }
            .build-btn { width: 45px !important; height: 45px !important; }
            #mobile-vertical-controls {
                bottom: 10px !important;
                left: 20px !important;
            }
            .vert-btn { width: 40px !important; height: 40px !important; }
            #hotbar-wrapper { bottom: 0 !important; transform: scale(0.8); transform-origin: bottom center; }
            #next-turn-btn { bottom: 80px !important; }
            #move-badge { bottom: 80px !important; }
        }

        #mobile-controls { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        .touch-zone-left { position: absolute; top: 60px; bottom: 0; left: 0; width: 50%; pointer-events: auto; touch-action: none; }
        .touch-zone-right { position: absolute; top: 60px; bottom: 0; right: 0; width: 50%; pointer-events: auto; touch-action: none; }
        #joystick-ui { position: absolute; width: 100px; height: 100px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; display: none; pointer-events: none; transform: translate(-50%, -50%); }
        #joystick-knob { position: absolute; left: 50%; top: 50%; width: 40px; height: 40px; background: rgba(56, 189, 248, 0.5); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(56, 189, 248, 0.8); }
        #mobile-build-actions { display: flex; flex-direction: column; gap: 15px; pointer-events: auto; position: absolute; bottom: 140px; right: 20px; z-index: 50; }
        .build-btn { width: 60px; height: 60px; background: rgba(30, 41, 59, 0.95); border: 2px solid #475569; border-radius: 50%; color: white; display: flex; items-center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.1s; touch-action: none; }
        .build-btn:active { transform: scale(0.95); }
        .build-btn.place-btn { border-color: #10b981; color: #10b981; background: rgba(6, 78, 59, 0.9); }
        .build-btn.break-btn { border-color: #ef4444; color: #ef4444; background: rgba(127, 29, 29, 0.9); }
        .build-btn.fly-btn { border-color: #eab308; color: #fef08a; background: rgba(113, 63, 18, 0.9); font-size: 10px; font-weight: bold; }
        .build-btn.fly-btn.active { background: #eab308; color: black; box-shadow: 0 0 15px rgba(234, 179, 8, 0.6); }
        .build-btn.rotate-btn { border-color: #818cf8; color: #a5b4fc; background: rgba(49, 46, 129, 0.9); }
        #mobile-vertical-controls { display: none; flex-direction: column; gap: 10px; position: absolute; bottom: 160px; left: 160px; pointer-events: auto; z-index: 50; }
        .vert-btn { width: 50px; height: 50px; background: rgba(15, 23, 42, 0.8); border: 2px solid #64748b; border-radius: 12px; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5); touch-action: none; }
        .vert-btn:active { background: #38BDF8; color: black; }
        #controls-modal { display: none; }
        #controls-modal.open { display: flex; }
    </style>
</head>
<body>
    <div id="ui-layer" class="flex flex-col justify-between h-full p-4">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="interactive bg-slate-900/90 border border-slate-700 p-3 rounded-xl shadow-xl backdrop-blur-sm flex flex-col gap-2 w-full md:w-auto">
                <div class="flex items-center justify-between gap-4">
                    <h1 class="text-xl font-bold text-white flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22d3ee" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
                        <span class="hidden md:inline">Akashic Atlas</span>
                        <span class="md:hidden">Atlas</span>
                    </h1>
                    <div class="mode-switch">
                        <button id="mode-build" class="mode-btn active">BUILD</button>
                        <button id="mode-dm" class="mode-btn">DM</button>
                        <button id="mode-players" class="mode-btn text-blue-400">PLAYERS</button>
                        <button id="mode-enemies" class="mode-btn text-red-400">ENEMIES</button>
                    </div>
                </div>
                <div class="text-xs text-slate-400 font-mono flex gap-3 justify-center md:justify-start">
                    <span id="coord-display">0, 0, 0</span> | <span id="block-count">0 Blocks</span> | <span id="current-map-name" class="text-amber-400 font-bold">Default Map</span>
                </div>
            </div>

            <div class="header-controls flex gap-2 relative flex-wrap justify-end w-full md:w-auto">
                <button id="btn-input-toggle" class="interactive bg-slate-800 border border-slate-600 p-2 rounded-lg text-slate-400 hover:text-white transition-colors shadow-lg" title="Change Controls"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg></button>
                <button id="btn-atmosphere" class="interactive bg-slate-800 border border-amber-500/50 p-2 rounded-lg text-amber-400 hover:bg-slate-700 transition-colors shadow-lg" title="Toggle Day/Night"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button>
                <div class="w-px h-10 bg-slate-700/50 mx-1 hidden md:block"></div>
                <button id="btn-sync" class="interactive bg-indigo-600 hover:bg-indigo-500 border border-indigo-400 text-white text-xs font-bold px-4 py-2 rounded-lg shadow-lg transition-all flex items-center gap-2">Sync</button>
                <button id="btn-slots" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-amber-400 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg> Maps</button>
                <button id="btn-export" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Export</button>
                <button id="btn-import" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Import</button>
                <button id="btn-clear" class="interactive bg-red-900/30 hover:bg-red-900/80 border border-red-800/50 text-red-200 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Clear</button>
                <input type="file" id="file-input" accept=".json" class="hidden">
                
                <div class="dropdown interactive relative">
                    <button id="btn-apps-dropdown" class="bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2">
                        Apps <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                    </button>
                    <div id="apps-dropdown-content" class="dropdown-content p-2">
                        <a href="tome.html" target="_blank" class="app-link-btn app-link-tome"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></svg> Tome</a>
                        <a href="homebrew.html" target="_blank" class="app-link-btn app-link-homebrew"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"/><path d="M8.5 2h7"/><path d="M7 16h10"/></svg> Homebrew</a>
                        <a href="loot.html" target="_blank" class="app-link-btn app-link-loot"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></svg> Loot</a>
                        <a href="campaign.html" target="_blank" class="app-link-btn app-link-campaign"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg> Campaign</a>
                    </div>
                </div>
            </div>
        </div>
        <div id="sidebar-container" class="absolute left-4 top-32 bottom-32 w-64 interactive overflow-y-auto pr-2 hidden sm:block"></div>
        
        <div id="focus-controls" class="interactive">
            <button id="focus-prev" class="focus-nav-btn">&lt;</button>
            <div id="focus-label" class="focus-label">No Target</div>
            <button id="focus-next" class="focus-nav-btn">&gt;</button>
        </div>

        <button id="next-turn-btn" class="interactive hidden">
            <span>Next</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>
        </button>

        <div id="instructions" class="interactive absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-900/95 border border-cyan-500/50 p-8 rounded-2xl text-center shadow-[0_0_50px_rgba(6,182,212,0.2)] backdrop-blur-md cursor-pointer hover:border-cyan-400 transition-all z-50 group">
            <h2 class="text-3xl font-bold text-white mb-2 group-hover:scale-105 transition-transform">Click to Enter</h2>
            <div id="instr-build" class="space-y-2 text-slate-300 text-sm mt-4 text-left grid grid-cols-2 gap-x-6">
                <div><span class="text-cyan-400 font-bold">WASD</span> Move</div>
                <div><span class="text-cyan-400 font-bold">Space / C</span> Fly</div>
                <div><span class="text-red-400 font-bold">L-Click</span> Delete</div>
                <div><span class="text-cyan-400 font-bold">R-Click</span> Place</div>
                <div><span class="text-green-400 font-bold">R</span> Rotate</div>
                <div><span class="text-indigo-400 font-bold">Shift + R</span> Focus</div>
                <div><span class="text-yellow-400 font-bold">F</span> Toggle Fly</div>
            </div>
            <div id="instr-dm" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">WASD</span> Free Cam</div>
                <div><span class="text-indigo-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Select</div>
                <div><span class="text-red-400 font-bold">Esc</span> Release</div>
            </div>
            <div id="instr-focus" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Move</div>
                <div><span class="text-indigo-400 font-bold">Tab</span> Snap</div>
                <div><span class="text-amber-400 font-bold">Scroll</span> Zoom</div>
            </div>
        </div>
        <div id="mouse-mode-badge" class="absolute top-32 left-1/2 -translate-x-1/2 bg-yellow-500/20 border border-yellow-500 text-yellow-200 px-4 py-1 rounded-full text-xs font-bold uppercase tracking-wider backdrop-blur hidden">Mouse Cursor Active (Tab)</div>
        <div id="move-badge">Movement: 30ft</div>
        
        <div id="mobile-controls">
            <div id="zone-move" class="touch-zone-left"></div>
            <div id="zone-look" class="touch-zone-right"></div>
            <div id="joystick-ui"><div id="joystick-knob"></div></div>
            <div id="mobile-vertical-controls">
                <button id="mob-up" class="vert-btn">▲</button>
                <button id="mob-down" class="vert-btn">▼</button>
            </div>
            <div id="mobile-build-actions">
                <button id="mob-place" class="build-btn place-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg></button>
                <button id="mob-break" class="build-btn break-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                <button id="mob-rotate" class="build-btn rotate-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                <button id="mob-fly" class="build-btn fly-btn">FLY</button>
            </div>
        </div>

        <div id="save-indicator">Saving...</div>

        <div class="interactive mt-auto w-full flex flex-col items-center" id="hotbar-wrapper">
            <div class="bg-black/80 text-slate-400 text-[10px] uppercase tracking-widest px-3 py-1 rounded-t-lg font-bold border-t border-x border-slate-800/50">Hold # & Scroll / Touch</div>
            <div id="hotbar" class="flex gap-2 p-3 bg-slate-900/90 border border-slate-700 rounded-2xl shadow-2xl backdrop-blur-md overflow-x-auto max-w-full"></div>
        </div>
    </div>

    <div id="slots-modal" class="interactive fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 shadow-2xl flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> Select Map</h2>
                <button id="close-slots" class="text-slate-400 hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
            </div>
            <div class="p-4 overflow-y-auto space-y-2 flex-1" id="slots-list"></div>
            <div class="p-4 border-t border-slate-700 bg-slate-800 rounded-b-xl">
                <div class="flex gap-2">
                    <input type="text" id="new-map-name" placeholder="New Map Name" class="flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm text-white focus:outline-none focus:border-indigo-500">
                    <button id="create-map-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded text-sm">Create</button>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-modal" class="interactive fixed inset-0 z-[110] bg-black/90 backdrop-blur-md flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-lg rounded-2xl border-2 border-indigo-500/50 shadow-[0_0_50px_rgba(99,102,241,0.2)] p-8 text-center">
            <h2 class="text-2xl font-bold text-white mb-2">Select Control Scheme</h2>
            <p class="text-slate-400 mb-8">Choose how you want to interact with the world.</p>
            
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                <button id="scheme-mouse" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-indigo-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-400 group-hover:scale-110 transition-transform"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Keyboard & Mouse</div>
                        <div class="text-xs text-slate-400 mt-1">WASD to Move<br>Pointer Lock Look</div>
                    </div>
                </button>

                <button id="scheme-touch" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-cyan-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-cyan-400 group-hover:scale-110 transition-transform"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Touchscreen</div>
                        <div class="text-xs text-slate-400 mt-1">Virtual Joystick<br>Swipe to Look</div>
                    </div>
                </button>
            </div>
            <p class="text-[10px] text-slate-500">You can change this later from the top menu.</p>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="tooltip" class="bg-slate-900/95 border border-slate-600 rounded-lg p-3 text-white shadow-xl min-w-[150px]"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            worldSize: 64,
            colors: { 
                bgNight: 0x020617, bgDay: 0x87CEEB, highlight: 0x38BDF8, delete: 0xEF4444, valid: 0x10b981, invalid: 0xEF4444,
                monster: 0xef4444, player: 0x3b82f6
            },
            moveSpeed: 30, blockSize: 5
        };

        const CONDITION_COLORS = { "Blinded":0x525252,"Charmed":0xdb2777,"Deafened":0x94a3b8,"Frightened":0x7c3aed,"Grappled":0xf97316,"Incapacitated":0xdc2626,"Invisible":0xffffff,"Paralyzed":0xfacc15,"Petrified":0x475569,"Poisoned":0x16a34a,"Prone":0x78350f,"Restrained":0x9a3412,"Stunned":0xf59e0b,"Unconscious":0x000000,"Exhaustion":0x7f1d1d,"Default":0x38BDF8 };
        
        // ---- TEXTURE GENERATION HELPER ----
        const TextureGenerator = {
            createCanvas(width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            },
            brick(color, groutColor) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + groutColor.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                const brickH = 14; const brickW = 28;
                ctx.fillRect(0, 2, brickW, brickH); ctx.fillRect(brickW + 2, 2, brickW, brickH); ctx.fillRect((brickW * 2) + 4, 2, brickW, brickH);
                ctx.fillRect(-10, 18, brickW, brickH); ctx.fillRect(16, 18, brickW, brickH); ctx.fillRect(16 + brickW + 2, 18, brickW, brickH);
                ctx.fillRect(0, 34, brickW, brickH); ctx.fillRect(brickW + 2, 34, brickW, brickH);
                ctx.fillRect(-10, 50, brickW, brickH); ctx.fillRect(16, 50, brickW, brickH); ctx.fillRect(16 + brickW + 2, 50, brickW, brickH);
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            wood(color, darkColor) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#' + darkColor.toString(16).padStart(6, '0');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, 21); ctx.lineTo(w, 21); ctx.moveTo(0, 42); ctx.lineTo(w, 42); ctx.stroke();
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let i=0; i<40; i++) { ctx.fillRect(Math.random()*w, Math.random()*h, 4, 1); }
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            cobblestone(color) {
                const w = 64, h = 64; const canvas = this.createCanvas(w, h); const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + (color-0x111111).toString(16).padStart(6, '0'); ctx.fillRect(0,0,w,h);
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                for(let i=0; i<15; i++) {
                    const x = Math.random()*w, y = Math.random()*h, s = 10 + Math.random()*15;
                    ctx.beginPath(); ctx.roundRect(x, y, s, s, 5); ctx.fill();
                    ctx.beginPath(); ctx.roundRect(x-w, y, s, s, 5); ctx.fill(); ctx.beginPath(); ctx.roundRect(x, y-h, s, s, 5); ctx.fill();
                }
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
            },
            bars(color) {
                const w = 64, h = 64; const canvas = this.createCanvas(w, h); const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0,0,w,4); ctx.fillRect(0,h-4,w,4); ctx.fillRect(0,0,4,h); ctx.fillRect(w-4,0,4,h);
                for(let i=12; i<w; i+=12) ctx.fillRect(i, 0, 4, h);
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
            },
            character(type, color) {
                const w = 64, h = 64; const canvas = this.createCanvas(w, h); const ctx = canvas.getContext('2d');
                if (type === 'hero') {
                    ctx.fillStyle = '#cbd5e1'; ctx.beginPath(); ctx.arc(32, 32, 20, Math.PI, 0); ctx.lineTo(52, 50); ctx.lineTo(12, 50); ctx.fill();
                    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0'); ctx.fillRect(28, 20, 8, 25); ctx.fillRect(18, 25, 28, 6);
                } else {
                    ctx.fillStyle = '#f1f5f9'; ctx.beginPath(); ctx.arc(32, 28, 18, 0, Math.PI*2); ctx.fill(); ctx.fillRect(22, 40, 20, 12);
                    ctx.fillStyle = '#0f172a'; ctx.beginPath(); ctx.arc(25, 28, 5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(39, 28, 5, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(32, 34); ctx.lineTo(29, 40); ctx.lineTo(35, 40); ctx.fill();
                }
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
            },
            effect(type, color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Helper for converting hex integer to string
                const hex = '#' + color.toString(16).padStart(6, '0');
                
                if (type === 'mushroom') {
                    // Classic Toadstool
                    ctx.fillStyle = '#eee'; // Stem
                    ctx.fillRect(w/2 - 6, h/2, 12, h/2);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.arc(w/2, h/2, 20, Math.PI, 0);
                    ctx.fill();
                    // Spots
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(w/2 - 10, h/2 - 10, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w/2 + 8, h/2 - 5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w/2, h/2 - 15, 3, 0, Math.PI*2); ctx.fill();
                } else if (type === 'mushroomFlat') {
                    // Wide Flat Mushroom
                    ctx.fillStyle = '#dcb'; // Stem
                    ctx.fillRect(w/2 - 5, h/2 + 5, 10, h/2 - 5);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.ellipse(w/2, h/2 + 5, 25, 8, 0, Math.PI, 0);
                    ctx.fill();
                } else if (type === 'mushroomTall') {
                    // Tall Thin Glowshroom
                    ctx.fillStyle = '#eee'; // Stem
                    ctx.fillRect(w/2 - 3, h/3, 6, h - h/3);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.moveTo(w/2 - 10, h/3 + 5);
                    ctx.quadraticCurveTo(w/2, h/3 - 15, w/2 + 10, h/3 + 5);
                    ctx.lineTo(w/2, h/3 + 2); // dimple underneath
                    ctx.fill();
                    // Glow particles
                    ctx.fillStyle = hex;
                    for(let i=0; i<5; i++) ctx.fillRect(w/2 + (Math.random()-0.5)*30, h/2 + (Math.random()-0.5)*30, 2, 2);
                } else if (type === 'grass') {
                    // Initial draw for icon
                    ctx.strokeStyle = hex; ctx.lineWidth = 4;
                    for(let i=0; i<12; i++) {
                        ctx.beginPath(); ctx.moveTo(i*5 + 2, h);
                        ctx.quadraticCurveTo(i*5 + 2 + (Math.random()-0.5)*10, h/2, i*5 + 2 + (Math.random()-0.5)*20, 5);
                        ctx.stroke();
                    }
                } else if (type === 'fire' || type === 'bubbles' || type === 'swirls') {
                    // Simple icon draw
                    ctx.fillStyle = hex; ctx.fillRect(16, 16, 32, 32);
                } else if (type === 'spikes') {
                    ctx.fillStyle = '#94a3b8'; // Metal
                    for(let i=0; i<3; i++) {
                         for(let j=0; j<3; j++) {
                             ctx.beginPath(); ctx.moveTo(10+i*20, 60-j*20); ctx.lineTo(15+i*20, 10-j*20); ctx.lineTo(20+i*20, 60-j*20); ctx.fill();
                         }
                    }
                } else if (type === 'torch') {
                    ctx.fillStyle = '#451a03'; ctx.fillRect(28, 30, 8, 34);
                    ctx.fillStyle = '#525252'; ctx.fillRect(26, 20, 12, 10);
                    ctx.fillStyle = '#ea580c'; ctx.beginPath(); ctx.arc(32, 18, 8, 0, Math.PI*2); ctx.fill();
                }

                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            loot(type) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                if (type === 'gold') {
                    // Gold Pouch
                    ctx.fillStyle = '#8B4513'; // Sack Brown
                    ctx.beginPath();
                    ctx.arc(32, 45, 15, 0, Math.PI * 2); // Main bag
                    ctx.fill();
                    ctx.fillStyle = '#A0522D'; // Darker top
                    ctx.beginPath();
                    ctx.moveTo(22, 35); ctx.lineTo(42, 35); ctx.lineTo(38, 25); ctx.lineTo(26, 25); ctx.fill(); // Neck
                    ctx.strokeStyle = '#DAA520'; // Gold string
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(22, 35); ctx.lineTo(42, 35); ctx.stroke();
                    // Symbol
                    ctx.fillStyle = '#FFD700'; ctx.font = 'bold 20px monospace'; ctx.fillText('G', 26, 52);
                } else if (type === 'sword') {
                    // Sword
                    ctx.translate(32, 32); ctx.rotate(Math.PI / 4); ctx.translate(-32, -32); // Rotate 45deg
                    ctx.fillStyle = '#C0C0C0'; // Blade
                    ctx.fillRect(28, 10, 8, 40); 
                    ctx.beginPath(); ctx.moveTo(28, 10); ctx.lineTo(32, 2); ctx.lineTo(36, 10); ctx.fill(); // Tip
                    ctx.fillStyle = '#8B4513'; // Hilt
                    ctx.fillRect(20, 50, 24, 4); // Guard
                    ctx.fillRect(30, 50, 4, 12); // Handle
                    ctx.fillStyle = '#DAA520'; // Pommel
                    ctx.beginPath(); ctx.arc(32, 64, 3, 0, Math.PI*2); ctx.fill();
                } else if (type === 'potion') {
                    // Potion
                    ctx.fillStyle = '#ef4444'; // Red Liquid
                    ctx.beginPath(); ctx.arc(32, 45, 14, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Glass
                    ctx.beginPath(); ctx.arc(32, 45, 14, 0, Math.PI*2); ctx.fill();
                    ctx.fillRect(26, 20, 12, 15); // Neck
                    ctx.fillStyle = '#8B4513'; // Cork
                    ctx.fillRect(24, 16, 16, 6);
                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath(); ctx.arc(28, 40, 4, 0, Math.PI*2); ctx.fill();
                }

                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            chest(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                // Base Wood
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0,0,w,h);
                // Iron Bands
                ctx.fillStyle = '#555';
                ctx.fillRect(0, 10, w, 4);
                ctx.fillRect(0, 50, w, 4);
                ctx.fillRect(10, 0, 4, h);
                ctx.fillRect(50, 0, 4, h);
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(28, 24, 8, 10);
                
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            noise(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Base Color
                const hex = '#' + color.toString(16).padStart(6, '0');
                ctx.fillStyle = hex;
                ctx.fillRect(0,0,w,h);
                
                // Noise
                for(let i=0; i<400; i++) {
                    const x = Math.floor(Math.random() * w);
                    const y = Math.floor(Math.random() * h);
                    const shade = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                    ctx.fillStyle = shade;
                    ctx.fillRect(x, y, 2, 2);
                }
                
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            bookshelf(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Wood Frame
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, w, h);
                
                // Shelves background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(4, 4, w-8, h-8);
                
                // Books
                const colors = ['#8B0000', '#00008B', '#006400', '#4B0082', '#A52A2A'];
                const drawRow = (y, h) => {
                    let x = 6;
                    while(x < w - 10) {
                        const bw = 4 + Math.random() * 6;
                        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                        ctx.fillRect(x, y, bw, h);
                        x += bw + 1;
                    }
                };
                
                drawRow(8, 20); // Top shelf
                drawRow(36, 20); // Bottom shelf
                
                // Wood Shelf divider
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0, 30, w, 4);
                
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            barrel(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Vertical Planks
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0,0,w,h);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                for(let x=10; x<w; x+=12) ctx.fillRect(x, 0, 2, h);
                
                // Metal Hoops
                ctx.fillStyle = '#555';
                ctx.fillRect(0, 10, w, 6);
                ctx.fillRect(0, h-16, w, 6);
                
                // Top/Bottom shading
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0,0,w,4);
                ctx.fillRect(0,h-4,w,4);

                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            obsidian(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Deep Dark Purple/Black Base
                ctx.fillStyle = '#150a15'; 
                ctx.fillRect(0, 0, w, h);
                
                // Purple Waving Lines
                ctx.strokeStyle = '#a855f7'; // Purple-500
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                for(let i=0; i<6; i++) {
                    const x = Math.random() * (w - 10) + 5;
                    const y = Math.random() * (h - 20);
                    const height = 15 + Math.random() * 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    // Draw a wavy vertical line
                    ctx.bezierCurveTo(x - 3, y + height * 0.3, x + 3, y + height * 0.6, x, y + height);
                    ctx.stroke();
                }
                
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            snow(color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Light Grey Base
                ctx.fillStyle = '#cbd5e1'; // Slate-300
                ctx.fillRect(0, 0, w, h);
                
                // White Spots
                ctx.fillStyle = '#ffffff';
                for(let i=0; i<60; i++) {
                    const x = Math.floor(Math.random() * w);
                    const y = Math.floor(Math.random() * h);
                    const size = Math.random() > 0.7 ? 2 : 1;
                    ctx.fillRect(x, y, size, size);
                }
                
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            }
        };

        // --- UPDATED MATERIALS ---
        const MATERIALS = [
            { id: 0, name: "Grass", color: 0x4b6e32, type: 'textured_noise' }, 
            { id: 1, name: "Dirt", color: 0x5c3c28, type: 'textured_noise' },  
            { id: 2, name: "Stone", color: 0x64748b, type: 'textured_noise' }, 
            { id: 3, name: "Wood Planks", color: 0x8B4513, type: 'textured_wood', color2: 0x5c3c28 }, 
            { id: 4, name: "Sand", color: 0xE6C288, type: 'textured_noise' },  
            { id: 5, name: "Snow", color: 0xf1f5f9, type: 'textured_snow' },  // UPDATED
            { id: 6, name: "Dungeon Bricks", color: 0x475569, type: 'textured_brick', color2: 0x1e293b }, 
            { id: 7, name: "Red Bricks", color: 0x8f3636, type: 'textured_brick', color2: 0x5c3c28 }, 
            { id: 8, name: "Water", color: 0x38BDF8, type: 'liquid', opacity: 0.6 },
            { id: 9, name: "Lava", color: 0xea580c, type: 'liquid', opacity: 0.8 },
            { id: 10, name: "Acid", color: 0x84cc16, type: 'liquid', opacity: 0.6 },
            { id: 11, name: "Poison", color: 0x14532d, type: 'liquid', opacity: 0.7 },
            { id: 12, name: "Wood Stairs", color: 0x8B4513, type: 'stair_wood', color2: 0x5c3c28 },
            { id: 13, name: "Dungeon Stairs", color: 0x475569, type: 'stair_brick', color2: 0x1e293b },
            { id: 14, name: "Red Brick Stairs", color: 0x8f3636, type: 'stair_brick', color2: 0x5c3c28 },
            { id: 15, name: "Obsidian", color: 0x181018, type: 'textured_obsidian' }, // UPDATED
            { id: 16, name: "Obsidian Bricks", color: 0x2d2038, type: 'textured_brick', color2: 0x0f0a14 },
            { id: 17, name: "Obsidian Stairs", color: 0x2d2038, type: 'stair_brick', color2: 0x0f0a14 },
            { id: 18, name: "Forcefield", color: 0xa855f7, type: 'liquid', opacity: 0.4 },
            { id: 19, name: "Tall Grass", color: 0x4b6e32, type: 'topper_grass' },
            { id: 20, name: "Fire", color: 0xff4500, type: 'topper_fire' },
            { id: 21, name: "Bubbles", color: 0x84cc16, type: 'topper_bubbles' },
            { id: 22, name: "Swirls", color: 0xd8b4fe, type: 'topper_swirls' },
            { id: 23, name: "Toadstool", color: 0xef4444, type: 'topper_mushroom' },
            { id: 24, name: "Brown Shroom", color: 0x8B4513, type: 'topper_mushroomFlat' },
            { id: 25, name: "Glow Shroom", color: 0x22d3ee, type: 'topper_mushroomTall' },
            { id: 26, name: "Chest", color: 0x8B4513, type: 'model_chest' },
            { id: 27, name: "Table", color: 0x8B4513, type: 'model_table', color2: 0x5c3c28 },
            { id: 28, name: "Chair", color: 0x8B4513, type: 'model_chair', color2: 0x5c3c28 },
            { id: 29, name: "Bookshelf", color: 0x8B4513, type: 'textured_books' }, 
            { id: 30, name: "Barrel", color: 0x8B4513, type: 'model_barrel' }, 
            { id: 31, name: "Iron Bars", color: 0x475569, type: 'textured_bars', opacity: 1 }, 
            { id: 32, name: "Cobblestone", color: 0x64748b, type: 'textured_cobble' }, 
            { id: 33, name: "Spikes", color: 0x94a3b8, type: 'topper_spikes' }, 
            { id: 34, name: "Torch", color: 0xffa500, type: 'topper_torch' }, 
        ];
        
        // --- CATEGORIES ---
        const CATEGORIES = [
            { key: '1', label: 'Solid', type: 'block', items: [0, 1, 2, 4, 5, 15] },
            { key: '2', label: 'Textured', type: 'block', items: [3, 6, 7, 12, 13, 14, 16, 17, 32] }, 
            { key: '3', label: 'Liquids', type: 'block', items: [8, 9, 10, 11, 18] },
            { key: '4', label: 'Players', type: 'token', subType: 'player', items: [] }, 
            { key: '5', label: 'Enemies', type: 'token', subType: 'monster', items: [] },
            { key: '6', label: 'Loot', type: 'loot', items: [] }, 
            { key: '7', label: 'Effects', type: 'block', items: [19, 20, 21, 22, 23, 24, 25, 33, 34] }, 
            { key: '8', label: 'Decor', type: 'block', items: [26, 30, 27, 28, 29, 31] }, 
            { key: '9', label: '-', type: 'none', items: [] }, 
            { key: '0', label: '-', type: 'none', items: [] }
        ];

        // --- ANIMATOR ---
        const TextureAnimator = {
            items: [],
            add: (mat, type, color) => {
                const canvas = mat.map.image;
                const ctx = canvas.getContext('2d');
                const data = { particles: [] }; 
                const w=64, h=64;
                
                // Initialize stable random data for smooth animation
                if(type==='grass') {
                    for(let i=0; i<12; i++) data.particles.push({x: Math.random()*w, h: 5+Math.random()*15, lean: (Math.random()-0.5)*20});
                } else if(type==='bubbles') {
                    for(let i=0; i<10; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, r: Math.random()*4+2, s: Math.random()+0.5});
                } else if (type==='swirls') {
                    for(let i=0; i<5; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, r: Math.random()*10+5, a: Math.random()*Math.PI*2});
                } else if (type==='fire' || type==='torch') {
                    for(let i=0; i<10; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, s: Math.random()*3+1});
                }

                TextureAnimator.items.push({ mat, type, color, ctx, w, h, data });
            },
            update: (time) => {
                TextureAnimator.items.forEach(item => {
                    const { mat, type, color, ctx, w, h, data } = item;
                    const t = time * 0.002; 
                    ctx.clearRect(0, 0, w, h);
                    const hex = '#' + color.toString(16).padStart(6, '0');
                    
                    if (type === 'grass') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 4;
                        ctx.beginPath();
                        data.particles.forEach((p, i) => {
                            const sway = Math.sin(t + i) * 10;
                            ctx.moveTo(p.x, h);
                            ctx.quadraticCurveTo(p.x + p.lean + sway, h/2, p.x + p.lean*2 + sway*1.5, p.h);
                        });
                        ctx.stroke();
                    } else if (type === 'bubbles') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 2; ctx.fillStyle='rgba(255,255,255,0.3)';
                        data.particles.forEach(p => {
                            let currY = (p.y - t * 20 * p.s) % (h + 10);
                            if (currY < -10) currY += h + 20;
                            const wobble = Math.sin(t*3 + p.x) * 3;
                            ctx.beginPath(); ctx.arc(p.x + wobble, currY, p.r, 0, Math.PI*2); 
                            ctx.stroke(); ctx.fill();
                        });
                    } else if (type === 'swirls') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 3;
                        data.particles.forEach(p => {
                            const rot = t * 2 + p.a;
                            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, rot, rot + Math.PI*1.5); ctx.stroke();
                        });
                    } else if (type === 'fire') {
                        // Flame Base
                        const g = ctx.createLinearGradient(0, h, 0, 0);
                        g.addColorStop(0, '#ff4500'); g.addColorStop(0.5, '#ffd700'); g.addColorStop(1, 'rgba(255,255,0,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        const flicker = Math.sin(t*10)*2 + Math.cos(t*23)*2;
                        ctx.moveTo(10, h); ctx.quadraticCurveTo(w/2 + flicker, -10, w-10, h); ctx.fill();
                        // Sparks
                        ctx.fillStyle = '#ffff00';
                        data.particles.forEach(p => {
                            let currY = (p.y - t * 40 * p.s) % h;
                            if (currY < 0) currY += h;
                            ctx.fillRect(p.x, currY, p.s, p.s);
                        });
                    } else if (type === 'torch') {
                        // Holder
                        ctx.fillStyle = '#451a03'; ctx.fillRect(28, 30, 8, 34);
                        ctx.fillStyle = '#525252'; ctx.fillRect(26, 20, 12, 10);
                        // Flame Base
                        const g = ctx.createLinearGradient(0, 30, 0, 0);
                        g.addColorStop(0, '#ff4500'); g.addColorStop(0.5, '#ffd700'); g.addColorStop(1, 'rgba(255,255,0,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        const flicker = Math.sin(t*10)*1.5;
                        ctx.arc(32 + flicker, 15, 8, 0, Math.PI*2); ctx.fill();
                        // Sparks
                        ctx.fillStyle = '#ffff00';
                        data.particles.forEach(p => {
                            let currY = (p.y - t * 40 * p.s) % 30;
                            if (currY < 0) currY += 30;
                            ctx.fillRect(32 + (p.x/w - 0.5)*16, currY, p.s, p.s);
                        });
                    }
                    mat.map.needsUpdate = true;
                });
            }
        };

        // --- UPDATED MATERIAL GENERATION ---
        const materials = MATERIALS.map(m => {
            const matConfig = { transparent: !!m.opacity, opacity: m.opacity || 1 };
            if (m.type === 'liquid') { matConfig.color = m.color; matConfig.depthWrite = false; matConfig.side = THREE.DoubleSide; }
            else if (m.type === 'textured_brick' || m.type === 'stair_brick') { matConfig.map = TextureGenerator.brick(m.color, m.color2 || 0x000000); }
            else if (m.type === 'textured_wood' || m.type === 'stair_wood' || m.type === 'model_table' || m.type === 'model_chair') { matConfig.map = TextureGenerator.wood(m.color, m.color2 || 0x000000); }
            else if (m.type === 'textured_noise') { matConfig.map = TextureGenerator.noise(m.color); }
            else if (m.type === 'textured_snow') { matConfig.map = TextureGenerator.snow(m.color); } 
            else if (m.type === 'textured_obsidian') { matConfig.map = TextureGenerator.obsidian(m.color); } 
            else if (m.type === 'textured_books') { matConfig.map = TextureGenerator.bookshelf(m.color); }
            else if (m.type === 'model_chest') { matConfig.map = TextureGenerator.chest(m.color); }
            else if (m.type === 'model_barrel') { matConfig.map = TextureGenerator.barrel(m.color); }
            else if (m.type === 'textured_bars') { matConfig.map = TextureGenerator.bars(m.color); matConfig.transparent = true; matConfig.side = THREE.DoubleSide; }
            else if (m.type === 'textured_cobble') { matConfig.map = TextureGenerator.cobblestone(m.color); }
            else if (m.type.startsWith('topper_')) { 
                matConfig.map = TextureGenerator.effect(m.type.split('_')[1], m.color); 
                matConfig.transparent = true; 
                matConfig.side = THREE.DoubleSide; 
                matConfig.depthWrite = false; 
            }
            else { matConfig.color = m.color; }
            
            const newMat = new THREE.MeshLambertMaterial(matConfig);
            
            // Register for animation if applicable
            if(m.type.startsWith('topper_')) {
                const subType = m.type.split('_')[1];
                if(['grass', 'fire', 'bubbles', 'swirls', 'torch'].includes(subType)) {
                    TextureAnimator.add(newMat, subType, m.color);
                }
            }
            
            return newMat;
        });
        
        // Cache for Loot Materials
        const LootMaterialCache = new Map();
        function getLootMaterial(name) {
            let type = 'gold'; // Default
            if (name.includes('Sword')) type = 'sword';
            if (name.includes('Potion')) type = 'potion';
            
            if (LootMaterialCache.has(type)) return LootMaterialCache.get(type);
            
            const map = TextureGenerator.loot(type);
            const mat = new THREE.MeshLambertMaterial({ map: map, transparent: true, side: THREE.DoubleSide, depthWrite: false });
            LootMaterialCache.set(type, mat);
            return mat;
        }

        const TokenMaterialCache = new Map();
        function getTokenMaterial(type, color) {
            const key = type + color;
            if(TokenMaterialCache.has(key)) return TokenMaterialCache.get(key);
            const tex = TextureGenerator.character(type, color);
            const mat = new THREE.MeshLambertMaterial({ map: tex, transparent: true, side: THREE.DoubleSide, depthWrite: false });
            TokenMaterialCache.set(key, mat);
            return mat;
        }

        const DIRS = [ {x:1,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:-1,z:0}, {x:0,y:0,z:1}, {x:0,y:0,z:-1} ];

        const state = { 
            gameMode: 'build', activeCategoryIdx: 0, subSelections: new Array(10).fill(0), 
            isAtmosphereDay: false, heldKeys: {}, mapData: new Map(), tokenData: new Map(), 
            mode: 'view', dragStart: null, controlledToken: null, focusedToken: null, moveBudget: 30,
            currentMapId: 'default', currentMapName: 'Default Map', autoSaveTimer: null,
            focusIndex: 0, focusList: [], 
            currentTurnIndex: 0,
            isTouch: false, // Updated: controlled by selection
            moveVector: { x: 0, z: 0 }, 
            touch: { id: null, startX: 0, startY: 0, moveX: 0, moveY: 0 },
            placementRotation: 0, // New state for manual rotation
            isInteracting: false // Track if button is held
        };

        const scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bgNight); scene.fog = new THREE.Fog(CONFIG.colors.bgNight, 10, 60);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 5, 10);
        // Force rotation order to prevent roll artifacts
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
        
        // FIX: Re-declare all required variables at the top level
        const controls = new PointerLockControls(camera, document.body);
        const raycaster = new THREE.Raycaster();
        const move = { f:false, b:false, l:false, r:false, u:false, d:false };
        let canJump=false, isFlying=false, velocity = new THREE.Vector3(), prevTime = performance.now();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5); dirLight.position.set(50, 100, 50); scene.add(dirLight);
        const torchLight = new THREE.PointLight(0xffaa00, 1.5, 20); camera.add(torchLight); scene.add(camera);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(64, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({visible:false})); plane.name = "ground"; scene.add(plane);
        scene.add(new THREE.GridHelper(64, 64, 0x334155, 0x1e293b));

        const mouse = new THREE.Vector2();
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        const GeometryManager = {
            cache: new Map(),
            init: () => {
                // Helper to create a BoxGeometry with UVs scaled to match size
                // This prevents texture "squashing" on smaller stair parts
                const createBox = (w, h, d, tx, ty, tz) => {
                    const g = new THREE.BoxGeometry(w, h, d);
                    // Scale UVs
                    const uv = g.attributes.uv;
                    for(let i=0; i<8; i++) { uv.setXY(i, uv.getX(i)*d, uv.getY(i)*h); }
                    for(let i=8; i<16; i++) { uv.setXY(i, uv.getX(i)*w, uv.getY(i)*d); }
                    for(let i=16; i<24; i++) { uv.setXY(i, uv.getX(i)*w, uv.getY(i)*h); }
                    g.translate(tx, ty, tz);
                    return g;
                };

                // --- OCCLUSION MASK GENERATION (0-63) ---
                // This generates geometries for solid/liquid blocks with specific faces removed based on neighbors.
                // Reinstating this restores the "seamless" look for liquids.
                const createFace = (idx) => {
                    const g = new THREE.PlaneGeometry(1, 1);
                    const matrix = new THREE.Matrix4();
                    switch(idx) {
                        case 0: matrix.makeRotationY(Math.PI/2); matrix.setPosition(0.5, 0, 0); break; // +x Right
                        case 1: matrix.makeRotationY(-Math.PI/2); matrix.setPosition(-0.5, 0, 0); break; // -x Left
                        case 2: matrix.makeRotationX(-Math.PI/2); matrix.setPosition(0, 0.5, 0); break; // +y Top
                        case 3: matrix.makeRotationX(Math.PI/2); matrix.setPosition(0, -0.5, 0); break; // -y Bottom
                        case 4: matrix.setPosition(0, 0, 0.5); break; // +z Front
                        case 5: matrix.makeRotationY(Math.PI); matrix.setPosition(0, 0, -0.5); break; // -z Back
                    }
                    g.applyMatrix4(matrix);
                    return g;
                };
                const faces = [0,1,2,3,4,5].map(i => createFace(i));

                for(let m=0; m<64; m++) {
                    const geoms = [];
                    for(let i=0; i<6; i++) {
                        if (!(m & (1 << i))) geoms.push(faces[i].clone());
                    }
                    if(geoms.length > 0) GeometryManager.cache.set(m, BufferGeometryUtils.mergeGeometries(geoms));
                    else GeometryManager.cache.set(m, new THREE.BufferGeometry()); // Fully internal block
                }

                // --- STAIR GEOMETRIES ---
                const slab = createBox(1, 0.5, 1, 0, -0.25, 0); 
                const topBack = createBox(1, 0.5, 0.5, 0, 0.25, -0.25);
                const qTL = createBox(0.5, 0.5, 0.5, -0.25, 0.25, -0.25);
                const qTR = createBox(0.5, 0.5, 0.5, 0.25, 0.25, -0.25);
                const qFL = createBox(0.5, 0.5, 0.5, -0.25, 0.25, 0.25);
                const qFR = createBox(0.5, 0.5, 0.5, 0.25, 0.25, 0.25);

                GeometryManager.cache.set('stair', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone()]));
                GeometryManager.cache.set('stair_outer_left', BufferGeometryUtils.mergeGeometries([slab.clone(), qTL.clone()]));
                GeometryManager.cache.set('stair_outer_right', BufferGeometryUtils.mergeGeometries([slab.clone(), qTR.clone()]));
                GeometryManager.cache.set('stair_inner_left', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone(), qFL.clone()]));
                GeometryManager.cache.set('stair_inner_right', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone(), qFR.clone()]));

                // --- CROSS GEOMETRY (For Grass, Fire, etc.) ---
                const p1 = new THREE.PlaneGeometry(1, 1); p1.rotateY(Math.PI / 4);
                const p2 = new THREE.PlaneGeometry(1, 1); p2.rotateY(-Math.PI / 4);
                GeometryManager.cache.set('cross', BufferGeometryUtils.mergeGeometries([p1, p2]));

                // --- FURNITURE GEOMETRIES ---
                // Chest (Slightly smaller box)
                const chestBox = createBox(0.8, 0.6, 0.8, 0, -0.2, 0);
                GeometryManager.cache.set('chest', chestBox);

                // Table (Leg + Top)
                const tableLeg = createBox(0.2, 0.8, 0.2, 0, -0.1, 0);
                const tableTop = createBox(1, 0.1, 1, 0, 0.35, 0); // Sits on top
                GeometryManager.cache.set('table', BufferGeometryUtils.mergeGeometries([tableLeg, tableTop]));

                // Chair (Legs + Seat + Back)
                const chairSeat = createBox(0.6, 0.1, 0.6, 0, -0.1, 0);
                const chairLeg1 = createBox(0.1, 0.4, 0.1, -0.25, -0.3, -0.25);
                const chairLeg2 = createBox(0.1, 0.4, 0.1, 0.25, -0.3, -0.25);
                const chairLeg3 = createBox(0.1, 0.4, 0.1, -0.25, -0.3, 0.25);
                const chairLeg4 = createBox(0.1, 0.4, 0.1, 0.25, -0.3, 0.25);
                const chairBack = createBox(0.6, 0.6, 0.1, 0, 0.25, -0.25); // Backrest
                GeometryManager.cache.set('chair', BufferGeometryUtils.mergeGeometries([chairSeat, chairLeg1, chairLeg2, chairLeg3, chairLeg4, chairBack]));

                // Barrel (Slightly smaller box, vertical orientation)
                const barrelBox = createBox(0.8, 0.9, 0.8, 0, -0.05, 0);
                GeometryManager.cache.set('barrel', barrelBox);
            },
            get: (m) => {
                if (typeof m === 'string') return GeometryManager.cache.get(m) || GeometryManager.cache.get('stair');
                return GeometryManager.cache.get(m) || GeometryManager.cache.get(0);
            }
        }; GeometryManager.init();

        const tokenGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
        const lootGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);

        const RangeRingManager = {
            group: new THREE.Group(),
            init: () => { scene.add(RangeRingManager.group); RangeRingManager.group.visible = false; },
            update: (targetToken, type = 'movement') => {
                while(RangeRingManager.group.children.length) RangeRingManager.group.remove(RangeRingManager.group.children[0]);
                if(!targetToken) { RangeRingManager.group.visible = false; return; }
                RangeRingManager.group.visible = true;
                RangeRingManager.group.position.copy(targetToken.position);
                RangeRingManager.group.position.y = targetToken.position.y - 0.1 + 0.02;
                const data = targetToken.userData.data;
                const radius = (state.moveBudget / 5); 
                const baseRing = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, opacity: 0.8, transparent: true}));
                RangeRingManager.group.add(baseRing);
                if (type === 'movement' && radius > 0) {
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(Math.max(0.1, radius-0.2), radius, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0x38BDF8, side: THREE.DoubleSide, transparent: true, opacity: 0.4}));
                    RangeRingManager.group.add(mesh);
                } else if (type === 'conditions' || type === 'focus') {
                    const moveRadius = 6; 
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(moveRadius-0.1, moveRadius, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({ color: 0x10b981, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
                    RangeRingManager.group.add(mesh);
                }
            }
        }; RangeRingManager.init();

        const MapStorageManager = {
            getKeys: () => { try { return JSON.parse(localStorage.getItem('akashic_map_index')) || { 'default': 'Default Map' }; } catch { return { 'default': 'Default Map' }; } },
            saveIndex: (idx) => localStorage.setItem('akashic_map_index', JSON.stringify(idx)),
            loadMap: (id) => {
                const idx = MapStorageManager.getKeys();
                if (!idx[id]) return false;
                state.currentMapId = id; state.currentMapName = idx[id];
                const mapNameEl = document.getElementById('current-map-name');
                if (mapNameEl) mapNameEl.innerText = state.currentMapName;
                try {
                    const raw = localStorage.getItem(`akashic_map_${id}_voxels`);
                    WorldManager.clear(false); 
                    if (raw) { JSON.parse(raw).forEach(b => WorldManager.add(b.x, b.y, b.z, b.c, b.r || 0, false)); }
                } catch(e) { console.error("Map Load Error", e); }
                try {
                    const posRaw = localStorage.getItem(`akashic_map_${id}_positions`);
                    const posData = posRaw ? JSON.parse(posRaw) : {};
                    state.tokenData.forEach((mesh, tokenId) => {
                        if (posData[tokenId]) mesh.position.set(posData[tokenId].x, posData[tokenId].y, posData[tokenId].z);
                        else mesh.position.set(0, 2, 0); 
                    });
                } catch(e) {}
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                return true;
            },
            saveMap: () => {
                const voxelData = []; state.mapData.forEach(m => voxelData.push({x:m.position.x, y:m.position.y, z:m.position.z, c:m.userData.matIndex, r: m.rotation.y}));
                localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(voxelData));
                const posData = {}; state.tokenData.forEach((m, id) => { posData[id] = {x:m.position.x, y:m.position.y, z:m.position.z}; });
                localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(posData));
                const ind = document.getElementById('save-indicator'); ind.classList.add('visible'); setTimeout(() => ind.classList.remove('visible'), 1000);
            },
            createMap: (name) => { const id = Date.now().toString(36); const idx = MapStorageManager.getKeys(); idx[id] = name; MapStorageManager.saveIndex(idx); return id; },
            deleteMap: (id) => { 
                if (id === 'default') { console.warn("Cannot delete default map."); return; } 
                const idx = MapStorageManager.getKeys(); delete idx[id]; MapStorageManager.saveIndex(idx); localStorage.removeItem(`akashic_map_${id}_voxels`); localStorage.removeItem(`akashic_map_${id}_positions`); if (state.currentMapId === id) MapStorageManager.loadMap('default'); UIManager.renderSlots(); 
            },
            triggerAutoSave: () => { if (state.autoSaveTimer) clearTimeout(state.autoSaveTimer); state.autoSaveTimer = setTimeout(MapStorageManager.saveMap, 2000); }
        };

        const WorldManager = {
            // Helper to get logic shape for stairs
            getStairShape: (x, y, z, myRot) => {
                const getBlock = (dx, dz) => {
                    const k = `${x+dx},${y},${z+dz}`;
                    const m = state.mapData.get(k);
                    if(m && MATERIALS[m.userData.matIndex].type.startsWith('stair')) return m;
                    return null;
                };

                // Normalize rotation to 0, 90, 180, 270
                let deg = Math.round(myRot * (180/Math.PI));
                while(deg < 0) deg += 360;
                deg = deg % 360;
                
                let frontVec = {x:0, z:0}; // Low Side (Step up)
                let backVec = {x:0, z:0};  // High Side (Wall)
                
                if (deg === 0) { // North
                    backVec = {x:0, z:-1}; frontVec = {x:0, z:1}; 
                } else if (deg === 90) { // West
                    backVec = {x:-1, z:0}; frontVec = {x:1, z:0};
                } else if (deg === 180) { // South
                    backVec = {x:0, z:1}; frontVec = {x:0, z:-1};
                } else if (deg === 270) { // East
                    backVec = {x:1, z:0}; frontVec = {x:-1, z:0};
                }

                const frontNeighbor = getBlock(frontVec.x, frontVec.z);
                const backNeighbor = getBlock(backVec.x, backVec.z);

                const getDeg = (obj) => {
                    let d = Math.round(obj.rotation.y * (180/Math.PI));
                    while(d < 0) d += 360; return d % 360;
                };
                const getDiff = (n) => (getDeg(n) - deg + 360) % 360;

                if (frontNeighbor) {
                    const d = getDiff(frontNeighbor);
                    if (d === 90) return 'stair_inner_left';
                    if (d === 270) return 'stair_inner_right';
                }
                if (backNeighbor) {
                    const d = getDiff(backNeighbor);
                    if (d === 90) return 'stair_outer_left';
                    if (d === 270) return 'stair_outer_right';
                } 
                return 'stair';
            },

            add: (x,y,z,mat, rot = 0, updateGeo=true) => { 
                const k = `${x},${y},${z}`; 
                if(state.mapData.has(k)) return; 
                
                const matDef = MATERIALS[mat];
                let geometry = GeometryManager.get(0);
                
                if (matDef.type.startsWith('stair')) {
                    geometry = GeometryManager.get('stair');
                } else if (matDef.type.startsWith('topper_')) {
                    geometry = GeometryManager.get('cross');
                } else if (matDef.type.startsWith('model_')) {
                    geometry = GeometryManager.get(matDef.type.split('_')[1]); // e.g. model_table -> table
                }

                const m = new THREE.Mesh(geometry, materials[mat]); 
                m.position.set(x,y,z); 
                m.userData={isVoxel:true, matIndex:mat}; 
                m.rotation.y = rot;

                scene.add(m); 
                state.mapData.set(k, m); 
                
                if(updateGeo) { 
                    WorldManager.updateGeo(x,y,z); 
                    DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); 
                    document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; 
                    MapStorageManager.triggerAutoSave(); 
                } 
            },
            remove: (m) => { 
                const {x,y,z} = m.position; 
                scene.remove(m); 
                state.mapData.delete(`${x},${y},${z}`); 
                DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); 
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; 
                MapStorageManager.triggerAutoSave(); 
            },
            updateGeo: (x,y,z) => { 
                const m = state.mapData.get(`${x},${y},${z}`); 
                if(!m) return; 
                
                const matDef = MATERIALS[m.userData.matIndex];

                // STAIR LOGIC
                if (matDef.type.startsWith('stair')) {
                    const shape = WorldManager.getStairShape(x, y, z, m.rotation.y);
                    const newGeo = GeometryManager.get(shape);
                    if(m.geometry !== newGeo) m.geometry = newGeo;
                    return;
                }

                // TOPPER & MODEL LOGIC (No occlusion, static geometry)
                if (matDef.type.startsWith('topper_') || matDef.type.startsWith('model_')) {
                    let geoName = 'cross';
                    if (matDef.type.startsWith('model_')) geoName = matDef.type.split('_')[1];
                    
                    const g = GeometryManager.get(geoName);
                    if (m.geometry !== g) m.geometry = g;
                    return;
                }
                
                // STANDARD OCCLUSION LOGIC
                const isSolid = (idx) => {
                    const t = MATERIALS[idx].type;
                    return t === 'solid' || t === 'textured_brick' || t === 'textured_wood' || t === 'textured_noise' || t === 'textured_books' || t === 'textured_snow' || t === 'textured_obsidian' || t === 'textured_cobble';
                };
                const isLiquid = (idx) => MATERIALS[idx].type === 'liquid';

                let mask = 0; 
                DIRS.forEach((d,i) => { 
                    const n = state.mapData.get(`${x+d.x},${y+d.y},${z+d.z}`); 
                    if (n) {
                        if (isSolid(m.userData.matIndex)) {
                            // Only hide if neighbor is also solid
                            if (isSolid(n.userData.matIndex)) mask |= (1<<i);
                        } else if (isLiquid(m.userData.matIndex)) {
                            // Hide if neighbor is same liquid or solid
                            if (n.userData.matIndex === m.userData.matIndex || isSolid(n.userData.matIndex)) mask |= (1<<i);
                        }
                    }
                }); 
                m.geometry = GeometryManager.get(mask); 
            },
            clear: (updateUI=true) => { state.mapData.forEach(m=>scene.remove(m)); state.mapData.clear(); if(updateUI) { document.getElementById('block-count').innerText = `0 Blocks`; MapStorageManager.triggerAutoSave(); } }
        };

        const EntityManager = {
            sync: () => {
                try {
                    const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters')||'[]');
                    if(!mons.length) { mons.push({id:'p1', name:'Hero', type:'player', currentHp:20, maxHp:20, conditions:['Poisoned']}); mons.push({id:'e1', name:'Goblin', type:'monster', currentHp:7, maxHp:7, conditions:[]}); }
                    CATEGORIES[3].items = mons.filter(c=>c.type==='player'); CATEGORIES[4].items = mons.filter(c=>c.type==='monster');
                    const loot = JSON.parse(localStorage.getItem('dm-loot') || '[]'); if (!loot.length) loot.push({id:'l1', name:'Gold', icon:'💰'}, {id:'l2', name:'Sword', icon:'⚔️'}, {id:'l3', name:'Potion', icon:'🧪'}); CATEGORIES[5].items = loot;
                    
                    state.tokenData.forEach((m,id) => { if(!m.userData.isLoot && !mons.find(c=>c.id===id)) { scene.remove(m); state.tokenData.delete(id); } });
                    
                    mons.forEach((c,i) => { 
                        let m = state.tokenData.get(c.id); 
                        const col = c.type==='monster' ? CONFIG.colors.monster : CONFIG.colors.player; 
                        if(!m) { 
                            // Standee Construction
                            m = new THREE.Group();
                            
                            // Base
                            const baseGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                            const base = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({color: 0x1e293b})); // Dark Slate Base
                            base.position.y = 0.05;
                            m.add(base);
                            
                            // Card Body
                            const cardGeo = new THREE.PlaneGeometry(0.8, 1.2);
                            // Determine type for texture
                            const texType = c.type === 'monster' ? 'monster' : 'hero';
                            const cardMat = getTokenMaterial(texType, col);
                            const card = new THREE.Mesh(cardGeo, cardMat);
                            card.position.y = 0.65;
                            m.add(card);

                            m.userData={isToken:true, id:c.id, data:c}; 
                            scene.add(m); 
                            state.tokenData.set(c.id, m); 
                            m.position.set(i*2, 2, 0); 
                        } else { 
                            // Update existing token data
                            m.userData.data=c; 
                        } 
                    });
                    
                    UIManager.renderHotbar(); UIManager.renderSidebar();
                    EntityManager.updateTurnVisuals();
                } catch(e) { console.error(e); }
            },
            advanceTurn: () => {
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                if (mons.length === 0) return;
                let turn = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                turn = (turn + 1) % mons.length;
                localStorage.setItem('dm-tracker-turn-index', turn);
                state.currentTurnIndex = turn;
                const activeId = mons[turn].id;
                const token = state.tokenData.get(activeId);
                if (token) {
                    const tokenType = mons[turn].type; 
                    if (tokenType === 'player') { setMode('players'); state.focusIndex = state.focusList.indexOf(token); snapCameraTo(token); } 
                    else if (tokenType === 'monster') { setMode('enemies'); state.focusIndex = state.focusList.indexOf(token); snapCameraTo(token); }
                }
                EntityManager.updateTurnVisuals();
            },
            updateTurnVisuals: () => {
                state.tokenData.forEach(m => { if (m.userData.glow) { m.remove(m.userData.glow); m.userData.glow = null; } });
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                const turnIndex = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                if (mons.length > 0 && mons[turnIndex]) {
                    const activeId = mons[turnIndex].id;
                    const token = state.tokenData.get(activeId);
                    if (token) {
                        const glowGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
                        const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.5 });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        glow.position.y = -0.1;
                        token.add(glow);
                        token.userData.glow = glow;
                        const btn = document.getElementById('next-turn-btn');
                        btn.classList.remove('hidden');
                        btn.innerHTML = `<span>Next Turn (${mons[turnIndex].name})</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>`;
                        btn.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});
                    }
                }
            }
        };

        const UIManager = {
            renderHotbar: () => {
                const el = document.getElementById('hotbar'); el.innerHTML='';
                CATEGORIES.forEach((c,i) => {
                    const div = document.createElement('div');
                    div.className = `hotbar-slot w-12 h-12 bg-slate-800 border-2 rounded-lg flex flex-col items-center justify-center cursor-pointer relative ${i===state.activeCategoryIdx?'active border-sky-400':'border-slate-600 opacity-80'} shrink-0`;
                    const item = c.items[state.subSelections[i]||0];
                    let inr = '';
                    if(item !== undefined) {
                        if(c.type==='block') { 
                            const mat = MATERIALS[item];
                            if (mat.type.startsWith('textured') || mat.type.startsWith('stair')) {
                                const h = mat.color.toString(16).padStart(6,'0');
                                inr=`<div style="width:24px;height:24px;background:repeating-linear-gradient(45deg, #${h}, #${h} 5px, #222 5px, #222 10px);border:1px solid #fff;border-radius:4px"></div>`;
                                if (mat.type.startsWith('stair')) { inr += `<span style="position:absolute; bottom:2px; right:2px; font-size:10px;">◢</span>`; }
                            } else {
                                const h = mat.color.toString(16).padStart(6,'0'); 
                                inr=`<div style="width:24px;height:24px;background:#${h};border:1px solid #fff;border-radius:4px"></div>`; 
                            }
                        }
                        else if(c.type==='token') { const cl = c.subType==='monster'?'#ef4444':'#3b82f6'; inr=`<div style="width:12px;height:12px;background:${cl};border-radius:50%"></div><span class="text-[9px] text-white truncate w-full text-center">${item.name}</span>`; }
                        else if(c.type==='loot') inr=`<span style="font-size:20px">${item.icon}</span>`;
                    }
                    div.innerHTML = `<span class="absolute -top-3 left-1/2 -translate-x-1/2 bg-slate-900 text-slate-400 text-[9px] px-1.5 rounded border border-slate-700">${(i+1)%10}</span>${inr}`;
                    div.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});
                    div.onclick = (e) => { 
                        e.stopPropagation();
                        if (state.activeCategoryIdx === i) {
                            const count = c.items.length;
                            if (count > 1) { let s = (state.subSelections[i] || 0) + 1; if (s >= count) s = 0; state.subSelections[i] = s; }
                        } else { state.activeCategoryIdx = i; }
                        UIManager.renderHotbar(); 
                    }; 
                    el.appendChild(div);
                });
            },
            renderSidebar: () => {
                const el = document.getElementById('sidebar-container'); el.innerHTML='';
                const parts = [ {l:'Heroes', d:CATEGORIES[3].items}, {l:'Enemies', d:CATEGORIES[4].items} ];
                parts.forEach(p => {
                    if(!p.d.length) return;
                    el.innerHTML += `<div class="text-[10px] font-bold text-slate-400 mt-2 mb-1 border-b border-slate-700">${p.l}</div>`;
                    p.d.forEach(t => {
                        const r = document.createElement('div'); r.className='token-item flex items-center gap-2 bg-slate-800/50 p-2 rounded mb-1 cursor-pointer';
                        r.innerHTML = `<div class="w-2 h-2 rounded-full ${p.l==='Heroes'?'bg-blue-500':'bg-red-500'}"></div><div class="text-xs text-slate-200">${t.name}</div>`;
                        r.onclick = () => { const m = state.tokenData.get(t.id); if(m) { controls.getObject().position.set(m.position.x, m.position.y+5, m.position.z+5); controls.getObject().lookAt(m.position); } };
                        el.appendChild(r);
                    });
                });
            },
            updateTooltip: (o) => {
                const t = document.getElementById('tooltip');
                if(!o) { t.style.display='none'; return; }
                t.style.display='block';
                if(o.userData.isVoxel) t.innerHTML = `<div class="font-bold text-sm">${MATERIALS[o.userData.matIndex].name}</div>`;
                else if(o.userData.isToken) t.innerHTML = `<div class="font-bold text-indigo-300 text-lg">${o.userData.data.name}</div><div class="text-xs">HP: ${o.userData.data.currentHp}/${o.userData.data.maxHp}</div><div class="text-[9px] text-slate-400">${o.userData.data.conditions?.join(',')||''}</div>`;
                else if(o.userData.isLoot) t.innerHTML = `<div class="font-bold text-amber-400">${o.userData.data.icon} ${o.userData.data.name}</div>`;
            },
            renderSlots: () => {
                const idx = MapStorageManager.getKeys();
                const list = document.getElementById('slots-list');
                list.innerHTML = '';
                Object.keys(idx).forEach(id => {
                    const row = document.createElement('div'); row.className = `flex justify-between items-center p-3 rounded mb-2 cursor-pointer transition-colors ${state.currentMapId === id ? 'bg-indigo-900/50 border border-indigo-500' : 'bg-slate-800 border border-slate-700 hover:bg-slate-700'}`; row.innerHTML = `<span class="font-bold text-sm text-white">${idx[id]}</span>`;
                    const actions = document.createElement('div'); actions.className = 'flex gap-2';
                    if (id !== state.currentMapId) { const loadBtn = document.createElement('button'); loadBtn.innerText = "Load"; loadBtn.className = "text-xs bg-green-700 hover:bg-green-600 text-white px-2 py-1 rounded"; loadBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.loadMap(id); document.getElementById('slots-modal').classList.remove('open'); }; actions.appendChild(loadBtn); } else { const activeBadge = document.createElement('span'); activeBadge.innerText = "Active"; activeBadge.className = "text-[10px] bg-indigo-600 text-white px-2 py-1 rounded"; actions.appendChild(activeBadge); }
                    if (id !== 'default') { const delBtn = document.createElement('button'); delBtn.innerText = "X"; delBtn.className = "text-xs bg-red-900/50 hover:bg-red-700 text-red-200 px-2 py-1 rounded"; delBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.deleteMap(id); }; actions.appendChild(delBtn); }
                    row.appendChild(actions); list.appendChild(row);
                });
            }
        };

        const rollover = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), new THREE.MeshBasicMaterial({color:0x38BDF8, wireframe:true, opacity:0.5, transparent:true})); scene.add(rollover);
        const tokenRoll = new THREE.Mesh(tokenGeo, new THREE.MeshBasicMaterial({color:0xFCD34D, wireframe:true})); tokenRoll.visible=false; scene.add(tokenRoll);

        function rotatePlacement() {
            state.placementRotation += Math.PI / 2;
            state.placementRotation = state.placementRotation % (Math.PI * 2);
            rollover.rotation.y = state.placementRotation;
        }

        function getVoxelPos(pt, norm, mode) { const p = pt.clone(); if(mode==='build') p.add(norm.clone().multiplyScalar(0.5)); else p.add(norm.clone().multiplyScalar(-0.1)); return p.floor().addScalar(0.5); }
        function checkCollision(pos) {
            if(state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies' || isFlying) return false;
            const r=0.3, h=1.6, minX=Math.floor(pos.x-r), maxX=Math.ceil(pos.x+r), minY=Math.floor(pos.y-h), maxY=Math.ceil(pos.y), minZ=Math.floor(pos.z-r), maxZ=Math.ceil(pos.z+r);
            for(let x=minX; x<maxX; x++) for(let y=minY; y<maxY; y++) for(let z=minZ; z<maxZ; z++) { if(state.mapData.has(`${x},${y},${z}`) && (pos.x-r < x+0.5 && pos.x+r > x-0.5 && pos.y-h < y+0.5 && pos.y > y-0.5 && pos.z-r < z+0.5 && pos.z+r > z-0.5)) return true; }
            return false;
        }

        function snapCameraTo(token) {
            if(!token) return;
            const targetPos = token.position.clone();
            const camOffset = new THREE.Vector3(0, 10, 8); 
            camera.position.copy(targetPos).add(camOffset);
            camera.up.set(0, 1, 0);
            camera.lookAt(targetPos);
            RangeRingManager.update(token, 'focus');
            document.getElementById('focus-label').innerText = token.userData.data.name;
        }

        function updateFocusMode(mode) {
            state.focusList = [];
            state.tokenData.forEach(t => {
                if (t.userData.isToken) {
                    if (mode === 'players' && t.userData.data.type === 'player') state.focusList.push(t);
                    if (mode === 'enemies' && t.userData.data.type === 'monster') state.focusList.push(t);
                }
            });
            if (state.focusList.length > 0) {
                if (state.controlledToken && state.focusList.includes(state.controlledToken)) { state.focusIndex = state.focusList.indexOf(state.controlledToken); } else { state.focusIndex = 0; }
                snapCameraTo(state.focusList[state.focusIndex]);
                state.controlledToken = state.focusList[state.focusIndex];
                state.moveBudget = 30; 
                RangeRingManager.update(state.controlledToken, 'movement');
                document.getElementById('move-badge').style.display = 'block';
                document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
            } else {
                RangeRingManager.update(null);
                state.controlledToken = null;
                document.getElementById('focus-label').innerText = "No Targets";
            }
        }

        function cycleFocus(direction) {
            if (state.focusList.length === 0) return;
            state.focusIndex += direction;
            if (state.focusIndex >= state.focusList.length) state.focusIndex = 0;
            if (state.focusIndex < 0) state.focusIndex = state.focusList.length - 1;
            const token = state.focusList[state.focusIndex];
            snapCameraTo(token);
            state.controlledToken = token;
            state.moveBudget = 30;
            RangeRingManager.update(state.controlledToken, 'movement');
            document.getElementById('move-badge').style.display = 'block';
            document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
        }

        function handleRaycast() {
            if(!controls.isLocked && !state.isTouch && state.mode!=='view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            if (controls.isLocked || state.isTouch) { raycaster.setFromCamera(new THREE.Vector2(0,0), camera); } else { raycaster.setFromCamera(mouse, camera); }
            
            // Recursive intersect to catch parts of token groups
            const hits = raycaster.intersectObjects([...state.mapData.values(), ...state.tokenData.values(), scene.getObjectByName('ground')], true);
            rollover.visible = false; tokenRoll.visible = false; UIManager.updateTooltip(null);

            if(hits.length) {
                // Traverse up to find the interactive entity (Group or Mesh)
                let object = hits[0].object;
                while(!object.userData.isToken && !object.userData.isVoxel && !object.userData.isLoot && object.name !== 'ground' && object.parent && object.parent !== scene) {
                    object = object.parent;
                }
                const hit = { ...hits[0], object: object };

                UIManager.updateTooltip(hit.object.name==='ground'?null:hit.object);
                
                if (state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies') {
                    if (state.controlledToken) {
                         if(hit.object.userData.isVoxel || hit.object.name === 'ground') {
                            rollover.visible = true;
                            if(rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                            let floorY = hit.object.name === 'ground' ? 0 : Math.round(hit.point.y);
                            if (hit.face.normal.y < 0.9 && hit.object.userData.isVoxel) floorY = Math.floor(hit.point.y); 
                            const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                            const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                            const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                            rollover.scale.set(1, 0.1, 1); rollover.position.set(tx, floorY+0.05, tz);
                            if (cost <= state.moveBudget) { rollover.material.color.setHex(CONFIG.colors.valid); document.getElementById('tooltip').innerHTML = `<div class="text-green-400 font-bold">Move: ${cost}ft</div>`; }
                            else { rollover.material.color.setHex(CONFIG.colors.invalid); document.getElementById('tooltip').innerHTML = `<div class="text-red-400 font-bold">Far: ${cost}ft</div>`; }
                            document.getElementById('tooltip').style.display = 'block';
                        }
                    }
                    return {hit, interactable:true};
                }
                
                if (state.gameMode === 'build') {
                    const cat = CATEGORIES[state.activeCategoryIdx];
                    if(cat.type === 'block' || cat.type === 'loot') {
                        rollover.visible = true;
                        if(state.dragStart) {
                            if (rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                            const s = state.dragStart.pos, e = getVoxelPos(hit.point, hit.face.normal, state.dragStart.mode);
                            const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                            rollover.scale.set(maxX-minX+1, maxY-minY+1, maxZ-minZ+1); rollover.position.set(minX+(maxX-minX+1)/2-0.5, minY+(maxY-minY+1)/2-0.5, minZ+(maxZ-minZ+1)/2-0.5);
                            rollover.rotation.y = 0; 
                            rollover.material.color.setHex(state.dragStart.mode==='delete' ? CONFIG.colors.delete : CONFIG.colors.highlight);
                        } else { 
                            const p = hit.point.clone().add(hit.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5); 
                            rollover.scale.set(1,1,1); rollover.position.copy(p); rollover.material.color.setHex(CONFIG.colors.highlight); 
                            
                            // Adjust cursor geometry based on selection
                            if (cat.type === 'loot') {
                                if (rollover.geometry !== GeometryManager.get('cross')) rollover.geometry = GeometryManager.get('cross');
                                rollover.rotation.y = state.placementRotation;
                            } else {
                                const mat = cat.items[state.subSelections[state.activeCategoryIdx]];
                                if (mat !== undefined) {
                                    const mDef = MATERIALS[mat];
                                    if (mDef.type.startsWith('stair')) {
                                        if (rollover.geometry !== GeometryManager.get('stair')) rollover.geometry = GeometryManager.get('stair');
                                        rollover.rotation.y = state.placementRotation;
                                    } else if (mDef.type.startsWith('topper_')) {
                                        if (rollover.geometry !== GeometryManager.get('cross')) rollover.geometry = GeometryManager.get('cross');
                                        rollover.rotation.y = 0;
                                    } else if (mDef.type.startsWith('model_')) {
                                        const gName = mDef.type.split('_')[1];
                                        if (rollover.geometry !== GeometryManager.get(gName)) rollover.geometry = GeometryManager.get(gName);
                                        rollover.rotation.y = state.placementRotation;
                                    } else {
                                        if (rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                                        rollover.rotation.y = 0;
                                    }
                                }
                            }
                        }
                    } else if (cat.type === 'token') {
                        tokenRoll.visible = true;
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        let fy = hit.object.name==='ground'?0:(hit.face.normal.y>0.9?Math.round(hit.point.y):Math.floor(hit.point.y));
                        tokenRoll.position.set(tx, fy+0.1, tz);
                    }
                    return {hit, interactable:true};
                }
            } 
            return {interactable:false};
        }

        // --- NEW: INTERACTION MANAGER (Handles Touch Drag & Mouse) ---
        const InteractionManager = {
            start: (mode) => {
                if (state.gameMode !== 'build') return;
                const cat = CATEGORIES[state.activeCategoryIdx];
                const res = handleRaycast();
                if (!res.interactable) return;

                if (cat.type === 'block') {
                    if (mode === 'delete' && res.hit.object.userData.isVoxel) {
                        // FIX: Use the actual object position for deletion to ensure 100% accuracy
                        state.dragStart = { pos: res.hit.object.position.clone(), mode: 'delete' };
                    } else if (mode === 'build') {
                        state.dragStart = { pos: getVoxelPos(res.hit.point, res.hit.face.normal, 'build'), mode: 'build' };
                    }
                } else if (cat.type === 'token' || cat.type === 'loot') {
                    if (mode === 'build') {
                        // Place Token/Loot logic
                        const d = cat.items[state.subSelections[state.activeCategoryIdx]];
                        if(d) {
                             // UPDATED: Loot uses rollover position (center of block)
                             let pos;
                             if (cat.type === 'loot') pos = rollover.position.clone();
                             else pos = tokenRoll.position.clone();

                             if(cat.type==='token') { if(state.tokenData.has(d.id)) state.tokenData.get(d.id).position.copy(pos); } 
                             else { 
                                 // Use Cross geometry and generated Texture for Loot
                                 const m = new THREE.Mesh(GeometryManager.get('cross'), getLootMaterial(d.name)); 
                                 m.position.copy(pos); 
                                 m.userData={isLoot:true, id:`l${Date.now()}`, data:d}; 
                                 scene.add(m); 
                                 state.tokenData.set(m.userData.id, m); 
                             }
                             MapStorageManager.saveMap();
                        }
                    } else if (mode === 'delete' && res.hit.object.userData.isLoot) {
                        scene.remove(res.hit.object); state.tokenData.delete(res.hit.object.userData.id); MapStorageManager.saveMap();
                    }
                }
            },
            end: () => {
                if (!state.dragStart) return;
                const res = handleRaycast();
                
                // Allow commit even if raycast misses, using inferred end position from last valid drag frame if needed
                // But for safety, we rely on current raycast or dragStart pos if click-release
                let endPos;
                if (res.interactable) {
                    endPos = getVoxelPos(res.hit.point, res.hit.face.normal, state.dragStart.mode);
                } else {
                    endPos = state.dragStart.pos; // Fallback to single block if mouse went off-world
                }

                const s = state.dragStart.pos;
                const e = endPos;
                const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                const mat = CATEGORIES[state.activeCategoryIdx].items[state.subSelections[state.activeCategoryIdx]];
                
                if((maxX-minX)*(maxY-minY)*(maxZ-minZ) > 5000) { console.warn("Too big"); state.dragStart=null; rollover.scale.set(1,1,1); return; }
                
                const rot = state.placementRotation;
                let chg=0;
                for(let x=minX; x<=maxX; x++) for(let y=minY; y<=maxY; y++) for(let z=minZ; z<=maxZ; z++) {
                    if(state.dragStart.mode==='build') { if(mat!==undefined){WorldManager.add(x,y,z,mat,rot,false); chg++;} } 
                    else { const m=state.mapData.get(`${x},${y},${z}`); if(m){WorldManager.remove(m); chg++;} }
                }
                for(let x=minX-1; x<=maxX+1; x++) for(let y=minY-1; y<=maxY+1; y++) for(let z=minZ-1; z<=maxZ+1; z++) WorldManager.updateGeo(x,y,z);
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                if(chg) MapStorageManager.saveMap();
                
                state.dragStart = null;
                rollover.scale.set(1,1,1);
            }
        };

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (isRightMouseDown && !controls.isLocked) {
                const movementX = event.clientX - lastMouseX; const movementY = event.clientY - lastMouseY;
                camera.rotation.y -= movementX * 0.002; camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, camera.rotation.x ) );
            }
            lastMouseX = event.clientX; lastMouseY = event.clientY;
        });

        // FIXED: Removed global touch listeners which caused snapping issues.
        
        const touchState = { moveId: null, moveStart: { x: 0, y: 0 }, lookId: null, lookLast: { x: 0, y: 0 } };
        const joyUI = document.getElementById('joystick-ui'); const joyKnob = document.getElementById('joystick-knob');
        const zoneMove = document.getElementById('zone-move');

        zoneMove.addEventListener('touchstart', (e) => {
            e.preventDefault(); const touch = e.changedTouches[0];
            if(touchState.moveId === null) {
                touchState.moveId = touch.identifier; touchState.moveStart = { x: touch.clientX, y: touch.clientY };
                joyUI.style.display = 'block'; joyUI.style.left = touch.clientX + 'px'; joyUI.style.top = touch.clientY + 'px'; joyKnob.style.transform = `translate(-50%, -50%)`;
            }
        }, { passive: false });

        zoneMove.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.moveId) {
                    const maxDist = 50; let dx = touch.clientX - touchState.moveStart.x; let dy = touch.clientY - touchState.moveStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy); if (dist > maxDist) { const ratio = maxDist / dist; dx *= ratio; dy *= ratio; }
                    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    
                    // FIXED: Inverted Z-axis calculation. Dragging Up (negative dy) should result in forward movement (positive velocity.z input).
                    state.moveVector.x = dx / maxDist; 
                    state.moveVector.z = -dy / maxDist; 
                }
            }
        }, { passive: false });

        const endMove = (e) => { for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchState.moveId) { touchState.moveId = null; state.moveVector = { x: 0, z: 0 }; joyUI.style.display = 'none'; } } };
        zoneMove.addEventListener('touchend', endMove); zoneMove.addEventListener('touchcancel', endMove);

        const zoneLook = document.getElementById('zone-look');
        zoneLook.addEventListener('touchstart', (e) => { const touch = e.changedTouches[0]; if(touchState.lookId === null) { touchState.lookId = touch.identifier; touchState.lookLast = { x: touch.clientX, y: touch.clientY }; } }, { passive: false });

        zoneLook.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.lookId) {
                    const dx = touch.clientX - touchState.lookLast.x; 
                    const dy = touch.clientY - touchState.lookLast.y;
                    
                    // FIXED: Pitch Logic. Rotate Body for YAW, Camera for PITCH.
                    // This separates axes to prevent roll issues.
                    
                    // Yaw (Left/Right) - Rotate the Player Body
                    controls.getObject().rotation.y -= dx * 0.005;
                    
                    // Pitch (Up/Down) - Rotate the Camera
                    camera.rotation.x -= dy * 0.005;
                    
                    // Clamp Pitch
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    touchState.lookLast = { x: touch.clientX, y: touch.clientY };
                }
            }
        }, { passive: false });

        const endLook = (e) => { for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchState.lookId) { touchState.lookId = null; } } };
        zoneLook.addEventListener('touchend', endLook); zoneLook.addEventListener('touchcancel', endLook);
        
        const simulateClick = (btn, type) => { const event = new MouseEvent(type, { bubbles: true, cancelable: true, view: window, button: btn }); document.dispatchEvent(event); };
        const touchBtns = ['mob-place', 'mob-break', 'mob-fly', 'mob-up', 'mob-down', 'mob-rotate'];
        touchBtns.forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault(); e.stopPropagation(); 
                    if (id === 'mob-place') { 
                        // Simulate Drag Start
                        InteractionManager.start('build');
                    } 
                    else if (id === 'mob-break') { 
                        // Simulate Drag Start
                        InteractionManager.start('delete');
                    } 
                    else if (id === 'mob-fly') { isFlying = !isFlying; velocity.y = 0; el.classList.toggle('bg-yellow-700'); const vControls = document.getElementById('mobile-vertical-controls'); if(vControls) vControls.style.display = isFlying ? 'flex' : 'none'; } 
                    else if (id === 'mob-rotate') { rotatePlacement(); }
                    else if (id === 'mob-up') { move.u = true; } 
                    else if (id === 'mob-down') { move.d = true; }
                }, { passive: false });
                el.addEventListener('touchend', (e) => { 
                    e.preventDefault(); e.stopPropagation(); 
                    if (id === 'mob-up') move.u = false; 
                    if (id === 'mob-down') move.d = false; 
                    if (id === 'mob-place' || id === 'mob-break') {
                        // Simulate Drag End
                        InteractionManager.end();
                    }
                });
            }
        });

        document.addEventListener('keydown', e => {
            if(e.repeat) return;
            if(e.code === 'KeyW') move.f=true; if(e.code === 'KeyS') move.b=true; if(e.code === 'KeyA') move.l=true; if(e.code === 'KeyD') move.r=true;
            if(e.code === 'Space') { if(isFlying || state.gameMode === 'dm') move.u=true; else if(canJump) { velocity.y+=15; canJump=false; } }
            if(e.code === 'KeyC') { if(isFlying || state.gameMode === 'dm') move.d=true; } 
            if(e.code === 'KeyF') { isFlying=!isFlying; velocity.y=0; }
            if(e.code === 'KeyR') { if(e.shiftKey) { } else { rotatePlacement(); } }
            if(e.code === 'Tab') {
                e.preventDefault();
                if (state.gameMode === 'players' || state.gameMode === 'enemies') { if (state.focusList && state.focusList.length > 0) { snapCameraTo(state.focusList[state.focusIndex]); } } 
                else { if(controls.isLocked) { controls.unlock(); state.mode='menu'; document.getElementById('mouse-mode-badge').style.display='block'; } else { if (!state.isTouch) controls.lock(); state.mode='view'; document.getElementById('mouse-mode-badge').style.display='none'; } }
            }
            if(e.code === 'Escape') { if(state.controlledToken) { state.controlledToken = null; state.moveBudget = 30; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } }
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=true; state.activeCategoryIdx=i; UIManager.renderHotbar(); }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') move.f=false; if(e.code === 'KeyS') move.b=false; if(e.code === 'KeyA') move.l=false; if(e.code === 'KeyD') move.r=false;
            if(e.code === 'Space') move.u=false; if(e.code === 'KeyC') move.d=false;
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=false; }
        });

        document.addEventListener('mousedown', e => {
            // FIX: Ignore clicks if the target is a UI element
            if (e.target.closest('.interactive') && !e.target.closest('.interactive').matches('body')) return;

            if (e.button === 2) { isRightMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; }
            if(!controls.isLocked && state.mode !== 'view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            const res = handleRaycast();
            if(!res.interactable) { if(e.button===0) { state.controlledToken = null; state.focusedToken = null; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } return; }
            const {hit} = res;
            if (state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies') {
                if (e.button === 0) { 
                    if (state.controlledToken && (hit.object.userData.isVoxel || hit.object.name === 'ground')) {
                        let floorY = hit.object.name==='ground'?0:Math.round(hit.point.y); if(hit.face.normal.y<0.9 && hit.object.userData.isVoxel) floorY=Math.floor(hit.point.y);
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                        const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                        if (cost <= state.moveBudget) { 
                            state.controlledToken.position.copy(targetPos); state.moveBudget -= cost; document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`; 
                            RangeRingManager.update(state.controlledToken, 'movement'); MapStorageManager.saveMap();
                        }
                    }
                    return;
                }
            }
            if (e.shiftKey && e.button === 2 && hit.object.userData.isToken) { state.focusedToken = hit.object; RangeRingManager.update(state.focusedToken, 'conditions'); const p = hit.object.position; controls.getObject().position.set(p.x, p.y+5, p.z+5); controls.getObject().lookAt(p); return; }
            if (state.gameMode === 'build') {
                if(e.button === 2) {
                    InteractionManager.start('build');
                } else if(e.button===0) {
                    InteractionManager.start('delete');
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) isRightMouseDown = false;
            InteractionManager.end();
        });

        document.addEventListener('wheel', e => {
            if (state.gameMode === 'players' || state.gameMode === 'enemies') {
                const zoomSpeed = 0.5; const zoomDir = new THREE.Vector3(); camera.getWorldDirection(zoomDir);
                if (e.deltaY > 0) zoomDir.negate(); camera.position.add(zoomDir.multiplyScalar(zoomSpeed)); return;
            }
            const i = Object.keys(state.heldKeys).find(k=>state.heldKeys[k]); const target = i !== undefined ? i : state.activeCategoryIdx;
            const c = CATEGORIES[target]; if(!c.items.length) return;
            let s = state.subSelections[target] + (e.deltaY>0?1:-1); if(s<0) s=c.items.length-1; if(s>=c.items.length) s=0;
            state.subSelections[target] = s; UIManager.renderHotbar();
        });

        document.getElementById('btn-apps-dropdown').onclick = (e) => { e.stopPropagation(); document.getElementById('apps-dropdown-content').classList.toggle('show'); };
        window.onclick = (e) => { if (!e.target.matches('#btn-apps-dropdown') && !e.target.closest('#btn-apps-dropdown')) { const dropdowns = document.getElementsByClassName("dropdown-content"); for (let i = 0; i < dropdowns.length; i++) { if (dropdowns[i].classList.contains('show')) dropdowns[i].classList.remove('show'); } } };

        document.getElementById('instructions').onclick = () => { 
            toggleFullScreen(); // Try to enable fullscreen on start click
            if (state.gameMode === 'players' || state.gameMode === 'enemies') { 
                document.getElementById('instructions').style.display='none'; 
                document.getElementById('ui-layer').classList.add('interactive'); 
            } else { 
                if (!state.isTouch) controls.lock(); 
                else document.getElementById('instructions').style.display='none'; 
            } 
        };
        
        // Fullscreen Helper
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            }
        }

        controls.addEventListener('lock', () => { document.getElementById('instructions').style.display='none'; document.getElementById('ui-layer').classList.remove('interactive'); });
        controls.addEventListener('unlock', () => { if(state.mode==='menu' || state.gameMode === 'players' || state.gameMode === 'enemies' || state.gameMode === 'dm') { document.getElementById('ui-layer').classList.add('interactive'); } else { if(!state.isTouch) document.getElementById('instructions').style.display='block'; } });
        
        document.getElementById('mode-build').onclick = () => setMode('build'); 
        document.getElementById('mode-dm').onclick = () => setMode('dm');
        document.getElementById('mode-players').onclick = () => setMode('players');
        document.getElementById('mode-enemies').onclick = () => setMode('enemies');
        
        document.getElementById('focus-next').onclick = () => cycleFocus(1);
        document.getElementById('focus-prev').onclick = () => cycleFocus(-1);
        document.getElementById('next-turn-btn').onclick = () => { EntityManager.advanceTurn(); };

        document.getElementById('btn-slots').onclick = () => { UIManager.renderSlots(); document.getElementById('slots-modal').classList.add('open'); };
        document.getElementById('close-slots').onclick = () => document.getElementById('slots-modal').classList.remove('open');
        document.getElementById('create-map-btn').onclick = () => { const name = document.getElementById('new-map-name').value; if(name) { const id = MapStorageManager.createMap(name); MapStorageManager.loadMap(id); WorldManager.clear(true); UIManager.renderSlots(); document.getElementById('new-map-name').value = ''; } };

        function applyInputScheme(mode) {
            state.isTouch = (mode === 'touch'); localStorage.setItem('akashic_input_scheme', mode);
            const mobControls = document.getElementById('mobile-controls'); const instructions = document.getElementById('instructions');
            if (state.isTouch) { 
                mobControls.style.display = 'block'; 
                instructions.style.display = 'none'; 
                toggleFullScreen(); // Try to enable fullscreen on touch selection
            } 
            else { mobControls.style.display = 'none'; if(state.gameMode === 'build' && !controls.isLocked) instructions.style.display = 'block'; }
            document.getElementById('controls-modal').classList.remove('open');
        }

        function initInputScheme() { const saved = localStorage.getItem('akashic_input_scheme'); if (saved) { applyInputScheme(saved); } else { document.getElementById('controls-modal').classList.add('open'); } }

        document.getElementById('scheme-mouse').onclick = () => applyInputScheme('mouse');
        document.getElementById('scheme-touch').onclick = () => applyInputScheme('touch');
        document.getElementById('btn-input-toggle').onclick = () => document.getElementById('controls-modal').classList.add('open');

        function setMode(m) {
            state.gameMode = m; document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active')); document.getElementById(`mode-${m}`).classList.add('active');
            document.getElementById('instr-build').style.display = m==='build'?'grid':'none'; 
            document.getElementById('instr-dm').style.display = m==='dm'?'grid':'none';
            document.getElementById('instr-focus').style.display = (m==='players'||m==='enemies')?'grid':'none';
            const focusControls = document.getElementById('focus-controls');
            if (m === 'players' || m === 'enemies') { focusControls.classList.add('visible'); updateFocusMode(m); } 
            else { focusControls.classList.remove('visible'); RangeRingManager.update(null); if(m==='dm') { isFlying=true; velocity.y=0; } if (m === 'build') { camera.rotation.z = 0; camera.rotation.x = 0; camera.up.set(0, 1, 0); if (!state.isTouch) controls.lock(); } }
            UIManager.renderHotbar();
        }
        document.getElementById('btn-sync').onclick = EntityManager.sync; 
        document.getElementById('btn-clear').onclick = () => { 
            // Bypass confirm for preview stability
            // if(confirm("Nuke this map?")) { 
            if(true) {
                WorldManager.clear(); MapStorageManager.saveMap(); 
            } 
        };
        document.getElementById('btn-export').onclick = () => { const data = { voxels: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_voxels`)), positions: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_positions`)) }; const b=new Blob([JSON.stringify(data)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=`map_${state.currentMapId}.json`; a.click(); };
        document.getElementById('btn-import').onclick = () => document.getElementById('file-input').click();
        document.getElementById('file-input').onchange = (e) => { const r=new FileReader(); r.onload=ev=>{ try { const d = JSON.parse(ev.target.result); localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(d.voxels)); localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(d.positions)); MapStorageManager.loadMap(state.currentMapId); } catch(e) { console.error("Invalid Map File"); } }; r.readAsText(e.target.files[0]); };

        function animate() {
            requestAnimationFrame(animate);
            const dt = (performance.now()-prevTime)/1000; prevTime=performance.now();
            
            // Update animations
            TextureAnimator.update(performance.now());

            const physicsEnabled = (controls.isLocked || state.isTouch) && state.gameMode !== 'players' && state.gameMode !== 'enemies';

            if(physicsEnabled) {
                velocity.x -= velocity.x * 10.0 * dt; 
                velocity.z -= velocity.z * 10.0 * dt;
                
                if (state.gameMode === 'dm') velocity.y -= velocity.y * 5.0 * dt; 
                else velocity.y -= isFlying ? velocity.y * 5.0 * dt : 9.8 * 2.0 * dt;

                const spd = isFlying || state.gameMode==='dm' ? 40 : 15;
                let inputX = 0; let inputZ = 0;

                if (state.isTouch) { inputX = state.moveVector.x; inputZ = state.moveVector.z; } 
                else { inputZ = Number(move.f) - Number(move.b); inputX = Number(move.r) - Number(move.l); }
                
                if (inputZ !== 0 || inputX !== 0) { velocity.z += inputZ * spd * 10.0 * dt; velocity.x += inputX * spd * 10.0 * dt; }
                if ((isFlying || state.gameMode==='dm')) { if (move.u) velocity.y += spd * 10.0 * dt; if (move.d) velocity.y -= spd * 10.0 * dt; }

                const obj = controls.getObject(), startPos = obj.position.clone();
                controls.moveRight(velocity.x * dt); 
                if(checkCollision(obj.position)) { if (!isFlying && state.gameMode !== 'dm') { obj.position.y += 0.6; if (checkCollision(obj.position)) { obj.position.y = startPos.y; obj.position.x = startPos.x; } } else { obj.position.x = startPos.x; } }
                
                // FIXED: Forward (W) moves in +Z direction relative to camera facing (standard WASD)
                // If velocity.z is positive (W pressed), moveForward(positive) moves forward.
                controls.moveForward(velocity.z * dt); 
                if(checkCollision(obj.position)) { if (!isFlying && state.gameMode !== 'dm') { const currentY = obj.position.y; obj.position.y += 0.6; if (checkCollision(obj.position)) { obj.position.y = currentY; obj.position.z = startPos.z; } } else { obj.position.z = startPos.z; } }
                
                obj.position.y += velocity.y * dt;
                if(checkCollision(obj.position) || (obj.position.y<2 && state.gameMode!=='dm')) { if(velocity.y<0) { canJump=true; obj.position.y = Math.ceil(obj.position.y); } else { obj.position.y = Math.floor(obj.position.y)-0.6; } velocity.y=0; if(obj.position.y < 2) obj.position.y = 2; }
                const p = obj.position; document.getElementById('coord-display').innerText = `${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;
                handleRaycast();
            }
            renderer.render(scene, camera);
        }

        if (!MapStorageManager.loadMap('default')) { MapStorageManager.saveIndex({'default': 'Default Map'}); MapStorageManager.loadMap('default'); }
        EntityManager.sync(); UIManager.renderHotbar(); initInputScheme(); 
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>