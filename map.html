<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Akashic Atlas | 3D Voxel Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: ui-sans-serif, system-ui, sans-serif; user-select: none; touch-action: none; -webkit-touch-callout: none; overscroll-behavior: none; }
        /* UPDATED: Increased z-index to 50 so UI buttons sit ABOVE touch zones */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .interactive { pointer-events: auto; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; transition: opacity 0.2s; }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: rgba(255, 255, 255, 0.9); }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: rgba(255, 255, 255, 0.9); }
        .hotbar-slot { transition: all 0.15s ease-out; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); touch-action: none; }
        .hotbar-slot.active { border-color: #38BDF8; box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); transform: translateY(-4px); z-index: 20; }
        #tooltip { position: absolute; display: none; transform: translate(-50%, -120%); backdrop-filter: blur(8px); z-index: 50; pointer-events: none; }
        .token-item { transition: all 0.2s; }
        .token-item:hover { transform: translateX(4px); background: rgba(51, 65, 85, 0.8); }
        .mode-switch { position: relative; display: flex; background: #0f172a; border-radius: 8px; padding: 4px; border: 1px solid #334155; gap: 4px; flex-wrap: wrap; justify-content: center; }
        .mode-btn { padding: 4px 12px; font-size: 12px; font-weight: bold; border-radius: 6px; color: #94a3b8; transition: all 0.2s; }
        .mode-btn.active { background: #38BDF8; color: #0f172a; box-shadow: 0 0 10px rgba(56, 189, 248, 0.3); }
        #move-badge { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #6ee7b7; font-weight: bold; padding: 6px 16px; border-radius: 20px; backdrop-filter: blur(4px); display: none; text-shadow: 0 1px 2px black; }
        #save-indicator { position: absolute; bottom: 80px; right: 20px; background: rgba(0,0,0,0.7); color: #aaa; padding: 5px 10px; border-radius: 5px; font-size: 12px; pointer-events: none; transition: opacity 0.5s; opacity: 0; }
        #save-indicator.visible { opacity: 1; }
        #slots-modal { display: none; }
        #slots-modal.open { display: flex; }
        #focus-controls { display: none; position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%); gap: 10px; align-items: center; pointer-events: auto; }
        #focus-controls.visible { display: flex; }
        .focus-nav-btn { background: rgba(15, 23, 42, 0.9); color: white; border: 1px solid #334155; width: 40px; height: 40px; border-radius: 50%; display: flex; items-center; justify-content: center; font-weight: bold; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .focus-nav-btn:hover { background: #38BDF8; color: #0f172a; transform: scale(1.1); }
        .focus-label { background: rgba(15, 23, 42, 0.9); color: white; padding: 8px 20px; border-radius: 20px; font-size: 14px; font-weight: bold; border: 1px solid #334155; min-width: 150px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #next-turn-btn { position: absolute; top: 130px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #4f46e5, #ec4899); border: 2px solid #a5b4fc; box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); padding: 8px 24px; border-radius: 99px; color: white; font-weight: bold; font-size: 14px; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: all 0.2s; z-index: 50; touch-action: none; }
        #next-turn-btn:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 25px rgba(99, 102, 241, 0.8); }
        #next-turn-btn.hidden { display: none; }
        .turn-active-glow { box-shadow: 0 0 30px 10px rgba(255, 215, 0, 0.6); }
        .dropdown-content { display: none; position: absolute; right: 0; top: 100%; background-color: #1e293b; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 50; border-radius: 0.5rem; border: 1px solid #334155; margin-top: 0.5rem;}
        .dropdown-content.show { display: block; }
        .dropdown-content a { text-decoration: none; display: flex; align-items: center; gap: 8px; font-size: 0.75rem; font-weight: 700; padding: 8px; }
        .app-link-btn { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background-color: #1e293b; color: #94a3b8; border: 1px solid #334155; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 700; transition: all 0.2s; width: 100%; margin-bottom: 4px; }
        .app-link-btn:last-child { margin-bottom: 0; }
        .app-link-btn:hover { background-color: #334155; color: #fff; border-color: #475569; }
        .app-link-tome:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-homebrew:hover { border-color: #f59e0b; color: #fcd34d; }
        .app-link-loot:hover { border-color: #ef4444; color: #fca5a5; }
        .app-link-campaign:hover { border-color: #10b981; color: #6ee7b7; }
        @media (max-width: 1024px) { 
            #ui-layer { padding: 10px; }
            .mode-switch { justify-content: space-between; }
            .mode-btn { padding: 6px 8px; font-size: 10px; flex-grow: 1; text-align: center; }
            #instructions { display: none !important; }
            #hotbar-wrapper { bottom: 10px; z-index: 60; position: relative; }
            .hotbar-slot { width: 40px; height: 40px; }
            #next-turn-btn { top: auto; bottom: 200px; }
            #sidebar-container { display: none; }
            .header-controls { flex-wrap: wrap; justify-content: center; gap: 5px; }
            .header-controls button { padding: 6px 10px; font-size: 10px; }
            #move-badge { bottom: 140px; }
        }
        
        /* ADDED: Landscape Mobile Optimization */
        @media (max-height: 500px) and (orientation: landscape) {
            #mobile-build-actions {
                bottom: 10px !important;
                right: 20px !important;
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 8px !important;
            }
            .build-btn { width: 45px !important; height: 45px !important; }
            #mobile-vertical-controls {
                bottom: 10px !important;
                left: 20px !important;
            }
            .vert-btn { width: 40px !important; height: 40px !important; }
            #hotbar-wrapper { bottom: 0 !important; transform: scale(0.8); transform-origin: bottom center; }
            #next-turn-btn { bottom: 80px !important; }
            #move-badge { bottom: 80px !important; }
        }

        #mobile-controls { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        .touch-zone-left { position: absolute; top: 60px; bottom: 0; left: 0; width: 50%; pointer-events: auto; touch-action: none; }
        .touch-zone-right { position: absolute; top: 60px; bottom: 0; right: 0; width: 50%; pointer-events: auto; touch-action: none; }
        #joystick-ui { position: absolute; width: 100px; height: 100px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; display: none; pointer-events: none; transform: translate(-50%, -50%); }
        #joystick-knob { position: absolute; left: 50%; top: 50%; width: 40px; height: 40px; background: rgba(56, 189, 248, 0.5); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(56, 189, 248, 0.8); }
        #mobile-build-actions { display: flex; flex-direction: column; gap: 15px; pointer-events: auto; position: absolute; bottom: 140px; right: 20px; z-index: 50; }
        .build-btn { width: 60px; height: 60px; background: rgba(30, 41, 59, 0.95); border: 2px solid #475569; border-radius: 50%; color: white; display: flex; items-center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.1s; touch-action: none; }
        .build-btn:active { transform: scale(0.95); }
        .build-btn.place-btn { border-color: #10b981; color: #10b981; background: rgba(6, 78, 59, 0.9); }
        .build-btn.break-btn { border-color: #ef4444; color: #ef4444; background: rgba(127, 29, 29, 0.9); }
        .build-btn.fly-btn { border-color: #eab308; color: #fef08a; background: rgba(113, 63, 18, 0.9); font-size: 10px; font-weight: bold; }
        .build-btn.fly-btn.active { background: #eab308; color: black; box-shadow: 0 0 15px rgba(234, 179, 8, 0.6); }
        .build-btn.rotate-btn { border-color: #818cf8; color: #a5b4fc; background: rgba(49, 46, 129, 0.9); }
        #mobile-vertical-controls { display: none; flex-direction: column; gap: 10px; position: absolute; bottom: 160px; left: 160px; pointer-events: auto; z-index: 50; }
        .vert-btn { width: 50px; height: 50px; background: rgba(15, 23, 42, 0.8); border: 2px solid #64748b; border-radius: 12px; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5); touch-action: none; }
        .vert-btn:active { background: #38BDF8; color: black; }
        #controls-modal { display: none; }
        #controls-modal.open { display: flex; }
    </style>
</head>
<body>
    <div id="ui-layer" class="flex flex-col justify-between h-full p-4">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="interactive bg-slate-900/90 border border-slate-700 p-3 rounded-xl shadow-xl backdrop-blur-sm flex flex-col gap-2 w-full md:w-auto">
                <div class="flex items-center justify-between gap-4">
                    <h1 class="text-xl font-bold text-white flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22d3ee" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
                        <span class="hidden md:inline">Akashic Atlas</span>
                        <span class="md:hidden">Atlas</span>
                    </h1>
                    <div class="mode-switch">
                        <button id="mode-build" class="mode-btn active">BUILD</button>
                        <button id="mode-dm" class="mode-btn">DM</button>
                        <button id="mode-players" class="mode-btn text-blue-400">PLAYERS</button>
                        <button id="mode-enemies" class="mode-btn text-red-400">ENEMIES</button>
                    </div>
                </div>
                <div class="text-xs text-slate-400 font-mono flex gap-3 justify-center md:justify-start">
                    <span id="coord-display">0, 0, 0</span> | <span id="block-count">0 Blocks</span> | <span id="current-map-name" class="text-amber-400 font-bold">Default Map</span>
                </div>
            </div>

            <div class="header-controls flex gap-2 relative flex-wrap justify-end w-full md:w-auto">
                <button id="btn-input-toggle" class="interactive bg-slate-800 border border-slate-600 p-2 rounded-lg text-slate-400 hover:text-white transition-colors shadow-lg" title="Change Controls"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg></button>
                <button id="btn-atmosphere" class="interactive bg-slate-800 border border-amber-500/50 p-2 rounded-lg text-amber-400 hover:bg-slate-700 transition-colors shadow-lg" title="Toggle Day/Night"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button>
                <div class="w-px h-10 bg-slate-700/50 mx-1 hidden md:block"></div>
                <button id="btn-sync" class="interactive bg-indigo-600 hover:bg-indigo-500 border border-indigo-400 text-white text-xs font-bold px-4 py-2 rounded-lg shadow-lg transition-all flex items-center gap-2">Sync</button>
                <button id="btn-slots" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-amber-400 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg> Maps</button>
                <button id="btn-export" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Export</button>
                <button id="btn-import" class="interactive bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Import</button>
                <button id="btn-clear" class="interactive bg-red-900/30 hover:bg-red-900/80 border border-red-800/50 text-red-200 text-xs font-bold px-3 py-2 rounded-lg transition-colors hidden md:block">Clear</button>
                <input type="file" id="file-input" accept=".json" class="hidden">
                
                <div class="dropdown interactive relative">
                    <button id="btn-apps-dropdown" class="bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 text-xs font-bold px-3 py-2 rounded-lg transition-colors flex items-center gap-2">
                        Apps <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                    </button>
                    <div id="apps-dropdown-content" class="dropdown-content p-2">
                        <a href="tome.html" target="_blank" class="app-link-btn app-link-tome"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></svg> Tome</a>
                        <a href="homebrew.html" target="_blank" class="app-link-btn app-link-homebrew"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"/><path d="M8.5 2h7"/><path d="M7 16h10"/></svg> Homebrew</a>
                        <a href="loot.html" target="_blank" class="app-link-btn app-link-loot"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></svg> Loot</a>
                        <a href="campaign.html" target="_blank" class="app-link-btn app-link-campaign"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg> Campaign</a>
                    </div>
                </div>
            </div>
        </div>
        <div id="sidebar-container" class="absolute left-4 top-32 bottom-32 w-64 interactive overflow-y-auto pr-2 hidden sm:block"></div>
        
        <div id="focus-controls" class="interactive">
            <button id="focus-prev" class="focus-nav-btn">&lt;</button>
            <div id="focus-label" class="focus-label">No Target</div>
            <button id="focus-next" class="focus-nav-btn">&gt;</button>
        </div>

        <button id="next-turn-btn" class="interactive hidden">
            <span>Next</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>
        </button>

        <div id="instructions" class="interactive absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-900/95 border border-cyan-500/50 p-8 rounded-2xl text-center shadow-[0_0_50px_rgba(6,182,212,0.2)] backdrop-blur-md cursor-pointer hover:border-cyan-400 transition-all z-50 group">
            <h2 class="text-3xl font-bold text-white mb-2 group-hover:scale-105 transition-transform">Click to Enter</h2>
            <div id="instr-build" class="space-y-2 text-slate-300 text-sm mt-4 text-left grid grid-cols-2 gap-x-6">
                <div><span class="text-cyan-400 font-bold">WASD</span> Move</div>
                <div><span class="text-cyan-400 font-bold">Space / C</span> Fly</div>
                <div><span class="text-red-400 font-bold">L-Click</span> Delete</div>
                <div><span class="text-cyan-400 font-bold">R-Click</span> Place</div>
                <div><span class="text-green-400 font-bold">R</span> Rotate</div>
                <div><span class="text-indigo-400 font-bold">Shift + R</span> Focus</div>
                <div><span class="text-yellow-400 font-bold">F</span> Toggle Fly</div>
            </div>
            <div id="instr-dm" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">WASD</span> Free Cam</div>
                <div><span class="text-indigo-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Select</div>
                <div><span class="text-red-400 font-bold">Esc</span> Release</div>
            </div>
            <div id="instr-focus" class="space-y-2 text-slate-300 text-sm mt-4 text-left hidden">
                <div><span class="text-cyan-400 font-bold">R-Hold</span> Look</div>
                <div><span class="text-green-400 font-bold">L-Click</span> Move</div>
                <div><span class="text-indigo-400 font-bold">Tab</span> Snap</div>
                <div><span class="text-amber-400 font-bold">Scroll</span> Zoom</div>
            </div>
        </div>
        <div id="mouse-mode-badge" class="absolute top-32 left-1/2 -translate-x-1/2 bg-yellow-500/20 border border-yellow-500 text-yellow-200 px-4 py-1 rounded-full text-xs font-bold uppercase tracking-wider backdrop-blur hidden">Mouse Cursor Active (Tab)</div>
        <div id="move-badge">Movement: 30ft</div>
        
        <div id="mobile-controls">
            <div id="zone-move" class="touch-zone-left"></div>
            <div id="zone-look" class="touch-zone-right"></div>
            <div id="joystick-ui"><div id="joystick-knob"></div></div>
            <div id="mobile-vertical-controls">
                <button id="mob-up" class="vert-btn">▲</button>
                <button id="mob-down" class="vert-btn">▼</button>
            </div>
            <div id="mobile-build-actions">
                <button id="mob-place" class="build-btn place-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg></button>
                <button id="mob-break" class="build-btn break-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                <button id="mob-rotate" class="build-btn rotate-btn"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                <button id="mob-fly" class="build-btn fly-btn">FLY</button>
            </div>
        </div>

        <div id="save-indicator">Saving...</div>

        <div class="interactive mt-auto w-full flex flex-col items-center" id="hotbar-wrapper">
            <div class="bg-black/80 text-slate-400 text-[10px] uppercase tracking-widest px-3 py-1 rounded-t-lg font-bold border-t border-x border-slate-800/50">Hold # & Scroll / Touch</div>
            <div id="hotbar" class="flex gap-2 p-3 bg-slate-900/90 border border-slate-700 rounded-2xl shadow-2xl backdrop-blur-md overflow-x-auto max-w-full"></div>
        </div>
    </div>

    <div id="slots-modal" class="interactive fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 shadow-2xl flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> Select Map</h2>
                <button id="close-slots" class="text-slate-400 hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
            </div>
            <div class="p-4 overflow-y-auto space-y-2 flex-1" id="slots-list"></div>
            <div class="p-4 border-t border-slate-700 bg-slate-800 rounded-b-xl">
                <div class="flex gap-2">
                    <input type="text" id="new-map-name" placeholder="New Map Name" class="flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm text-white focus:outline-none focus:border-indigo-500">
                    <button id="create-map-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded text-sm">Create</button>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-modal" class="interactive fixed inset-0 z-[110] bg-black/90 backdrop-blur-md flex items-center justify-center p-4 hidden">
        <div class="bg-slate-900 w-full max-w-lg rounded-2xl border-2 border-indigo-500/50 shadow-[0_0_50px_rgba(99,102,241,0.2)] p-8 text-center">
            <h2 class="text-2xl font-bold text-white mb-2">Select Control Scheme</h2>
            <p class="text-slate-400 mb-8">Choose how you want to interact with the world.</p>
            
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                <button id="scheme-mouse" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-indigo-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-400 group-hover:scale-110 transition-transform"><rect x="2" y="4" width="20" height="12" rx="2"/><path d="M6 12h.01"/><path d="M10 12h.01"/><path d="M14 12h.01"/><path d="M18 12h.01"/><path d="M12 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/><path d="M6 8v.01"/><path d="M18 8v.01"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Keyboard & Mouse</div>
                        <div class="text-xs text-slate-400 mt-1">WASD to Move<br>Pointer Lock Look</div>
                    </div>
                </button>

                <button id="scheme-touch" class="p-6 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-cyan-400 rounded-xl transition-all group flex flex-col items-center gap-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-cyan-400 group-hover:scale-110 transition-transform"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
                    <div>
                        <div class="font-bold text-white text-lg">Touchscreen</div>
                        <div class="text-xs text-slate-400 mt-1">Virtual Joystick<br>Swipe to Look</div>
                    </div>
                </button>
            </div>
            <p class="text-[10px] text-slate-500">You can change this later from the top menu.</p>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="tooltip" class="bg-slate-900/95 border border-slate-600 rounded-lg p-3 text-white shadow-xl min-w-[150px]"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            worldSize: 64,
            colors: { 
                bgNight: 0x020617, bgDay: 0x87CEEB, highlight: 0x38BDF8, delete: 0xEF4444, valid: 0x10b981, invalid: 0xEF4444,
                monster: 0xef4444, player: 0x3b82f6
            },
            moveSpeed: 30, blockSize: 5
        };

        const CONDITION_COLORS = { "Blinded":0x525252,"Charmed":0xdb2777,"Deafened":0x94a3b8,"Frightened":0x7c3aed,"Grappled":0xf97316,"Incapacitated":0xdc2626,"Invisible":0xffffff,"Paralyzed":0xfacc15,"Petrified":0x475569,"Poisoned":0x16a34a,"Prone":0x78350f,"Restrained":0x9a3412,"Stunned":0xf59e0b,"Unconscious":0x000000,"Exhaustion":0x7f1d1d,"Default":0x38BDF8 };
        
        // ---- TEXTURE GENERATION HELPER ----
        const TextureGenerator = {
            createCanvas(width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            },
            brick(color, groutColor) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + groutColor.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                const brickH = 14; const brickW = 28;
                ctx.fillRect(0, 2, brickW, brickH); ctx.fillRect(brickW + 2, 2, brickW, brickH); ctx.fillRect((brickW * 2) + 4, 2, brickW, brickH);
                ctx.fillRect(-10, 18, brickW, brickH); ctx.fillRect(16, 18, brickW, brickH); ctx.fillRect(16 + brickW + 2, 18, brickW, brickH);
                ctx.fillRect(0, 34, brickW, brickH); ctx.fillRect(brickW + 2, 34, brickW, brickH);
                ctx.fillRect(-10, 50, brickW, brickH); ctx.fillRect(16, 50, brickW, brickH); ctx.fillRect(16 + brickW + 2, 50, brickW, brickH);
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            wood(color, darkColor) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#' + darkColor.toString(16).padStart(6, '0');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, 21); ctx.lineTo(w, 21); ctx.moveTo(0, 42); ctx.lineTo(w, 42); ctx.stroke();
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let i=0; i<40; i++) { ctx.fillRect(Math.random()*w, Math.random()*h, 4, 1); }
                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            },
            effect(type, color) {
                const w = 64, h = 64;
                const canvas = this.createCanvas(w, h);
                const ctx = canvas.getContext('2d');
                
                // Helper for converting hex integer to string
                const hex = '#' + color.toString(16).padStart(6, '0');
                
                if (type === 'mushroom') {
                    // Classic Toadstool
                    ctx.fillStyle = '#eee'; // Stem
                    ctx.fillRect(w/2 - 6, h/2, 12, h/2);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.arc(w/2, h/2, 20, Math.PI, 0);
                    ctx.fill();
                    // Spots
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(w/2 - 10, h/2 - 10, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w/2 + 8, h/2 - 5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w/2, h/2 - 15, 3, 0, Math.PI*2); ctx.fill();
                } else if (type === 'mushroomFlat') {
                    // Wide Flat Mushroom
                    ctx.fillStyle = '#dcb'; // Stem
                    ctx.fillRect(w/2 - 5, h/2 + 5, 10, h/2 - 5);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.ellipse(w/2, h/2 + 5, 25, 8, 0, Math.PI, 0);
                    ctx.fill();
                } else if (type === 'mushroomTall') {
                    // Tall Thin Glowshroom
                    ctx.fillStyle = '#eee'; // Stem
                    ctx.fillRect(w/2 - 3, h/3, 6, h - h/3);
                    ctx.fillStyle = hex; // Cap
                    ctx.beginPath();
                    ctx.moveTo(w/2 - 10, h/3 + 5);
                    ctx.quadraticCurveTo(w/2, h/3 - 15, w/2 + 10, h/3 + 5);
                    ctx.lineTo(w/2, h/3 + 2); // dimple underneath
                    ctx.fill();
                    // Glow particles
                    ctx.fillStyle = hex;
                    for(let i=0; i<5; i++) ctx.fillRect(w/2 + (Math.random()-0.5)*30, h/2 + (Math.random()-0.5)*30, 2, 2);
                } else if (type === 'grass') {
                    // Initial draw for icon
                    ctx.strokeStyle = hex; ctx.lineWidth = 4;
                    for(let i=0; i<12; i++) {
                        ctx.beginPath(); ctx.moveTo(i*5 + 2, h);
                        ctx.quadraticCurveTo(i*5 + 2 + (Math.random()-0.5)*10, h/2, i*5 + 2 + (Math.random()-0.5)*20, 5);
                        ctx.stroke();
                    }
                } else if (type === 'fire' || type === 'bubbles' || type === 'swirls') {
                    // Simple icon draw
                    ctx.fillStyle = hex; ctx.fillRect(16, 16, 32, 32);
                }

                const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter;
                return tex;
            }
        };

        // --- UPDATED MATERIALS ---
        const MATERIALS = [
            { id: 0, name: "Grass", color: 0x4b6e32, type: 'solid' },
            { id: 1, name: "Dirt", color: 0x5c3c28, type: 'solid' },
            { id: 2, name: "Stone", color: 0x64748b, type: 'solid' },
            { id: 3, name: "Wood Planks", color: 0x8B4513, type: 'textured_wood', color2: 0x5c3c28 }, 
            { id: 4, name: "Sand", color: 0xE6C288, type: 'solid' },
            { id: 5, name: "Snow", color: 0xf1f5f9, type: 'solid' },
            { id: 6, name: "Dungeon Bricks", color: 0x475569, type: 'textured_brick', color2: 0x1e293b }, 
            { id: 7, name: "Red Bricks", color: 0x8f3636, type: 'textured_brick', color2: 0x5c3c28 }, 
            { id: 8, name: "Water", color: 0x38BDF8, type: 'liquid', opacity: 0.6 },
            { id: 9, name: "Lava", color: 0xea580c, type: 'liquid', opacity: 0.8 },
            { id: 10, name: "Acid", color: 0x84cc16, type: 'liquid', opacity: 0.6 },
            { id: 11, name: "Poison", color: 0x14532d, type: 'liquid', opacity: 0.7 },
            { id: 12, name: "Wood Stairs", color: 0x8B4513, type: 'stair_wood', color2: 0x5c3c28 },
            { id: 13, name: "Dungeon Stairs", color: 0x475569, type: 'stair_brick', color2: 0x1e293b },
            { id: 14, name: "Red Brick Stairs", color: 0x8f3636, type: 'stair_brick', color2: 0x5c3c28 },
            { id: 15, name: "Obsidian", color: 0x181018, type: 'solid' },
            { id: 16, name: "Obsidian Bricks", color: 0x2d2038, type: 'textured_brick', color2: 0x0f0a14 },
            { id: 17, name: "Obsidian Stairs", color: 0x2d2038, type: 'stair_brick', color2: 0x0f0a14 },
            { id: 18, name: "Forcefield", color: 0xa855f7, type: 'liquid', opacity: 0.4 },
            { id: 19, name: "Tall Grass", color: 0x4b6e32, type: 'topper_grass' },
            { id: 20, name: "Fire", color: 0xff4500, type: 'topper_fire' },
            { id: 21, name: "Bubbles", color: 0x84cc16, type: 'topper_bubbles' },
            { id: 22, name: "Swirls", color: 0xd8b4fe, type: 'topper_swirls' },
            { id: 23, name: "Toadstool", color: 0xef4444, type: 'topper_mushroom' },
            { id: 24, name: "Brown Shroom", color: 0x8B4513, type: 'topper_mushroomFlat' },
            { id: 25, name: "Glow Shroom", color: 0x22d3ee, type: 'topper_mushroomTall' },
        ];
        
        // --- CATEGORIES ---
        const CATEGORIES = [
            { key: '1', label: 'Solid', type: 'block', items: [0, 1, 2, 4, 5, 15] },
            { key: '2', label: 'Textured', type: 'block', items: [3, 6, 7, 12, 13, 14, 16, 17] }, 
            { key: '3', label: 'Liquids', type: 'block', items: [8, 9, 10, 11, 18] },
            { key: '4', label: 'Players', type: 'token', subType: 'player', items: [] }, 
            { key: '5', label: 'Enemies', type: 'token', subType: 'monster', items: [] },
            { key: '6', label: 'Loot', type: 'loot', items: [] }, 
            { key: '7', label: 'Effects', type: 'block', items: [19, 20, 21, 22, 23, 24, 25] }, 
            { key: '8', label: '-', type: 'none', items: [] }, 
            { key: '9', label: '-', type: 'none', items: [] }, 
            { key: '0', label: '-', type: 'none', items: [] }
        ];

        // --- ANIMATOR ---
        const TextureAnimator = {
            items: [],
            add: (mat, type, color) => {
                const canvas = mat.map.image;
                const ctx = canvas.getContext('2d');
                const data = { particles: [] }; 
                const w=64, h=64;
                
                // Initialize stable random data for smooth animation
                if(type==='grass') {
                    for(let i=0; i<12; i++) data.particles.push({x: Math.random()*w, h: 5+Math.random()*15, lean: (Math.random()-0.5)*20});
                } else if(type==='bubbles') {
                    for(let i=0; i<10; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, r: Math.random()*4+2, s: Math.random()+0.5});
                } else if (type==='swirls') {
                    for(let i=0; i<5; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, r: Math.random()*10+5, a: Math.random()*Math.PI*2});
                } else if (type==='fire') {
                    for(let i=0; i<10; i++) data.particles.push({x: Math.random()*w, y: Math.random()*h, s: Math.random()*3+1});
                }

                TextureAnimator.items.push({ mat, type, color, ctx, w, h, data });
            },
            update: (time) => {
                TextureAnimator.items.forEach(item => {
                    const { mat, type, color, ctx, w, h, data } = item;
                    const t = time * 0.002; 
                    ctx.clearRect(0, 0, w, h);
                    const hex = '#' + color.toString(16).padStart(6, '0');
                    
                    if (type === 'grass') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 4;
                        ctx.beginPath();
                        data.particles.forEach((p, i) => {
                            const sway = Math.sin(t + i) * 10;
                            ctx.moveTo(p.x, h);
                            ctx.quadraticCurveTo(p.x + p.lean + sway, h/2, p.x + p.lean*2 + sway*1.5, p.h);
                        });
                        ctx.stroke();
                    } else if (type === 'bubbles') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 2; ctx.fillStyle='rgba(255,255,255,0.3)';
                        data.particles.forEach(p => {
                            let currY = (p.y - t * 20 * p.s) % (h + 10);
                            if (currY < -10) currY += h + 20;
                            const wobble = Math.sin(t*3 + p.x) * 3;
                            ctx.beginPath(); ctx.arc(p.x + wobble, currY, p.r, 0, Math.PI*2); 
                            ctx.stroke(); ctx.fill();
                        });
                    } else if (type === 'swirls') {
                        ctx.strokeStyle = hex; ctx.lineWidth = 3;
                        data.particles.forEach(p => {
                            const rot = t * 2 + p.a;
                            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, rot, rot + Math.PI*1.5); ctx.stroke();
                        });
                    } else if (type === 'fire') {
                        // Flame Base
                        const g = ctx.createLinearGradient(0, h, 0, 0);
                        g.addColorStop(0, '#ff4500'); g.addColorStop(0.5, '#ffd700'); g.addColorStop(1, 'rgba(255,255,0,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        const flicker = Math.sin(t*10)*2 + Math.cos(t*23)*2;
                        ctx.moveTo(10, h); ctx.quadraticCurveTo(w/2 + flicker, -10, w-10, h); ctx.fill();
                        // Sparks
                        ctx.fillStyle = '#ffff00';
                        data.particles.forEach(p => {
                            let currY = (p.y - t * 40 * p.s) % h;
                            if (currY < 0) currY += h;
                            ctx.fillRect(p.x, currY, p.s, p.s);
                        });
                    }
                    mat.map.needsUpdate = true;
                });
            }
        };

        // --- UPDATED MATERIAL GENERATION ---
        const materials = MATERIALS.map(m => {
            const matConfig = { transparent: !!m.opacity, opacity: m.opacity || 1 };
            if (m.type === 'liquid') { matConfig.color = m.color; matConfig.depthWrite = false; matConfig.side = THREE.DoubleSide; }
            else if (m.type === 'textured_brick' || m.type === 'stair_brick') { matConfig.map = TextureGenerator.brick(m.color, m.color2 || 0x000000); }
            else if (m.type === 'textured_wood' || m.type === 'stair_wood') { matConfig.map = TextureGenerator.wood(m.color, m.color2 || 0x000000); }
            else if (m.type.startsWith('topper_')) { 
                matConfig.map = TextureGenerator.effect(m.type.split('_')[1], m.color); 
                matConfig.transparent = true; 
                matConfig.side = THREE.DoubleSide; 
                matConfig.depthWrite = false; 
            }
            else { matConfig.color = m.color; }
            
            const newMat = new THREE.MeshLambertMaterial(matConfig);
            
            // Register for animation if applicable
            if(m.type.startsWith('topper_')) {
                const subType = m.type.split('_')[1];
                if(['grass', 'fire', 'bubbles', 'swirls'].includes(subType)) {
                    TextureAnimator.add(newMat, subType, m.color);
                }
            }
            
            return newMat;
        });
        
        const DIRS = [ {x:1,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:-1,z:0}, {x:0,y:0,z:1}, {x:0,y:0,z:-1} ];

        const state = { 
            gameMode: 'build', activeCategoryIdx: 0, subSelections: new Array(10).fill(0), 
            isAtmosphereDay: false, heldKeys: {}, mapData: new Map(), tokenData: new Map(), 
            mode: 'view', dragStart: null, controlledToken: null, focusedToken: null, moveBudget: 30,
            currentMapId: 'default', currentMapName: 'Default Map', autoSaveTimer: null,
            focusIndex: 0, focusList: [], 
            currentTurnIndex: 0,
            isTouch: false, // Updated: controlled by selection
            moveVector: { x: 0, z: 0 }, 
            touch: { id: null, startX: 0, startY: 0, moveX: 0, moveY: 0 },
            placementRotation: 0 // New state for manual rotation
        };

        const scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bgNight); scene.fog = new THREE.Fog(CONFIG.colors.bgNight, 10, 60);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 5, 10);
        // Force rotation order to prevent roll artifacts
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
        
        // FIX: Re-declare all required variables at the top level
        const controls = new PointerLockControls(camera, document.body);
        const raycaster = new THREE.Raycaster();
        const move = { f:false, b:false, l:false, r:false, u:false, d:false };
        let canJump=false, isFlying=false, velocity = new THREE.Vector3(), prevTime = performance.now();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5); dirLight.position.set(50, 100, 50); scene.add(dirLight);
        const torchLight = new THREE.PointLight(0xffaa00, 1.5, 20); camera.add(torchLight); scene.add(camera);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(64, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({visible:false})); plane.name = "ground"; scene.add(plane);
        scene.add(new THREE.GridHelper(64, 64, 0x334155, 0x1e293b));

        const mouse = new THREE.Vector2();
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        const GeometryManager = {
            cache: new Map(),
            init: () => {
                // Helper to create a BoxGeometry with UVs scaled to match size
                // This prevents texture "squashing" on smaller stair parts
                const createBox = (w, h, d, tx, ty, tz) => {
                    const g = new THREE.BoxGeometry(w, h, d);
                    // Scale UVs
                    const uv = g.attributes.uv;
                    // BoxGeometry creates faces: +x, -x, +y, -y, +z, -z.
                    // Each face has 4 vertices. 
                    // To be perfect, we map width/depth/height to u/v.
                    // Since textures are tilable, we assume 1 unit world space = 1 unit UV.
                    // Simple BoxGeometry maps 0..1 to each face.
                    // We modify this by scaling u by width/depth and v by height/depth.
                    
                    // Indices for faces: 0-3 (+x), 4-7 (-x), 8-11 (+y), 12-15 (-y), 16-19 (+z), 20-23 (-z)
                    // +x/-x (Right/Left): Size d * h. U*=d, V*=h
                    for(let i=0; i<8; i++) { uv.setXY(i, uv.getX(i)*d, uv.getY(i)*h); }
                    // +y/-y (Top/Bottom): Size w * d. U*=w, V*=d
                    for(let i=8; i<16; i++) { uv.setXY(i, uv.getX(i)*w, uv.getY(i)*d); }
                    // +z/-z (Front/Back): Size w * h. U*=w, V*=h
                    for(let i=16; i<24; i++) { uv.setXY(i, uv.getX(i)*w, uv.getY(i)*h); }
                    
                    g.translate(tx, ty, tz);
                    return g;
                };

                // --- OCCLUSION MASK GENERATION (0-63) ---
                // This generates geometries for solid/liquid blocks with specific faces removed based on neighbors.
                // Reinstating this restores the "seamless" look for liquids.
                const createFace = (idx) => {
                    const g = new THREE.PlaneGeometry(1, 1);
                    const matrix = new THREE.Matrix4();
                    switch(idx) {
                        case 0: matrix.makeRotationY(Math.PI/2); matrix.setPosition(0.5, 0, 0); break; // +x Right
                        case 1: matrix.makeRotationY(-Math.PI/2); matrix.setPosition(-0.5, 0, 0); break; // -x Left
                        case 2: matrix.makeRotationX(-Math.PI/2); matrix.setPosition(0, 0.5, 0); break; // +y Top
                        case 3: matrix.makeRotationX(Math.PI/2); matrix.setPosition(0, -0.5, 0); break; // -y Bottom
                        case 4: matrix.setPosition(0, 0, 0.5); break; // +z Front
                        case 5: matrix.makeRotationY(Math.PI); matrix.setPosition(0, 0, -0.5); break; // -z Back
                    }
                    g.applyMatrix4(matrix);
                    return g;
                };
                const faces = [0,1,2,3,4,5].map(i => createFace(i));

                // Generate all 64 permutations
                for(let m=0; m<64; m++) {
                    const geoms = [];
                    for(let i=0; i<6; i++) {
                        // If bit i is NOT set, it means no neighbor there, so we DRAW the face.
                        if (!(m & (1 << i))) geoms.push(faces[i].clone());
                    }
                    if(geoms.length > 0) GeometryManager.cache.set(m, BufferGeometryUtils.mergeGeometries(geoms));
                    else GeometryManager.cache.set(m, new THREE.BufferGeometry()); // Fully internal block
                }

                // --- STAIR GEOMETRIES ---
                // Re-create using Scaled UVs
                const slab = createBox(1, 0.5, 1, 0, -0.25, 0); 
                const topBack = createBox(1, 0.5, 0.5, 0, 0.25, -0.25);
                
                // Quarters
                const qTL = createBox(0.5, 0.5, 0.5, -0.25, 0.25, -0.25);
                const qTR = createBox(0.5, 0.5, 0.5, 0.25, 0.25, -0.25);
                const qFL = createBox(0.5, 0.5, 0.5, -0.25, 0.25, 0.25);
                const qFR = createBox(0.5, 0.5, 0.5, 0.25, 0.25, 0.25);

                // 1. Standard Stair
                GeometryManager.cache.set('stair', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone()]));

                // 2. Outer Left (Pyramid Corner)
                GeometryManager.cache.set('stair_outer_left', BufferGeometryUtils.mergeGeometries([slab.clone(), qTL.clone()]));

                // 3. Outer Right (Pyramid Corner)
                GeometryManager.cache.set('stair_outer_right', BufferGeometryUtils.mergeGeometries([slab.clone(), qTR.clone()]));

                // 4. Inner Left (Room Corner)
                GeometryManager.cache.set('stair_inner_left', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone(), qFL.clone()]));

                // 5. Inner Right (Room Corner)
                GeometryManager.cache.set('stair_inner_right', BufferGeometryUtils.mergeGeometries([slab.clone(), topBack.clone(), qFR.clone()]));

                // --- CROSS GEOMETRY (For Grass, Fire, etc.) ---
                const p1 = new THREE.PlaneGeometry(1, 1); p1.rotateY(Math.PI / 4);
                const p2 = new THREE.PlaneGeometry(1, 1); p2.rotateY(-Math.PI / 4);
                GeometryManager.cache.set('cross', BufferGeometryUtils.mergeGeometries([p1, p2]));
            },
            get: (m) => {
                if (typeof m === 'string') return GeometryManager.cache.get(m) || GeometryManager.cache.get('stair');
                return GeometryManager.cache.get(m) || GeometryManager.cache.get(0);
            }
        }; GeometryManager.init();

        const tokenGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
        const lootGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);

        const RangeRingManager = {
            group: new THREE.Group(),
            init: () => { scene.add(RangeRingManager.group); RangeRingManager.group.visible = false; },
            update: (targetToken, type = 'movement') => {
                while(RangeRingManager.group.children.length) RangeRingManager.group.remove(RangeRingManager.group.children[0]);
                if(!targetToken) { RangeRingManager.group.visible = false; return; }
                RangeRingManager.group.visible = true;
                RangeRingManager.group.position.copy(targetToken.position);
                RangeRingManager.group.position.y = targetToken.position.y - 0.1 + 0.02;
                const data = targetToken.userData.data;
                const radius = (state.moveBudget / 5); 
                const baseRing = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, opacity: 0.8, transparent: true}));
                RangeRingManager.group.add(baseRing);
                if (type === 'movement' && radius > 0) {
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(Math.max(0.1, radius-0.2), radius, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0x38BDF8, side: THREE.DoubleSide, transparent: true, opacity: 0.4}));
                    RangeRingManager.group.add(mesh);
                } else if (type === 'conditions' || type === 'focus') {
                    const moveRadius = 6; 
                    const mesh = new THREE.Mesh(new THREE.RingGeometry(moveRadius-0.1, moveRadius, 64).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({ color: 0x10b981, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
                    RangeRingManager.group.add(mesh);
                }
            }
        }; RangeRingManager.init();

        const MapStorageManager = {
            getKeys: () => { try { return JSON.parse(localStorage.getItem('akashic_map_index')) || { 'default': 'Default Map' }; } catch { return { 'default': 'Default Map' }; } },
            saveIndex: (idx) => localStorage.setItem('akashic_map_index', JSON.stringify(idx)),
            loadMap: (id) => {
                const idx = MapStorageManager.getKeys();
                if (!idx[id]) return false;
                state.currentMapId = id; state.currentMapName = idx[id];
                const mapNameEl = document.getElementById('current-map-name');
                if (mapNameEl) mapNameEl.innerText = state.currentMapName;
                try {
                    const raw = localStorage.getItem(`akashic_map_${id}_voxels`);
                    WorldManager.clear(false); 
                    if (raw) { JSON.parse(raw).forEach(b => WorldManager.add(b.x, b.y, b.z, b.c, b.r || 0, false)); }
                } catch(e) { console.error("Map Load Error", e); }
                try {
                    const posRaw = localStorage.getItem(`akashic_map_${id}_positions`);
                    const posData = posRaw ? JSON.parse(posRaw) : {};
                    state.tokenData.forEach((mesh, tokenId) => {
                        if (posData[tokenId]) mesh.position.set(posData[tokenId].x, posData[tokenId].y, posData[tokenId].z);
                        else mesh.position.set(0, 2, 0); 
                    });
                } catch(e) {}
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                return true;
            },
            saveMap: () => {
                const voxelData = []; state.mapData.forEach(m => voxelData.push({x:m.position.x, y:m.position.y, z:m.position.z, c:m.userData.matIndex, r: m.rotation.y}));
                localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(voxelData));
                const posData = {}; state.tokenData.forEach((m, id) => { posData[id] = {x:m.position.x, y:m.position.y, z:m.position.z}; });
                localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(posData));
                const ind = document.getElementById('save-indicator'); ind.classList.add('visible'); setTimeout(() => ind.classList.remove('visible'), 1000);
            },
            createMap: (name) => { const id = Date.now().toString(36); const idx = MapStorageManager.getKeys(); idx[id] = name; MapStorageManager.saveIndex(idx); return id; },
            deleteMap: (id) => { 
                if (id === 'default') { console.warn("Cannot delete default map."); return; } 
                // Bypass confirm for preview stability
                // if (!confirm("Delete this map forever?")) return; 
                const idx = MapStorageManager.getKeys(); delete idx[id]; MapStorageManager.saveIndex(idx); localStorage.removeItem(`akashic_map_${id}_voxels`); localStorage.removeItem(`akashic_map_${id}_positions`); if (state.currentMapId === id) MapStorageManager.loadMap('default'); UIManager.renderSlots(); 
            },
            triggerAutoSave: () => { if (state.autoSaveTimer) clearTimeout(state.autoSaveTimer); state.autoSaveTimer = setTimeout(MapStorageManager.saveMap, 2000); }
        };

        const WorldManager = {
            // Helper to get logic shape for stairs
            getStairShape: (x, y, z, myRot) => {
                const getBlock = (dx, dz) => {
                    const k = `${x+dx},${y},${z+dz}`;
                    const m = state.mapData.get(k);
                    if(m && MATERIALS[m.userData.matIndex].type.startsWith('stair')) return m;
                    return null;
                };

                // Normalize rotation to 0, 90, 180, 270
                // 0=North(-Z), 90=West(-X), 180=South(+Z), 270=East(+X)
                let deg = Math.round(myRot * (180/Math.PI));
                while(deg < 0) deg += 360;
                deg = deg % 360;

                // Define Front and Back vectors relative to MY facing direction
                // CORRECTION: 
                // Geometry has High side at Local -Z (North).
                // So "Back" (High side) is in the direction of rotation.
                // "Front" (Low side, where you step up) is opposite the direction of rotation.
                
                let frontVec = {x:0, z:0}; // Low Side (Step up)
                let backVec = {x:0, z:0};  // High Side (Wall)
                
                if (deg === 0) { // North (High side is North/-Z)
                    backVec = {x:0, z:-1}; frontVec = {x:0, z:1}; 
                } else if (deg === 90) { // West (High side is West/-X)
                    backVec = {x:-1, z:0}; frontVec = {x:1, z:0};
                } else if (deg === 180) { // South (High side is South/+Z)
                    backVec = {x:0, z:1}; frontVec = {x:0, z:-1};
                } else if (deg === 270) { // East (High side is East/+X)
                    backVec = {x:1, z:0}; frontVec = {x:-1, z:0};
                }

                const frontNeighbor = getBlock(frontVec.x, frontVec.z);
                const backNeighbor = getBlock(backVec.x, backVec.z);

                const getDeg = (obj) => {
                    let d = Math.round(obj.rotation.y * (180/Math.PI));
                    while(d < 0) d += 360; return d % 360;
                };
                
                // Helper: Is neighbor rotated 90 degrees Left or Right relative to me?
                // Left = +90, Right = -90 (or +270)
                const getDiff = (n) => (getDeg(n) - deg + 360) % 360;

                // 1. INNER CORNER CHECK (Sofa / Pit)
                // Rule: Check Neighbor in FRONT (Low side).
                if (frontNeighbor) {
                    const d = getDiff(frontNeighbor);
                    // Standard Logic: Left -> Inner Left, Right -> Inner Right
                    if (d === 90) return 'stair_inner_left';
                    if (d === 270) return 'stair_inner_right';
                }

                // 2. OUTER CORNER CHECK (Pyramid / Column)
                // Rule: Check Neighbor BEHIND (High side).
                if (backNeighbor) {
                    const d = getDiff(backNeighbor);
                    // Standard Logic: Left -> Outer Left, Right -> Outer Right
                    if (d === 90) return 'stair_outer_left';
                    if (d === 270) return 'stair_outer_right';
                } 

                return 'stair';
            },

            add: (x,y,z,mat, rot = 0, updateGeo=true) => { 
                const k = `${x},${y},${z}`; 
                if(state.mapData.has(k)) return; 
                
                const matDef = MATERIALS[mat];
                let geometry = GeometryManager.get(0);
                
                if (matDef.type.startsWith('stair')) {
                    geometry = GeometryManager.get('stair'); // Initial geometry, updated later
                } else if (matDef.type.startsWith('topper_')) {
                    geometry = GeometryManager.get('cross');
                }

                const m = new THREE.Mesh(geometry, materials[mat]); 
                m.position.set(x,y,z); 
                m.userData={isVoxel:true, matIndex:mat}; 
                m.rotation.y = rot;

                scene.add(m); 
                state.mapData.set(k, m); 
                
                if(updateGeo) { 
                    WorldManager.updateGeo(x,y,z); 
                    // Update neighbors for occlusion AND stair corners
                    DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); 
                    document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; 
                    MapStorageManager.triggerAutoSave(); 
                } 
            },
            remove: (m) => { 
                const {x,y,z} = m.position; 
                scene.remove(m); 
                state.mapData.delete(`${x},${y},${z}`); 
                DIRS.forEach(d=>WorldManager.updateGeo(x+d.x, y+d.y, z+d.z)); 
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`; 
                MapStorageManager.triggerAutoSave(); 
            },
            updateGeo: (x,y,z) => { 
                const m = state.mapData.get(`${x},${y},${z}`); 
                if(!m) return; 
                
                const matDef = MATERIALS[m.userData.matIndex];

                // STAIR LOGIC
                if (matDef.type.startsWith('stair')) {
                    const shape = WorldManager.getStairShape(x, y, z, m.rotation.y);
                    const newGeo = GeometryManager.get(shape);
                    if(m.geometry !== newGeo) m.geometry = newGeo;
                    return;
                }

                // TOPPER LOGIC (Always cross geometry, no occlusion)
                if (matDef.type.startsWith('topper_')) {
                    if (m.geometry !== GeometryManager.get('cross')) m.geometry = GeometryManager.get('cross');
                    return;
                }
                
                // STANDARD OCCLUSION LOGIC (Updated for reliability)
                // 1. Identify types
                const isSolid = (idx) => {
                    const t = MATERIALS[idx].type;
                    return t === 'solid' || t === 'textured_brick' || t === 'textured_wood';
                };
                const isLiquid = (idx) => MATERIALS[idx].type === 'liquid';

                let mask = 0; 
                DIRS.forEach((d,i) => { 
                    const n = state.mapData.get(`${x+d.x},${y+d.y},${z+d.z}`); 
                    
                    if (n) {
                        // If I am a Solid Block
                        if (isSolid(m.userData.matIndex)) {
                            // Only hide my face if neighbor is ALSO a Solid Block (Full Cube)
                            // This ensures that if neighbor is a Stair (partial), Liquid, or Topper (transparent), my face is drawn.
                            if (isSolid(n.userData.matIndex)) mask |= (1<<i);
                        }
                        // If I am a Liquid Block
                        else if (isLiquid(m.userData.matIndex)) {
                            // Hide face if neighbor is SAME Liquid (merge pools)
                            // OR if neighbor is Solid (don't show water side "inside" dirt)
                            if (n.userData.matIndex === m.userData.matIndex || isSolid(n.userData.matIndex)) mask |= (1<<i);
                        }
                    }
                }); 
                m.geometry = GeometryManager.get(mask); 
            },
            clear: (updateUI=true) => { state.mapData.forEach(m=>scene.remove(m)); state.mapData.clear(); if(updateUI) { document.getElementById('block-count').innerText = `0 Blocks`; MapStorageManager.triggerAutoSave(); } }
        };

        const EntityManager = {
            sync: () => {
                try {
                    const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters')||'[]');
                    if(!mons.length) { mons.push({id:'p1', name:'Hero', type:'player', currentHp:20, maxHp:20, conditions:['Poisoned']}); mons.push({id:'e1', name:'Goblin', type:'monster', currentHp:7, maxHp:7, conditions:[]}); }
                    CATEGORIES[3].items = mons.filter(c=>c.type==='player'); CATEGORIES[4].items = mons.filter(c=>c.type==='monster');
                    const loot = JSON.parse(localStorage.getItem('dm-loot') || '[]'); if (!loot.length) loot.push({id:'l1', name:'Gold', icon:'💰'}, {id:'l2', name:'Sword', icon:'⚔️'}, {id:'l3', name:'Potion', icon:'🧪'}); CATEGORIES[5].items = loot;
                    
                    state.tokenData.forEach((m,id) => { if(!m.userData.isLoot && !mons.find(c=>c.id===id)) { scene.remove(m); state.tokenData.delete(id); } });
                    
                    mons.forEach((c,i) => { 
                        let m = state.tokenData.get(c.id); 
                        const col = c.type==='monster' ? CONFIG.colors.monster : CONFIG.colors.player; 
                        if(!m) { 
                            m = new THREE.Mesh(tokenGeo, new THREE.MeshLambertMaterial({color:col})); 
                            m.add(new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshLambertMaterial({color:0xffffff})).translateY(0.4)); 
                            m.userData={isToken:true, id:c.id, data:c}; scene.add(m); state.tokenData.set(c.id, m); m.position.set(i*2, 2, 0); 
                        } else { m.material.color.setHex(col); m.userData.data=c; } 
                    });
                    
                    UIManager.renderHotbar(); UIManager.renderSidebar();
                    EntityManager.updateTurnVisuals();
                } catch(e) { console.error(e); }
            },
            advanceTurn: () => {
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                if (mons.length === 0) return;
                let turn = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                turn = (turn + 1) % mons.length;
                localStorage.setItem('dm-tracker-turn-index', turn);
                state.currentTurnIndex = turn;
                const activeId = mons[turn].id;
                const token = state.tokenData.get(activeId);
                if (token) {
                    const tokenType = mons[turn].type; 
                    if (tokenType === 'player') { setMode('players'); state.focusIndex = state.focusList.indexOf(token); snapCameraTo(token); } 
                    else if (tokenType === 'monster') { setMode('enemies'); state.focusIndex = state.focusList.indexOf(token); snapCameraTo(token); }
                }
                EntityManager.updateTurnVisuals();
            },
            updateTurnVisuals: () => {
                state.tokenData.forEach(m => { if (m.userData.glow) { m.remove(m.userData.glow); m.userData.glow = null; } });
                const mons = JSON.parse(localStorage.getItem('dm-tracker-monsters') || '[]');
                const turnIndex = parseInt(localStorage.getItem('dm-tracker-turn-index') || '0');
                if (mons.length > 0 && mons[turnIndex]) {
                    const activeId = mons[turnIndex].id;
                    const token = state.tokenData.get(activeId);
                    if (token) {
                        const glowGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
                        const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.5 });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        glow.position.y = -0.1;
                        token.add(glow);
                        token.userData.glow = glow;
                        const btn = document.getElementById('next-turn-btn');
                        btn.classList.remove('hidden');
                        btn.innerHTML = `<span>Next Turn (${mons[turnIndex].name})</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>`;
                        btn.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                        btn.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});
                    }
                }
            }
        };

        const UIManager = {
            renderHotbar: () => {
                const el = document.getElementById('hotbar'); el.innerHTML='';
                CATEGORIES.forEach((c,i) => {
                    const div = document.createElement('div');
                    div.className = `hotbar-slot w-12 h-12 bg-slate-800 border-2 rounded-lg flex flex-col items-center justify-center cursor-pointer relative ${i===state.activeCategoryIdx?'active border-sky-400':'border-slate-600 opacity-80'} shrink-0`;
                    const item = c.items[state.subSelections[i]||0];
                    let inr = '';
                    if(item !== undefined) {
                        if(c.type==='block') { 
                            const mat = MATERIALS[item];
                            if (mat.type.startsWith('textured') || mat.type.startsWith('stair')) {
                                const h = mat.color.toString(16).padStart(6,'0');
                                inr=`<div style="width:24px;height:24px;background:repeating-linear-gradient(45deg, #${h}, #${h} 5px, #222 5px, #222 10px);border:1px solid #fff;border-radius:4px"></div>`;
                                if (mat.type.startsWith('stair')) { inr += `<span style="position:absolute; bottom:2px; right:2px; font-size:10px;">◢</span>`; }
                            } else {
                                const h = mat.color.toString(16).padStart(6,'0'); 
                                inr=`<div style="width:24px;height:24px;background:#${h};border:1px solid #fff;border-radius:4px"></div>`; 
                            }
                        }
                        else if(c.type==='token') { const cl = c.subType==='monster'?'#ef4444':'#3b82f6'; inr=`<div style="width:12px;height:12px;background:${cl};border-radius:50%"></div><span class="text-[9px] text-white truncate w-full text-center">${item.name}</span>`; }
                        else if(c.type==='loot') inr=`<span style="font-size:20px">${item.icon}</span>`;
                    }
                    div.innerHTML = `<span class="absolute -top-3 left-1/2 -translate-x-1/2 bg-slate-900 text-slate-400 text-[9px] px-1.5 rounded border border-slate-700">${(i+1)%10}</span>${inr}`;
                    div.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchmove', (e) => { e.stopPropagation(); }, {passive: false});
                    div.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive: false});
                    div.onclick = (e) => { 
                        e.stopPropagation();
                        if (state.activeCategoryIdx === i) {
                            const count = c.items.length;
                            if (count > 1) { let s = (state.subSelections[i] || 0) + 1; if (s >= count) s = 0; state.subSelections[i] = s; }
                        } else { state.activeCategoryIdx = i; }
                        UIManager.renderHotbar(); 
                    }; 
                    el.appendChild(div);
                });
            },
            renderSidebar: () => {
                const el = document.getElementById('sidebar-container'); el.innerHTML='';
                const parts = [ {l:'Heroes', d:CATEGORIES[3].items}, {l:'Enemies', d:CATEGORIES[4].items} ];
                parts.forEach(p => {
                    if(!p.d.length) return;
                    el.innerHTML += `<div class="text-[10px] font-bold text-slate-400 mt-2 mb-1 border-b border-slate-700">${p.l}</div>`;
                    p.d.forEach(t => {
                        const r = document.createElement('div'); r.className='token-item flex items-center gap-2 bg-slate-800/50 p-2 rounded mb-1 cursor-pointer';
                        r.innerHTML = `<div class="w-2 h-2 rounded-full ${p.l==='Heroes'?'bg-blue-500':'bg-red-500'}"></div><div class="text-xs text-slate-200">${t.name}</div>`;
                        r.onclick = () => { const m = state.tokenData.get(t.id); if(m) { controls.getObject().position.set(m.position.x, m.position.y+5, m.position.z+5); controls.getObject().lookAt(m.position); } };
                        el.appendChild(r);
                    });
                });
            },
            updateTooltip: (o) => {
                const t = document.getElementById('tooltip');
                if(!o) { t.style.display='none'; return; }
                t.style.display='block';
                if(o.userData.isVoxel) t.innerHTML = `<div class="font-bold text-sm">${MATERIALS[o.userData.matIndex].name}</div>`;
                else if(o.userData.isToken) t.innerHTML = `<div class="font-bold text-indigo-300 text-lg">${o.userData.data.name}</div><div class="text-xs">HP: ${o.userData.data.currentHp}/${o.userData.data.maxHp}</div><div class="text-[9px] text-slate-400">${o.userData.data.conditions?.join(',')||''}</div>`;
                else if(o.userData.isLoot) t.innerHTML = `<div class="font-bold text-amber-400">${o.userData.data.icon} ${o.userData.data.name}</div>`;
            },
            renderSlots: () => {
                const idx = MapStorageManager.getKeys();
                const list = document.getElementById('slots-list');
                list.innerHTML = '';
                Object.keys(idx).forEach(id => {
                    const row = document.createElement('div'); row.className = `flex justify-between items-center p-3 rounded mb-2 cursor-pointer transition-colors ${state.currentMapId === id ? 'bg-indigo-900/50 border border-indigo-500' : 'bg-slate-800 border border-slate-700 hover:bg-slate-700'}`; row.innerHTML = `<span class="font-bold text-sm text-white">${idx[id]}</span>`;
                    const actions = document.createElement('div'); actions.className = 'flex gap-2';
                    if (id !== state.currentMapId) { const loadBtn = document.createElement('button'); loadBtn.innerText = "Load"; loadBtn.className = "text-xs bg-green-700 hover:bg-green-600 text-white px-2 py-1 rounded"; loadBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.loadMap(id); document.getElementById('slots-modal').classList.remove('open'); }; actions.appendChild(loadBtn); } else { const activeBadge = document.createElement('span'); activeBadge.innerText = "Active"; activeBadge.className = "text-[10px] bg-indigo-600 text-white px-2 py-1 rounded"; actions.appendChild(activeBadge); }
                    if (id !== 'default') { const delBtn = document.createElement('button'); delBtn.innerText = "X"; delBtn.className = "text-xs bg-red-900/50 hover:bg-red-700 text-red-200 px-2 py-1 rounded"; delBtn.onclick = (e) => { e.stopPropagation(); MapStorageManager.deleteMap(id); }; actions.appendChild(delBtn); }
                    row.appendChild(actions); list.appendChild(row);
                });
            }
        };

        const rollover = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), new THREE.MeshBasicMaterial({color:0x38BDF8, wireframe:true, opacity:0.5, transparent:true})); scene.add(rollover);
        const tokenRoll = new THREE.Mesh(tokenGeo, new THREE.MeshBasicMaterial({color:0xFCD34D, wireframe:true})); tokenRoll.visible=false; scene.add(tokenRoll);

        function rotatePlacement() {
            state.placementRotation += Math.PI / 2;
            state.placementRotation = state.placementRotation % (Math.PI * 2);
            rollover.rotation.y = state.placementRotation;
        }

        function getVoxelPos(pt, norm, mode) { const p = pt.clone(); if(mode==='build') p.add(norm.clone().multiplyScalar(0.5)); else p.add(norm.clone().multiplyScalar(-0.1)); return p.floor().addScalar(0.5); }
        function checkCollision(pos) {
            if(state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies' || isFlying) return false;
            const r=0.3, h=1.6, minX=Math.floor(pos.x-r), maxX=Math.ceil(pos.x+r), minY=Math.floor(pos.y-h), maxY=Math.ceil(pos.y), minZ=Math.floor(pos.z-r), maxZ=Math.ceil(pos.z+r);
            for(let x=minX; x<maxX; x++) for(let y=minY; y<maxY; y++) for(let z=minZ; z<maxZ; z++) { if(state.mapData.has(`${x},${y},${z}`) && (pos.x-r < x+0.5 && pos.x+r > x-0.5 && pos.y-h < y+0.5 && pos.y > y-0.5 && pos.z-r < z+0.5 && pos.z+r > z-0.5)) return true; }
            return false;
        }

        function snapCameraTo(token) {
            if(!token) return;
            const targetPos = token.position.clone();
            const camOffset = new THREE.Vector3(0, 10, 8); 
            camera.position.copy(targetPos).add(camOffset);
            camera.up.set(0, 1, 0);
            camera.lookAt(targetPos);
            RangeRingManager.update(token, 'focus');
            document.getElementById('focus-label').innerText = token.userData.data.name;
        }

        function updateFocusMode(mode) {
            state.focusList = [];
            state.tokenData.forEach(t => {
                if (t.userData.isToken) {
                    if (mode === 'players' && t.userData.data.type === 'player') state.focusList.push(t);
                    if (mode === 'enemies' && t.userData.data.type === 'monster') state.focusList.push(t);
                }
            });
            if (state.focusList.length > 0) {
                if (state.controlledToken && state.focusList.includes(state.controlledToken)) { state.focusIndex = state.focusList.indexOf(state.controlledToken); } else { state.focusIndex = 0; }
                snapCameraTo(state.focusList[state.focusIndex]);
                state.controlledToken = state.focusList[state.focusIndex];
                state.moveBudget = 30; 
                RangeRingManager.update(state.controlledToken, 'movement');
                document.getElementById('move-badge').style.display = 'block';
                document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
            } else {
                RangeRingManager.update(null);
                state.controlledToken = null;
                document.getElementById('focus-label').innerText = "No Targets";
            }
        }

        function cycleFocus(direction) {
            if (state.focusList.length === 0) return;
            state.focusIndex += direction;
            if (state.focusIndex >= state.focusList.length) state.focusIndex = 0;
            if (state.focusIndex < 0) state.focusIndex = state.focusList.length - 1;
            const token = state.focusList[state.focusIndex];
            snapCameraTo(token);
            state.controlledToken = token;
            state.moveBudget = 30;
            RangeRingManager.update(state.controlledToken, 'movement');
            document.getElementById('move-badge').style.display = 'block';
            document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`;
        }

        function handleRaycast() {
            if(!controls.isLocked && !state.isTouch && state.mode!=='view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            if (controls.isLocked || state.isTouch) { raycaster.setFromCamera(new THREE.Vector2(0,0), camera); } else { raycaster.setFromCamera(mouse, camera); }
            const hits = raycaster.intersectObjects([...state.mapData.values(), ...state.tokenData.values(), scene.getObjectByName('ground')]);
            rollover.visible = false; tokenRoll.visible = false; UIManager.updateTooltip(null);

            if(hits.length) {
                const hit = hits[0]; 
                UIManager.updateTooltip(hit.object.name==='ground'?null:hit.object);
                
                if (state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies') {
                    if (state.controlledToken) {
                         if(hit.object.userData.isVoxel || hit.object.name === 'ground') {
                            rollover.visible = true;
                            if(rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                            let floorY = hit.object.name === 'ground' ? 0 : Math.round(hit.point.y);
                            if (hit.face.normal.y < 0.9 && hit.object.userData.isVoxel) floorY = Math.floor(hit.point.y); 
                            const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                            const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                            const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                            rollover.scale.set(1, 0.1, 1); rollover.position.set(tx, floorY+0.05, tz);
                            if (cost <= state.moveBudget) { rollover.material.color.setHex(CONFIG.colors.valid); document.getElementById('tooltip').innerHTML = `<div class="text-green-400 font-bold">Move: ${cost}ft</div>`; }
                            else { rollover.material.color.setHex(CONFIG.colors.invalid); document.getElementById('tooltip').innerHTML = `<div class="text-red-400 font-bold">Far: ${cost}ft</div>`; }
                            document.getElementById('tooltip').style.display = 'block';
                        }
                    }
                    return {hit, interactable:true};
                }
                
                if (state.gameMode === 'build') {
                    const cat = CATEGORIES[state.activeCategoryIdx];
                    if(cat.type === 'block') {
                        rollover.visible = true;
                        if(state.dragStart) {
                            if (rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                            const s = state.dragStart.pos, e = getVoxelPos(hit.point, hit.face.normal, state.dragStart.mode);
                            const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                            rollover.scale.set(maxX-minX+1, maxY-minY+1, maxZ-minZ+1); rollover.position.set(minX+(maxX-minX+1)/2-0.5, minY+(maxY-minY+1)/2-0.5, minZ+(maxZ-minZ+1)/2-0.5);
                            rollover.rotation.y = 0; 
                            rollover.material.color.setHex(state.dragStart.mode==='delete' ? CONFIG.colors.delete : CONFIG.colors.highlight);
                        } else { 
                            const p = hit.point.clone().add(hit.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5); 
                            rollover.scale.set(1,1,1); rollover.position.copy(p); rollover.material.color.setHex(CONFIG.colors.highlight); 
                            
                            const mat = cat.items[state.subSelections[state.activeCategoryIdx]];
                            if (mat !== undefined && MATERIALS[mat].type.startsWith('stair')) {
                                if (rollover.geometry !== GeometryManager.get('stair')) rollover.geometry = GeometryManager.get('stair');
                                rollover.rotation.y = state.placementRotation;
                            } else {
                                if (rollover.geometry !== GeometryManager.get(0)) rollover.geometry = GeometryManager.get(0);
                                rollover.rotation.y = 0;
                            }
                        }
                    } else if (cat.type === 'token' || cat.type === 'loot') {
                        tokenRoll.visible = true;
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        let fy = hit.object.name==='ground'?0:(hit.face.normal.y>0.9?Math.round(hit.point.y):Math.floor(hit.point.y));
                        tokenRoll.position.set(tx, fy+(cat.type==='loot'?0.2:0.1), tz);
                    }
                    return {hit, interactable:true};
                }
            } 
            return {interactable:false};
        }

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (isRightMouseDown && !controls.isLocked) {
                const movementX = event.clientX - lastMouseX; const movementY = event.clientY - lastMouseY;
                camera.rotation.y -= movementX * 0.002; camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, camera.rotation.x ) );
            }
            lastMouseX = event.clientX; lastMouseY = event.clientY;
        });

        // FIXED: Removed global touch listeners which caused snapping issues.
        
        const touchState = { moveId: null, moveStart: { x: 0, y: 0 }, lookId: null, lookLast: { x: 0, y: 0 } };
        const joyUI = document.getElementById('joystick-ui'); const joyKnob = document.getElementById('joystick-knob');
        const zoneMove = document.getElementById('zone-move');

        zoneMove.addEventListener('touchstart', (e) => {
            e.preventDefault(); const touch = e.changedTouches[0];
            if(touchState.moveId === null) {
                touchState.moveId = touch.identifier; touchState.moveStart = { x: touch.clientX, y: touch.clientY };
                joyUI.style.display = 'block'; joyUI.style.left = touch.clientX + 'px'; joyUI.style.top = touch.clientY + 'px'; joyKnob.style.transform = `translate(-50%, -50%)`;
            }
        }, { passive: false });

        zoneMove.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.moveId) {
                    const maxDist = 50; let dx = touch.clientX - touchState.moveStart.x; let dy = touch.clientY - touchState.moveStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy); if (dist > maxDist) { const ratio = maxDist / dist; dx *= ratio; dy *= ratio; }
                    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    
                    // FIXED: Inverted Z-axis calculation. Dragging Up (negative dy) should result in forward movement (positive velocity.z input).
                    state.moveVector.x = dx / maxDist; 
                    state.moveVector.z = -dy / maxDist; 
                }
            }
        }, { passive: false });

        const endMove = (e) => { for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchState.moveId) { touchState.moveId = null; state.moveVector = { x: 0, z: 0 }; joyUI.style.display = 'none'; } } };
        zoneMove.addEventListener('touchend', endMove); zoneMove.addEventListener('touchcancel', endMove);

        const zoneLook = document.getElementById('zone-look');
        zoneLook.addEventListener('touchstart', (e) => { const touch = e.changedTouches[0]; if(touchState.lookId === null) { touchState.lookId = touch.identifier; touchState.lookLast = { x: touch.clientX, y: touch.clientY }; } }, { passive: false });

        zoneLook.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === touchState.lookId) {
                    const dx = touch.clientX - touchState.lookLast.x; 
                    const dy = touch.clientY - touchState.lookLast.y;
                    
                    // FIXED: Pitch Logic. Rotate Body for YAW, Camera for PITCH.
                    // This separates axes to prevent roll issues.
                    
                    // Yaw (Left/Right) - Rotate the Player Body
                    controls.getObject().rotation.y -= dx * 0.005;
                    
                    // Pitch (Up/Down) - Rotate the Camera
                    camera.rotation.x -= dy * 0.005;
                    
                    // Clamp Pitch
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    touchState.lookLast = { x: touch.clientX, y: touch.clientY };
                }
            }
        }, { passive: false });

        const endLook = (e) => { for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchState.lookId) { touchState.lookId = null; } } };
        zoneLook.addEventListener('touchend', endLook); zoneLook.addEventListener('touchcancel', endLook);
        
        const simulateClick = (btn, type) => { const event = new MouseEvent(type, { bubbles: true, cancelable: true, view: window, button: btn }); document.dispatchEvent(event); };
        const touchBtns = ['mob-place', 'mob-break', 'mob-fly', 'mob-up', 'mob-down', 'mob-rotate'];
        touchBtns.forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault(); e.stopPropagation(); 
                    if (id === 'mob-place') { simulateClick(2, 'mousedown'); setTimeout(() => simulateClick(2, 'mouseup'), 50); } 
                    else if (id === 'mob-break') { simulateClick(0, 'mousedown'); setTimeout(() => simulateClick(0, 'mouseup'), 50); } 
                    else if (id === 'mob-fly') { isFlying = !isFlying; velocity.y = 0; el.classList.toggle('bg-yellow-700'); const vControls = document.getElementById('mobile-vertical-controls'); if(vControls) vControls.style.display = isFlying ? 'flex' : 'none'; } 
                    else if (id === 'mob-rotate') { rotatePlacement(); }
                    else if (id === 'mob-up') { move.u = true; } 
                    else if (id === 'mob-down') { move.d = true; }
                }, { passive: false });
                el.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); if (id === 'mob-up') move.u = false; if (id === 'mob-down') move.d = false; });
            }
        });

        document.addEventListener('keydown', e => {
            if(e.repeat) return;
            if(e.code === 'KeyW') move.f=true; if(e.code === 'KeyS') move.b=true; if(e.code === 'KeyA') move.l=true; if(e.code === 'KeyD') move.r=true;
            if(e.code === 'Space') { if(isFlying || state.gameMode === 'dm') move.u=true; else if(canJump) { velocity.y+=15; canJump=false; } }
            if(e.code === 'KeyC') { if(isFlying || state.gameMode === 'dm') move.d=true; } 
            if(e.code === 'KeyF') { isFlying=!isFlying; velocity.y=0; }
            if(e.code === 'KeyR') { if(e.shiftKey) { } else { rotatePlacement(); } }
            if(e.code === 'Tab') {
                e.preventDefault();
                if (state.gameMode === 'players' || state.gameMode === 'enemies') { if (state.focusList && state.focusList.length > 0) { snapCameraTo(state.focusList[state.focusIndex]); } } 
                else { if(controls.isLocked) { controls.unlock(); state.mode='menu'; document.getElementById('mouse-mode-badge').style.display='block'; } else { if (!state.isTouch) controls.lock(); state.mode='view'; document.getElementById('mouse-mode-badge').style.display='none'; } }
            }
            if(e.code === 'Escape') { if(state.controlledToken) { state.controlledToken = null; state.moveBudget = 30; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } }
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=true; state.activeCategoryIdx=i; UIManager.renderHotbar(); }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') move.f=false; if(e.code === 'KeyS') move.b=false; if(e.code === 'KeyA') move.l=false; if(e.code === 'KeyD') move.r=false;
            if(e.code === 'Space') move.u=false; if(e.code === 'KeyC') move.d=false;
            if (e.key >= '0' && e.key <= '9') { const i = e.key==='0'?9:parseInt(e.key)-1; state.heldKeys[i]=false; }
        });

        document.addEventListener('mousedown', e => {
            if (e.button === 2) { isRightMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; }
            if(!controls.isLocked && state.mode !== 'view' && state.gameMode !== 'players' && state.gameMode !== 'enemies' && state.gameMode !== 'dm') return;
            const res = handleRaycast();
            if(!res.interactable) { if(e.button===0) { state.controlledToken = null; state.focusedToken = null; RangeRingManager.update(null); document.getElementById('move-badge').style.display='none'; } return; }
            const {hit} = res;
            if (state.gameMode === 'dm' || state.gameMode === 'players' || state.gameMode === 'enemies') {
                if (e.button === 0) { 
                    if (state.controlledToken && (hit.object.userData.isVoxel || hit.object.name === 'ground')) {
                        let floorY = hit.object.name==='ground'?0:Math.round(hit.point.y); if(hit.face.normal.y<0.9 && hit.object.userData.isVoxel) floorY=Math.floor(hit.point.y);
                        const tx = Math.floor(hit.point.x + hit.face.normal.x*0.1) + 0.5, tz = Math.floor(hit.point.z + hit.face.normal.z*0.1) + 0.5;
                        const targetPos = new THREE.Vector3(tx, floorY + 0.1, tz);
                        const cost = Math.ceil(state.controlledToken.position.distanceTo(targetPos)) * 5;
                        if (cost <= state.moveBudget) { 
                            state.controlledToken.position.copy(targetPos); state.moveBudget -= cost; document.getElementById('move-badge').innerText = `Movement: ${state.moveBudget}ft`; 
                            RangeRingManager.update(state.controlledToken, 'movement'); MapStorageManager.saveMap();
                        }
                    }
                    return;
                }
            }
            if (e.shiftKey && e.button === 2 && hit.object.userData.isToken) { state.focusedToken = hit.object; RangeRingManager.update(state.focusedToken, 'conditions'); const p = hit.object.position; controls.getObject().position.set(p.x, p.y+5, p.z+5); controls.getObject().lookAt(p); return; }
            if (state.gameMode === 'build') {
                const cat = CATEGORIES[state.activeCategoryIdx];
                if(e.button === 2) {
                    if(cat.type==='block') { state.dragStart = {pos:getVoxelPos(hit.point, hit.face.normal, 'build'), mode:'build'}; }
                    else if(cat.type==='token' || cat.type==='loot') {
                        const d = cat.items[state.subSelections[state.activeCategoryIdx]];
                        if(d) {
                             const p = tokenRoll.position.clone();
                             if(cat.type==='token') { if(state.tokenData.has(d.id)) state.tokenData.get(d.id).position.copy(p); } 
                             else { const m = new THREE.Mesh(lootGeo, new THREE.MeshLambertMaterial({color:0xFFD700})); m.position.copy(tokenRoll.position); m.userData={isLoot:true, id:`l${Date.now()}`, data:d}; scene.add(m); state.tokenData.set(m.userData.id, m); }
                             MapStorageManager.saveMap();
                        }
                    }
                } else if(e.button===0) {
                    if(cat.type==='block' && hit.object.userData.isVoxel) state.dragStart={pos:getVoxelPos(hit.point, hit.face.normal, 'delete'), mode:'delete'};
                    else if(hit.object.userData.isLoot) { scene.remove(hit.object); state.tokenData.delete(hit.object.userData.id); MapStorageManager.saveMap(); }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) isRightMouseDown = false;
            if(!state.dragStart) return;
            const res = handleRaycast();
            if(res.interactable) {
                const s = state.dragStart.pos, e = getVoxelPos(res.hit.point, res.hit.face.normal, state.dragStart.mode);
                const minX=Math.min(s.x,e.x), maxX=Math.max(s.x,e.x), minY=Math.min(s.y,e.y), maxY=Math.max(s.y,e.y), minZ=Math.min(s.z,e.z), maxZ=Math.max(s.z,e.z);
                const mat = CATEGORIES[state.activeCategoryIdx].items[state.subSelections[state.activeCategoryIdx]];
                if((maxX-minX)*(maxY-minY)*(maxZ-minZ) > 5000) { console.warn("Too big"); state.dragStart=null; rollover.scale.set(1,1,1); return; }
                
                const rot = state.placementRotation;
                let chg=0;
                for(let x=minX; x<=maxX; x++) for(let y=minY; y<=maxY; y++) for(let z=minZ; z<=maxZ; z++) {
                    if(state.dragStart.mode==='build') { if(mat!==undefined){WorldManager.add(x,y,z,mat,rot,false); chg++;} } 
                    else { const m=state.mapData.get(`${x},${y},${z}`); if(m){WorldManager.remove(m); chg++;} }
                }
                // Update self and neighbors for corners
                for(let x=minX-1; x<=maxX+1; x++) for(let y=minY-1; y<=maxY+1; y++) for(let z=minZ-1; z<=maxZ+1; z++) WorldManager.updateGeo(x,y,z);
                document.getElementById('block-count').innerText = `${state.mapData.size} Blocks`;
                if(chg) MapStorageManager.saveMap();
            }
            state.dragStart=null; rollover.scale.set(1,1,1);
        });

        document.addEventListener('wheel', e => {
            if (state.gameMode === 'players' || state.gameMode === 'enemies') {
                const zoomSpeed = 0.5; const zoomDir = new THREE.Vector3(); camera.getWorldDirection(zoomDir);
                if (e.deltaY > 0) zoomDir.negate(); camera.position.add(zoomDir.multiplyScalar(zoomSpeed)); return;
            }
            const i = Object.keys(state.heldKeys).find(k=>state.heldKeys[k]); const target = i !== undefined ? i : state.activeCategoryIdx;
            const c = CATEGORIES[target]; if(!c.items.length) return;
            let s = state.subSelections[target] + (e.deltaY>0?1:-1); if(s<0) s=c.items.length-1; if(s>=c.items.length) s=0;
            state.subSelections[target] = s; UIManager.renderHotbar();
        });

        document.getElementById('btn-apps-dropdown').onclick = (e) => { e.stopPropagation(); document.getElementById('apps-dropdown-content').classList.toggle('show'); };
        window.onclick = (e) => { if (!e.target.matches('#btn-apps-dropdown') && !e.target.closest('#btn-apps-dropdown')) { const dropdowns = document.getElementsByClassName("dropdown-content"); for (let i = 0; i < dropdowns.length; i++) { if (dropdowns[i].classList.contains('show')) dropdowns[i].classList.remove('show'); } } };

        document.getElementById('instructions').onclick = () => { 
            toggleFullScreen(); // Try to enable fullscreen on start click
            if (state.gameMode === 'players' || state.gameMode === 'enemies') { 
                document.getElementById('instructions').style.display='none'; 
                document.getElementById('ui-layer').classList.add('interactive'); 
            } else { 
                if (!state.isTouch) controls.lock(); 
                else document.getElementById('instructions').style.display='none'; 
            } 
        };
        
        // Fullscreen Helper
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            }
        }

        controls.addEventListener('lock', () => { document.getElementById('instructions').style.display='none'; document.getElementById('ui-layer').classList.remove('interactive'); });
        controls.addEventListener('unlock', () => { if(state.mode==='menu' || state.gameMode === 'players' || state.gameMode === 'enemies' || state.gameMode === 'dm') { document.getElementById('ui-layer').classList.add('interactive'); } else { if(!state.isTouch) document.getElementById('instructions').style.display='block'; } });
        
        document.getElementById('mode-build').onclick = () => setMode('build'); 
        document.getElementById('mode-dm').onclick = () => setMode('dm');
        document.getElementById('mode-players').onclick = () => setMode('players');
        document.getElementById('mode-enemies').onclick = () => setMode('enemies');
        
        document.getElementById('focus-next').onclick = () => cycleFocus(1);
        document.getElementById('focus-prev').onclick = () => cycleFocus(-1);
        document.getElementById('next-turn-btn').onclick = () => { EntityManager.advanceTurn(); };

        document.getElementById('btn-slots').onclick = () => { UIManager.renderSlots(); document.getElementById('slots-modal').classList.add('open'); };
        document.getElementById('close-slots').onclick = () => document.getElementById('slots-modal').classList.remove('open');
        document.getElementById('create-map-btn').onclick = () => { const name = document.getElementById('new-map-name').value; if(name) { const id = MapStorageManager.createMap(name); MapStorageManager.loadMap(id); WorldManager.clear(true); UIManager.renderSlots(); document.getElementById('new-map-name').value = ''; } };

        function applyInputScheme(mode) {
            state.isTouch = (mode === 'touch'); localStorage.setItem('akashic_input_scheme', mode);
            const mobControls = document.getElementById('mobile-controls'); const instructions = document.getElementById('instructions');
            if (state.isTouch) { 
                mobControls.style.display = 'block'; 
                instructions.style.display = 'none'; 
                toggleFullScreen(); // Try to enable fullscreen on touch selection
            } 
            else { mobControls.style.display = 'none'; if(state.gameMode === 'build' && !controls.isLocked) instructions.style.display = 'block'; }
            document.getElementById('controls-modal').classList.remove('open');
        }

        function initInputScheme() { const saved = localStorage.getItem('akashic_input_scheme'); if (saved) { applyInputScheme(saved); } else { document.getElementById('controls-modal').classList.add('open'); } }

        document.getElementById('scheme-mouse').onclick = () => applyInputScheme('mouse');
        document.getElementById('scheme-touch').onclick = () => applyInputScheme('touch');
        document.getElementById('btn-input-toggle').onclick = () => document.getElementById('controls-modal').classList.add('open');

        function setMode(m) {
            state.gameMode = m; document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active')); document.getElementById(`mode-${m}`).classList.add('active');
            document.getElementById('instr-build').style.display = m==='build'?'grid':'none'; 
            document.getElementById('instr-dm').style.display = m==='dm'?'grid':'none';
            document.getElementById('instr-focus').style.display = (m==='players'||m==='enemies')?'grid':'none';
            const focusControls = document.getElementById('focus-controls');
            if (m === 'players' || m === 'enemies') { focusControls.classList.add('visible'); updateFocusMode(m); } 
            else { focusControls.classList.remove('visible'); RangeRingManager.update(null); if(m==='dm') { isFlying=true; velocity.y=0; } if (m === 'build') { camera.rotation.z = 0; camera.rotation.x = 0; camera.up.set(0, 1, 0); if (!state.isTouch) controls.lock(); } }
            UIManager.renderHotbar();
        }
        document.getElementById('btn-sync').onclick = EntityManager.sync; 
        document.getElementById('btn-clear').onclick = () => { 
            // Bypass confirm for preview stability
            // if(confirm("Nuke this map?")) { 
            if(true) {
                WorldManager.clear(); MapStorageManager.saveMap(); 
            } 
        };
        document.getElementById('btn-export').onclick = () => { const data = { voxels: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_voxels`)), positions: JSON.parse(localStorage.getItem(`akashic_map_${state.currentMapId}_positions`)) }; const b=new Blob([JSON.stringify(data)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=`map_${state.currentMapId}.json`; a.click(); };
        document.getElementById('btn-import').onclick = () => document.getElementById('file-input').click();
        document.getElementById('file-input').onchange = (e) => { const r=new FileReader(); r.onload=ev=>{ try { const d = JSON.parse(ev.target.result); localStorage.setItem(`akashic_map_${state.currentMapId}_voxels`, JSON.stringify(d.voxels)); localStorage.setItem(`akashic_map_${state.currentMapId}_positions`, JSON.stringify(d.positions)); MapStorageManager.loadMap(state.currentMapId); } catch(e) { console.error("Invalid Map File"); } }; r.readAsText(e.target.files[0]); };

        function animate() {
            requestAnimationFrame(animate);
            const dt = (performance.now()-prevTime)/1000; prevTime=performance.now();
            
            // Update animations
            TextureAnimator.update(performance.now());

            const physicsEnabled = (controls.isLocked || state.isTouch) && state.gameMode !== 'players' && state.gameMode !== 'enemies';

            if(physicsEnabled) {
                velocity.x -= velocity.x * 10.0 * dt; 
                velocity.z -= velocity.z * 10.0 * dt;
                
                if (state.gameMode === 'dm') velocity.y -= velocity.y * 5.0 * dt; 
                else velocity.y -= isFlying ? velocity.y * 5.0 * dt : 9.8 * 2.0 * dt;

                const spd = isFlying || state.gameMode==='dm' ? 40 : 15;
                let inputX = 0; let inputZ = 0;

                if (state.isTouch) { inputX = state.moveVector.x; inputZ = state.moveVector.z; } 
                else { inputZ = Number(move.f) - Number(move.b); inputX = Number(move.r) - Number(move.l); }
                
                if (inputZ !== 0 || inputX !== 0) { velocity.z += inputZ * spd * 10.0 * dt; velocity.x += inputX * spd * 10.0 * dt; }
                if ((isFlying || state.gameMode==='dm')) { if (move.u) velocity.y += spd * 10.0 * dt; if (move.d) velocity.y -= spd * 10.0 * dt; }

                const obj = controls.getObject(), startPos = obj.position.clone();
                controls.moveRight(velocity.x * dt); 
                if(checkCollision(obj.position)) { if (!isFlying && state.gameMode !== 'dm') { obj.position.y += 0.6; if (checkCollision(obj.position)) { obj.position.y = startPos.y; obj.position.x = startPos.x; } } else { obj.position.x = startPos.x; } }
                
                // FIXED: Forward (W) moves in +Z direction relative to camera facing (standard WASD)
                // If velocity.z is positive (W pressed), moveForward(positive) moves forward.
                controls.moveForward(velocity.z * dt); 
                if(checkCollision(obj.position)) { if (!isFlying && state.gameMode !== 'dm') { const currentY = obj.position.y; obj.position.y += 0.6; if (checkCollision(obj.position)) { obj.position.y = currentY; obj.position.z = startPos.z; } } else { obj.position.z = startPos.z; } }
                
                obj.position.y += velocity.y * dt;
                if(checkCollision(obj.position) || (obj.position.y<2 && state.gameMode!=='dm')) { if(velocity.y<0) { canJump=true; obj.position.y = Math.ceil(obj.position.y); } else { obj.position.y = Math.floor(obj.position.y)-0.6; } velocity.y=0; if(obj.position.y < 2) obj.position.y = 2; }
                const p = obj.position; document.getElementById('coord-display').innerText = `${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;
                handleRaycast();
            }
            renderer.render(scene, camera);
        }

        if (!MapStorageManager.loadMap('default')) { MapStorageManager.saveIndex({'default': 'Default Map'}); MapStorageManager.loadMap('default'); }
        EntityManager.sync(); UIManager.renderHotbar(); initInputScheme(); 
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>