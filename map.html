<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akashic Atlas (3D Map)</title>
    <!-- Tailwind for matching the suite's theme -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: ui-sans-serif, system-ui, sans-serif; }
        
        /* UI Overlay Styles matching Astral Theme */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Custom Scrollbar for lists */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference;
        }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: rgba(255, 255, 255, 0.8); }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: rgba(255, 255, 255, 0.8); }

        /* Floating Tooltip for Hovered Token */
        #tooltip {
            position: absolute; display: none;
            background: rgba(15, 23, 42, 0.9); border: 1px solid #475569;
            padding: 8px 12px; border-radius: 8px; color: white;
            backdrop-filter: blur(4px); pointer-events: none;
            transform: translate(-50%, -120%); white-space: nowrap;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 20;
        }

        /* Material Slot */
        .slot { width: 36px; height: 36px; border: 2px solid rgba(255,255,255,0.1); cursor: pointer; transition: all 0.2s; border-radius: 4px; }
        .slot:hover { transform: scale(1.1); border-color: white; }
        .slot.active { border-color: #38BDF8; box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); transform: scale(1.1); }

        /* Token Slot (Vertical Bar) */
        .token-slot { 
            display: flex; align-items: center; gap: 8px;
            padding: 6px 10px; margin-bottom: 4px;
            background: rgba(30, 41, 59, 0.8); border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 6px; cursor: pointer; transition: all 0.2s;
            color: #cbd5e1; font-size: 0.75rem;
        }
        .token-slot:hover { background: rgba(51, 65, 85, 0.9); border-color: #94a3b8; transform: translateX(4px); }
        .token-slot.active { background: rgba(56, 189, 248, 0.2); border-color: #38BDF8; color: white; font-weight: bold; }
        .token-slot .key-hint { 
            font-family: monospace; font-size: 0.65rem; 
            background: rgba(0,0,0,0.3); padding: 2px 4px; rounded: 4px; color: #94a3b8;
        }
        .token-slot.active .key-hint { color: #38BDF8; background: rgba(56, 189, 248, 0.1); }
    </style>
</head>
<body>

    <!-- UI OVERLAY -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- HEADER -->
        <header class="pointer-events-auto flex justify-between items-start">
            <div class="bg-slate-900/90 border border-slate-700 p-3 rounded-xl shadow-lg backdrop-blur-sm">
                <h1 class="text-xl font-bold text-white flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-cyan-400"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>
                    Akashic Atlas
                </h1>
                <div class="text-xs text-slate-400 mt-1 flex gap-2">
                    <span id="coords">0, 0, 0</span> | <span id="block-count">0</span> Blocks
                </div>
            </div>

            <!-- NAVIGATION (Matches Suite) -->
            <div class="flex gap-2">
                <a href="./index.html" class="pointer-events-auto bg-slate-900 border border-slate-700 p-2 rounded-full text-slate-400 hover:text-white transition-colors" title="Hub">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                </a>
                <a href="./tome.html" class="pointer-events-auto bg-purple-900/80 border border-purple-600 p-2 rounded-full text-white hover:bg-purple-800 transition-colors" title="Tracker">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></svg>
                </a>
            </div>
        </header>

        <!-- TOKEN ROSTER (Left Side) -->
        <div id="token-bar-container" class="absolute left-4 top-24 bottom-24 overflow-y-auto pointer-events-auto w-48 hidden sm:block">
            <h3 class="text-xs font-bold text-slate-500 uppercase mb-2 bg-slate-900/50 p-1 rounded backdrop-blur-sm">Active Tokens</h3>
            <div id="token-bar">
                <!-- Generated by JS -->
            </div>
        </div>

        <!-- INSTRUCTIONS / START -->
        <div id="instructions" class="pointer-events-auto absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-900/90 border border-cyan-500/50 p-8 rounded-2xl text-center shadow-[0_0_50px_rgba(6,182,212,0.15)] backdrop-blur-md cursor-pointer hover:border-cyan-400 transition-all">
            <h2 class="text-2xl font-bold text-white mb-2">Click to Enter</h2>
            <div class="space-y-2 text-slate-300 text-sm">
                <p><strong class="text-cyan-400">WASD</strong> Move | <strong class="text-cyan-400">Space</strong> Jump/Fly</p>
                <p><strong class="text-cyan-400">Left Click</strong> Destroy</p>
                <p><strong class="text-cyan-400">Right Click</strong> Place Block / Move Token</p>
                <div class="border-t border-slate-700 pt-2 mt-2">
                    <p><strong class="text-cyan-400">1-9</strong> Select Block</p>
                    <p><strong class="text-indigo-400">Shift + 1-9</strong> Select Token</p>
                </div>
            </div>
            <div class="mt-6 pt-4 border-t border-slate-700">
                <p class="text-xs text-indigo-300 animate-pulse">Syncs with Akashic Tracker Data</p>
            </div>
        </div>

        <!-- TOOLBAR & SYNC CONTROLS -->
        <div class="pointer-events-auto flex flex-col items-center gap-2 mb-4">
            <!-- Sync Panel -->
            <div class="bg-slate-900/90 border border-slate-700 p-2 rounded-lg flex items-center gap-3 backdrop-blur-md">
                <button id="btn-sync" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold px-3 py-1.5 rounded flex items-center gap-2 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    Sync Tokens
                </button>
                <div class="h-4 w-px bg-slate-700"></div>
                <button id="btn-save" class="text-xs text-slate-400 hover:text-white">Save Map</button>
                <button id="btn-clear" class="text-xs text-red-400 hover:text-red-300">Clear</button>
                <input type="file" id="file-input" accept=".json" class="hidden">
            </div>

            <!-- Material Toolbar -->
            <div id="toolbar" class="bg-slate-900/90 border border-slate-700 p-2 rounded-xl flex gap-2 backdrop-blur-md">
                <!-- Generated by JS -->
            </div>
        </div>
    </div>

    <!-- 3D ELEMENTS -->
    <div id="crosshair"></div>
    <div id="tooltip"></div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const WORLD_SIZE = 256;
        const BLOCK_SIZE = 1;
        
        // Astral Palette
        const MATERIALS = [
            { color: 0x4b6e32, name: "Grass" },       
            { color: 0x5c3c28, name: "Dirt" },        
            { color: 0x64748b, name: "Stone" },       // Slate-ish stone
            { color: 0x8B4513, name: "Wood" },        
            { color: 0x38BDF8, name: "Water", transparent: true, opacity: 0.6 }, // Cyan Water
            { color: 0xE6C288, name: "Sand" },        
            { color: 0xf1f5f9, name: "Snow" },        
            { color: 0xF43F5E, name: "Lava" },        // Rose Red Lava
            { color: 0x1e293b, name: "Dungeon" }      // Dark Slate
        ];

        // --- Globals ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let canJump = false, isFlying = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let lastSpaceKeyTime = 0;

        // Data Storage
        const voxels = new Map(); // Standard blocks
        const objects = []; // For raycasting
        const tokens = new Map(); // Combatant Tokens (distinct from voxels)
        let combatantList = []; // Array for UI and indexing
        
        // Interaction State
        let selectedMaterialIndex = 0;
        let heldTokenId = null; // ID of token currently being moved
        let isShiftDown = false;

        // Visuals
        let rollOverMesh; // Box cursor
        let tokenRollOverMesh; // Cylinder cursor (Ghost token)
        let voxelGeometry, tokenGeometry;
        const threeMaterials = [];

        // UI
        const instructions = document.getElementById('instructions');
        const tooltip = document.getElementById('tooltip');
        const toolbar = document.getElementById('toolbar');
        const tokenBar = document.getElementById('token-bar');

        // --- INITIALIZATION ---
        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617); // Slate 950
            scene.fog = new THREE.Fog(0x020617, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => instructions.style.display = 'none');
            controls.addEventListener('unlock', () => instructions.style.display = 'block');
            scene.add(controls.getObject());

            // Input
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            document.addEventListener('mousemove', onMouseMove); // For tooltip

            // World Base
            const planeGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            planeGeo.rotateX(-Math.PI / 2);
            const plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
            plane.name = "ground";
            scene.add(plane);
            objects.push(plane);

            const gridHelper = new THREE.GridHelper(WORLD_SIZE, WORLD_SIZE, 0x334155, 0x1e293b);
            scene.add(gridHelper);

            // Raycaster & Geometries
            raycaster = new THREE.Raycaster();
            voxelGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            tokenGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16); 

            // Materials
            MATERIALS.forEach(m => {
                threeMaterials.push(new THREE.MeshLambertMaterial({ 
                    color: m.color, 
                    transparent: !!m.transparent, 
                    opacity: m.opacity || 1.0 
                }));
            });

            // Block Cursor (Box)
            const rollOverGeo = new THREE.BoxGeometry(BLOCK_SIZE + 0.05, BLOCK_SIZE + 0.05, BLOCK_SIZE + 0.05);
            rollOverMesh = new THREE.Mesh(rollOverGeo, new THREE.MeshBasicMaterial({ color: 0x38BDF8, opacity: 0.5, transparent: true, wireframe: true }));
            scene.add(rollOverMesh);

            // Token Cursor (Ghost Cylinder)
            tokenRollOverMesh = new THREE.Mesh(tokenGeometry, new THREE.MeshBasicMaterial({ color: 0xFCD34D, opacity: 0.5, transparent: true, wireframe: true }));
            tokenRollOverMesh.visible = false;
            scene.add(tokenRollOverMesh);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);

            // Init UI
            initToolbar();
            initButtons();

            // Load Data
            loadMap();
            syncTokensFromTracker(); 
        }

        // --- TRACKER SYNC LOGIC ---

        function syncTokensFromTracker() {
            const raw = localStorage.getItem('dm-tracker-monsters');
            if (!raw) return;
            combatantList = JSON.parse(raw); // Update global list for UI

            const savedPositions = JSON.parse(localStorage.getItem('dm-tracker-map-positions') || '{}');
            const currentIds = new Set();
            
            combatantList.forEach((c, index) => {
                currentIds.add(c.id);
                if (tokens.has(c.id)) {
                    const mesh = tokens.get(c.id);
                    updateTokenVisuals(mesh, c);
                } else {
                    const isMonster = c.type === 'monster';
                    const color = isMonster ? 0xF43F5E : 0x6366f1; 
                    const mat = new THREE.MeshLambertMaterial({ color: color });
                    const mesh = new THREE.Mesh(tokenGeometry, mat);
                    
                    if (savedPositions[c.id]) {
                        mesh.position.set(savedPositions[c.id].x, savedPositions[c.id].y, savedPositions[c.id].z);
                    } else {
                        mesh.position.set(index * 2, 1, 0); 
                    }

                    mesh.userData = { isToken: true, id: c.id, name: c.name, hp: c.currentHp, maxHp: c.maxHp };
                    mesh.name = "token"; 
                    
                    scene.add(mesh);
                    objects.push(mesh); 
                    tokens.set(c.id, mesh);
                    updateTokenVisuals(mesh, c);
                }
            });

            tokens.forEach((mesh, id) => {
                if (!currentIds.has(id)) {
                    scene.remove(mesh);
                    objects.splice(objects.indexOf(mesh), 1);
                    tokens.delete(id);
                }
            });

            saveTokenPositions(); 
            updateBlockCount();
            renderTokenBar(); // Update UI
        }

        function updateTokenVisuals(mesh, data) {
            mesh.userData.hp = data.currentHp;
            mesh.userData.maxHp = data.maxHp;
            mesh.userData.name = data.name; // Keep name synced
            
            if (data.currentHp <= 0 && data.type === 'monster') {
                mesh.rotation.x = Math.PI / 2; 
                mesh.position.y = 0.2; 
                mesh.material.color.setHex(0x334155); 
            } else {
                mesh.rotation.x = 0; 
                const color = data.type === 'monster' ? 0xF43F5E : 0x6366f1;
                mesh.material.color.setHex(color);
                if (mesh.position.y < 0.6) mesh.position.y = 1; 
            }
        }

        function saveTokenPositions() {
            const posData = {};
            tokens.forEach((mesh, id) => {
                posData[id] = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
            });
            localStorage.setItem('dm-tracker-map-positions', JSON.stringify(posData));
        }

        // --- INTERACTION ---

        function onMouseMove(event) {
            if (controls.isLocked) { tooltip.style.display = 'none'; return; } 
        }

        function updateInteraction() {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const obj = intersect.object;
                const hitPoint = intersect.point;
                const normal = intersect.face.normal;

                // 1. Tooltip for Tokens
                if (obj.userData.isToken && heldTokenId === null) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = '50%';
                    tooltip.style.top = '50%';
                    tooltip.innerHTML = `<strong>${obj.userData.name}</strong><br>HP: ${obj.userData.hp}/${obj.userData.maxHp}<br><span style="font-size:10px; color:#cbd5e1;">Right Click to Move</span>`;
                    
                    rollOverMesh.visible = false;
                    tokenRollOverMesh.visible = false;
                    return;
                } else {
                    tooltip.style.display = 'none';
                }

                // 2. Cursor (Ghost Token OR Block)
                if (heldTokenId !== null) {
                    // We are holding a token
                    rollOverMesh.visible = false;
                    tokenRollOverMesh.visible = true;
                    // Snap cylinder to grid center
                    tokenRollOverMesh.position.copy(hitPoint).add(normal);
                    tokenRollOverMesh.position.divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
                    // Cylinder height adjustment (1.2 height -> 0.6 offset)
                    tokenRollOverMesh.position.y = Math.floor(hitPoint.y + 0.1) + 0.6; 
                } else {
                    // Standard block cursor
                    tokenRollOverMesh.visible = false;
                    rollOverMesh.visible = true;
                    rollOverMesh.position.copy(hitPoint).addScaledVector(normal, 0.5)
                        .divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
                }
            } else {
                rollOverMesh.visible = false;
                tokenRollOverMesh.visible = false;
                tooltip.style.display = 'none';
            }
        }

        function onMouseClick(event) {
            if (event.target.closest('#ui-layer')) return;
            if (!controls.isLocked) { controls.lock(); return; }

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const obj = intersect.object;

                // RIGHT CLICK: Move/Place Logic
                if (event.button === 2) { 
                    if (heldTokenId !== null) {
                        // PLACE HELD TOKEN
                        const tokenMesh = tokens.get(heldTokenId);
                        if (tokenMesh) {
                            tokenMesh.position.copy(tokenRollOverMesh.position);
                            // If we placed it on top of a block, fine. 
                            // Ghost logic already handles Y offset roughly.
                            saveTokenPositions();
                            heldTokenId = null; // Drop it
                            renderTokenBar(); // Update UI highlight
                        }
                    } else if (obj.userData.isToken) {
                        // PICK UP TOKEN (Right click on existing)
                        heldTokenId = obj.userData.id;
                        renderTokenBar();
                    } else {
                        // PLACE BLOCK (Standard)
                        const pos = new THREE.Vector3().copy(intersect.point).addScaledVector(intersect.face.normal, 0.5)
                            .divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
                        
                        if (pos.distanceTo(controls.getObject().position) < 1.5) return;
                        addBlock(pos.x, pos.y, pos.z, selectedMaterialIndex);
                    }
                } 
                // LEFT CLICK: Destroy / Cancel
                else if (event.button === 0) { 
                    if (heldTokenId !== null) {
                        // Cancel Move? Just drop it back where it was (nullify hand)
                        // Or simple: Left click doesn't place, just drops focus?
                        // Let's keep it simple: Left click destroys blocks, ignores tokens usually
                        // If holding token, maybe left click cancels pickup?
                        heldTokenId = null;
                        renderTokenBar();
                    } else if (obj.name !== "ground" && !obj.userData.isToken) {
                        removeBlock(obj);
                    }
                }
            }
        }

        // --- VOXEL LOGIC ---

        function addBlock(x, y, z, matIndex, save = true) {
            const key = `${x},${y},${z}`;
            if (voxels.has(key)) return;

            const mesh = new THREE.Mesh(voxelGeometry, threeMaterials[matIndex]);
            mesh.position.set(x, y, z);
            mesh.name = "voxel";
            mesh.userData.colorIndex = matIndex;
            
            scene.add(mesh);
            objects.push(mesh);
            voxels.set(key, mesh);

            if (save) saveMap();
            updateBlockCount();
        }

        function removeBlock(object) {
            scene.remove(object);
            objects.splice(objects.indexOf(object), 1);
            voxels.delete(`${object.position.x},${object.position.y},${object.position.z}`);
            saveMap();
            updateBlockCount();
        }

        // --- PERSISTENCE ---

        function saveMap() {
            const data = [];
            voxels.forEach(v => {
                data.push({ x: v.position.x, y: v.position.y, z: v.position.z, c: v.userData.colorIndex });
            });
            localStorage.setItem('dnd-voxel-map', JSON.stringify(data));
        }

        function loadMap() {
            const raw = localStorage.getItem('dnd-voxel-map');
            if (raw) {
                const data = JSON.parse(raw);
                data.forEach(b => addBlock(b.x, b.y, b.z, b.c, false));
            }
            // If raw is missing, we do NOT load a default floor anymore.
            // Starts empty.
        }

        // --- UI WIRING ---

        function initToolbar() {
            MATERIALS.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = `slot ${i===0?'active':''}`;
                div.style.backgroundColor = '#' + m.color.toString(16).padStart(6,'0');
                div.onclick = () => {
                    selectedMaterialIndex = i;
                    document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                    div.classList.add('active');
                };
                toolbar.appendChild(div);
            });
        }

        function renderTokenBar() {
            tokenBar.innerHTML = '';
            combatantList.forEach((c, i) => {
                // Show first 9 only for shortcuts, or all if list is long but hotkeys only work for 9
                const div = document.createElement('div');
                const isSelected = c.id === heldTokenId;
                div.className = `token-slot ${isSelected ? 'active' : ''}`;
                
                // Color indicator
                const dotColor = c.type === 'monster' ? '#F43F5E' : '#6366f1';
                
                div.innerHTML = `
                    <div style="width:8px; height:8px; border-radius:50%; background:${dotColor};"></div>
                    <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${c.name}</span>
                    ${i < 9 ? `<span class="key-hint">Shift+${i+1}</span>` : ''}
                `;
                
                div.onclick = () => {
                    heldTokenId = c.id;
                    renderTokenBar();
                };
                
                tokenBar.appendChild(div);
            });
        }

        function initButtons() {
            document.getElementById('btn-sync').onclick = () => { syncTokensFromTracker(); alert("Synced!"); };
            document.getElementById('btn-clear').onclick = () => {
                if(confirm("Clear Map Blocks?")) {
                    voxels.forEach(v => scene.remove(v));
                    voxels.clear();
                    objects.length = 0;
                    objects.push(scene.getObjectByName("ground"));
                    tokens.forEach(t => objects.push(t));
                    saveMap();
                }
            };
            document.getElementById('btn-save').onclick = () => {
                const data = localStorage.getItem('dnd-voxel-map');
                const blob = new Blob([data], {type: 'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'akashic-map.json';
                a.click();
            };
        }
        
        function updateBlockCount() {
            document.getElementById('block-count').innerText = voxels.size;
        }

        // --- EVENTS ---
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.key === 'Shift') isShiftDown = true;

            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (!e.repeat) {
                        if (Date.now() - lastSpaceKeyTime < 300) { isFlying = !isFlying; velocity.y=0; }
                        else if (isFlying) moveUp = true;
                        else if (canJump) { velocity.y += 10; canJump = false; }
                        lastSpaceKeyTime = Date.now();
                    }
                    break;
                case 'KeyC': if(isFlying) moveDown = true; break;
            }

            // Material Select vs Token Select
            if(e.code.startsWith('Digit')) {
                const idx = parseInt(e.key)-1;
                if (idx >= 0 && idx < 9) {
                    if (isShiftDown) {
                        // SELECT TOKEN
                        if (combatantList[idx]) {
                            heldTokenId = combatantList[idx].id;
                            renderTokenBar();
                        }
                    } else {
                        // SELECT MATERIAL
                        if (idx < MATERIALS.length) {
                            selectedMaterialIndex = idx;
                            document.querySelectorAll('.slot').forEach((s, i) => {
                                if(i===idx) s.classList.add('active'); else s.classList.remove('active');
                            });
                        }
                    }
                }
            }
        }
        function onKeyUp(e) {
            if (e.key === 'Shift') isShiftDown = false;
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'KeyC': moveDown = false; break;
            }
        }

        // --- ANIMATION ---

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            if (controls.isLocked) {
                const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                
                if (isFlying) {
                    velocity.y -= velocity.y * 5.0 * delta;
                    if(moveUp) velocity.y += 30 * delta;
                    if(moveDown) velocity.y -= 30 * delta;
                } else {
                    velocity.y -= 9.8 * 2.0 * delta;
                }

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 2) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2;
                    if(!isFlying) canJump = true;
                }
                
                const p = controls.getObject().position;
                document.getElementById('coords').innerText = `${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;
                
                updateInteraction();
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
