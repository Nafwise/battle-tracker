<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akashic Atlas (3D Map)</title>
    <!-- Tailwind for matching the suite's theme -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: ui-sans-serif, system-ui, sans-serif; }
        
        /* UI Overlay Styles matching Astral Theme */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Custom Scrollbar for lists */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference;
            transition: opacity 0.2s;
        }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: rgba(255, 255, 255, 0.8); }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: rgba(255, 255, 255, 0.8); }

        /* Floating Tooltip for Hovered Token */
        #tooltip {
            position: absolute; display: none;
            background: rgba(15, 23, 42, 0.9); border: 1px solid #475569;
            padding: 8px 12px; border-radius: 8px; color: white;
            backdrop-filter: blur(4px); pointer-events: none;
            transform: translate(-50%, -120%); white-space: nowrap;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 20;
        }

        /* Material Slot */
        .slot { width: 32px; height: 32px; border: 2px solid rgba(255,255,255,0.1); cursor: pointer; transition: all 0.2s; border-radius: 4px; position: relative; }
        .slot:hover { transform: scale(1.1); border-color: white; }
        .slot.active { border-color: #38BDF8; box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); transform: scale(1.1); z-index: 10; }
        
        /* Toolbar Groups */
        .toolbar-group {
            background: rgba(15, 23, 42, 0.6);
            padding: 6px;
            border-radius: 8px;
            display: flex;
            gap: 4px;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .group-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 9px;
            color: #94a3b8;
            font-weight: bold;
            margin-right: 2px;
            border-right: 1px solid rgba(255,255,255,0.1);
            padding-right: 4px;
            height: 32px;
            text-align: center;
        }

        /* Token Slot (Vertical Bar) */
        .token-slot { 
            display: flex; align-items: center; gap: 8px;
            padding: 6px 10px; margin-bottom: 4px;
            background: rgba(30, 41, 59, 0.8); border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 6px; cursor: pointer; transition: all 0.2s;
            color: #cbd5e1; font-size: 0.75rem;
        }
        .token-slot:hover { background: rgba(51, 65, 85, 0.9); border-color: #94a3b8; transform: translateX(4px); }
        .token-slot.active { background: rgba(56, 189, 248, 0.2); border-color: #38BDF8; color: white; font-weight: bold; }
        .token-slot .key-hint { 
            font-family: monospace; font-size: 0.65rem; 
            background: rgba(0,0,0,0.3); padding: 2px 4px; rounded: 4px; color: #94a3b8;
        }
        .token-slot.active .key-hint { color: #38BDF8; background: rgba(56, 189, 248, 0.1); }
        
        /* Edit Mode Indicator */
        #edit-mode-badge {
            display: none;
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.2); border: 1px solid rgba(234, 179, 8, 0.5);
            color: #fcd34d; font-size: 0.75rem; font-weight: bold; padding: 4px 12px; rounded-full;
            pointer-events: none; text-transform: uppercase; letter-spacing: 1px;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <!-- UI OVERLAY -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- HEADER -->
        <header class="pointer-events-auto flex justify-between items-start">
            <div class="bg-slate-900/90 border border-slate-700 p-3 rounded-xl shadow-lg backdrop-blur-sm">
                <h1 class="text-xl font-bold text-white flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-cyan-400"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>
                    Akashic Atlas
                </h1>
                <div class="text-xs text-slate-400 mt-1 flex gap-2">
                    <span id="coords">0, 0, 0</span> | <span id="block-count">0</span> Blocks
                </div>
            </div>

            <!-- NAVIGATION (Matches Suite) -->
            <div class="flex gap-2">
                <button id="btn-atmosphere" class="pointer-events-auto bg-slate-800 border border-amber-500/50 p-2 rounded-full text-amber-400 hover:bg-slate-700 hover:text-amber-300 transition-colors shadow-lg" title="Toggle Atmosphere (Day/Dungeon)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
                </button>
                <div class="w-px h-8 bg-slate-700 mx-1"></div>
                <a href="./index.html" class="pointer-events-auto bg-slate-900 border border-slate-700 p-2 rounded-full text-slate-400 hover:text-white transition-colors" title="Hub">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                </a>
                <a href="./tome.html" class="pointer-events-auto bg-purple-900/80 border border-purple-600 p-2 rounded-full text-white hover:bg-purple-800 transition-colors" title="Tracker">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-8a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v8"/><path d="M4 11V7"/><path d="M20 11V7"/><path d="M2 7h4v4H2z"/><path d="M18 7h4v4h-4z"/><path d="M4 7l2-4 2 4"/><path d="M18 7l2-4 2 4"/><path d="M10 21v-4a2 2 0 0 1 4 0v4"/></svg>
                </a>
            </div>
        </header>

        <!-- TOKEN ROSTER (Left Side) -->
        <div id="token-bar-container" class="absolute left-4 top-24 bottom-24 overflow-y-auto pointer-events-auto w-48 hidden sm:block">
            <h3 class="text-xs font-bold text-slate-500 uppercase mb-2 bg-slate-900/50 p-1 rounded backdrop-blur-sm">Active Tokens</h3>
            <div id="token-bar">
                <!-- Generated by JS -->
            </div>
        </div>

        <!-- EDIT MODE BADGE -->
        <div id="edit-mode-badge">Mouse Mode Active (Tab)</div>

        <!-- INSTRUCTIONS / START -->
        <div id="instructions" class="pointer-events-auto absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-900/90 border border-cyan-500/50 p-8 rounded-2xl text-center shadow-[0_0_50px_rgba(6,182,212,0.15)] backdrop-blur-md cursor-pointer hover:border-cyan-400 transition-all">
            <h2 class="text-2xl font-bold text-white mb-2">Click to Enter</h2>
            <div class="space-y-2 text-slate-300 text-sm">
                <p><strong class="text-cyan-400">WASD</strong> Move | <strong class="text-cyan-400">Space</strong> Jump/Fly</p>
                <p><strong class="text-cyan-400">Tab</strong> Toggle Mouse Mode</p>
                <p><strong class="text-red-400">Left Drag</strong> Delete Blocks</p>
                <p><strong class="text-cyan-400">Right Drag</strong> Place Blocks</p>
                <p><strong class="text-indigo-400">Shift + Right Click</strong> Focus & Range (15ft)</p>
                <div class="border-t border-slate-700 pt-2 mt-2">
                    <p><strong class="text-cyan-400">Hold 1 + Scroll</strong> Solid Blocks</p>
                    <p><strong class="text-cyan-400">Hold 2 + Scroll</strong> Liquids</p>
                    <p><strong class="text-indigo-400">Shift + 1-9</strong> Select Token</p>
                </div>
            </div>
            <div class="mt-6 pt-4 border-t border-slate-700">
                <p class="text-xs text-indigo-300 animate-pulse">Syncs with Akashic Tracker Data</p>
            </div>
        </div>

        <!-- TOOLBAR & SYNC CONTROLS -->
        <div class="pointer-events-auto flex flex-col items-center gap-2 mb-4">
            <!-- Sync Panel -->
            <div class="bg-slate-900/90 border border-slate-700 p-2 rounded-lg flex items-center gap-3 backdrop-blur-md">
                <button id="btn-sync" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold px-3 py-1.5 rounded flex items-center gap-2 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    Sync Tokens
                </button>
                <div class="h-4 w-px bg-slate-700"></div>
                <button id="btn-save" class="text-xs text-slate-400 hover:text-white">Save Map</button>
                <button id="btn-clear" class="text-xs text-red-400 hover:text-red-300">Clear</button>
                <input type="file" id="file-input" accept=".json" class="hidden">
            </div>

            <!-- Material Toolbar -->
            <div id="toolbar" class="flex gap-4 items-end">
                <!-- Generated by JS -->
            </div>
        </div>
    </div>

    <!-- 3D ELEMENTS -->
    <div id="crosshair"></div>
    <div id="tooltip"></div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const WORLD_SIZE = 64; 
        const BLOCK_SIZE = 1;
        
        // D&D Condition Colors
        const CONDITION_COLORS = {
            "Blinded": 0x525252, "Charmed": 0xdb2777, "Deafened": 0x94a3b8, "Frightened": 0x7c3aed,
            "Grappled": 0xf97316, "Incapacitated": 0xdc2626, "Invisible": 0xffffff, "Paralyzed": 0xfacc15,
            "Petrified": 0x475569, "Poisoned": 0x16a34a, "Prone": 0x78350f, "Restrained": 0x9a3412,
            "Stunned": 0xf59e0b, "Unconscious": 0x000000, "Exhaustion": 0x7f1d1d, "Default": 0x38BDF8
        };

        // Astral Palette (Blocks)
        // Indices: 0-8 (Keys 1-9), 9 (Key 0), 10 (Key -), 11 (Key =)
        const MATERIALS = [
            { color: 0x4b6e32, name: "Grass" },       // 0
            { color: 0x5c3c28, name: "Dirt" },        // 1
            { color: 0x64748b, name: "Stone" },       // 2
            { color: 0x8B4513, name: "Wood" },        // 3
            { color: 0x38BDF8, name: "Water", transparent: true, opacity: 0.6 }, // 4
            { color: 0xE6C288, name: "Sand" },        // 5
            { color: 0xf1f5f9, name: "Snow" },        // 6
            { color: 0xea580c, name: "Lava/Fire", transparent: true, opacity: 0.7 }, // 7
            { color: 0x1e293b, name: "Dungeon" },     // 8
            { color: 0x84cc16, name: "Acid", transparent: true, opacity: 0.6 }, // 9
            { color: 0x14532d, name: "Poison", transparent: true, opacity: 0.7 }, // 10
            { color: 0xa855f7, name: "Force", transparent: true, opacity: 0.5 }   // 11
        ];

        // Groups
        const SOLID_IDXS = [0, 1, 2, 3, 5, 6, 8];
        const LIQUID_IDXS = [4, 7, 9, 10, 11];

        // --- Globals ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let canJump = false, isFlying = false;
        let isTabMode = false; 
        let isLocking = false; 
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let lastSpaceKeyTime = 0;
        let lastLockTime = 0; 

        // Lighting & Atmosphere
        let isNight = true; 
        let ambientLight, dirLight, torchLight;

        // Data Storage
        const voxels = new Map(); 
        const objects = []; 
        const tokens = new Map(); 
        let combatantList = []; 
        
        // Geometry Cache for Culling
        const geometryCache = new Map();
        
        // Interaction State
        let selectedMaterialIndex = 0;
        let group1Index = 0; // Current selection index within solids
        let group2Index = 0; // Current selection index within liquids
        let isKey1Down = false;
        let isKey2Down = false;

        let heldTokenId = null; 
        let focusedToken = null; 
        let isShiftDown = false;
        
        // Drag Building/Deleting State
        let isDragging = false;
        let isDeleting = false;
        let buildStartPoint = null; 
        let deleteStartPoint = null; 

        // Visuals
        let rollOverMesh; 
        let tokenRollOverMesh; 
        let rangeGroup; 
        let voxelGeometry, tokenGeometry;
        const threeMaterials = [];

        // UI
        const instructions = document.getElementById('instructions');
        const tooltip = document.getElementById('tooltip');
        const toolbar = document.getElementById('toolbar');
        const tokenBar = document.getElementById('token-bar');
        const crosshair = document.getElementById('crosshair');
        const editModeBadge = document.getElementById('edit-mode-badge');

        // --- INITIALIZATION ---
        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617); 
            scene.fog = new THREE.Fog(0x020617, 10, 60);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);

            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2); 
            scene.add(ambientLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);
            torchLight = new THREE.PointLight(0xffaa00, 1.5, 20); 
            camera.add(torchLight); 
            scene.add(camera);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => safeLock());
            
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                editModeBadge.style.display = 'none';
                crosshair.style.opacity = '1';
                isTabMode = false;
                isLocking = false;
            });
            
            controls.addEventListener('unlock', () => {
                isLocking = false; 
                if (isTabMode) {
                    instructions.style.display = 'none';
                    editModeBadge.style.display = 'block';
                    crosshair.style.opacity = '0';
                } else {
                    instructions.style.display = 'block';
                    editModeBadge.style.display = 'none';
                    crosshair.style.opacity = '1';
                }
            });
            
            document.addEventListener('pointerlockerror', () => {
                isLocking = false;
                console.warn("Pointer lock failed/rejected.");
            });
            
            // Input
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove); 
            document.addEventListener('wheel', onScroll);

            // World Base
            const planeGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            planeGeo.rotateX(-Math.PI / 2);
            const plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
            plane.name = "ground";
            scene.add(plane);
            objects.push(plane);

            const gridHelper = new THREE.GridHelper(WORLD_SIZE, WORLD_SIZE, 0x334155, 0x1e293b);
            scene.add(gridHelper);

            // Raycaster & Geometries
            raycaster = new THREE.Raycaster();
            voxelGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            tokenGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16); 

            initGeometryCache();

            // Materials
            MATERIALS.forEach(m => {
                threeMaterials.push(new THREE.MeshLambertMaterial({ 
                    color: m.color, 
                    transparent: !!m.transparent, 
                    opacity: m.opacity || 1.0 
                }));
            });

            // Cursors
            const rollOverGeo = new THREE.BoxGeometry(BLOCK_SIZE + 0.05, BLOCK_SIZE + 0.05, BLOCK_SIZE + 0.05);
            rollOverMesh = new THREE.Mesh(rollOverGeo, new THREE.MeshBasicMaterial({ color: 0x38BDF8, opacity: 0.5, transparent: true, wireframe: true }));
            scene.add(rollOverMesh);

            tokenRollOverMesh = new THREE.Mesh(tokenGeometry, new THREE.MeshBasicMaterial({ color: 0xFCD34D, opacity: 0.5, transparent: true, wireframe: true }));
            tokenRollOverMesh.visible = false;
            scene.add(tokenRollOverMesh);

            rangeGroup = new THREE.Group();
            rangeGroup.visible = false;
            scene.add(rangeGroup);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);

            // Init UI
            initToolbar();
            initButtons();

            // Load Data
            loadMap();
            syncTokensFromTracker(); 
        }
        
        function initGeometryCache() {
            const baseGeo = new THREE.BoxGeometry(1, 1, 1);
            const indices = baseGeo.index.array;
            const position = baseGeo.attributes.position;
            const normal = baseGeo.attributes.normal;
            const uv = baseGeo.attributes.uv;
            for (let mask = 0; mask < 64; mask++) {
                const newIndices = [];
                for (let i = 0; i < 6; i++) {
                    if ((mask & (1 << i)) !== 0) {
                        const offset = i * 6;
                        for (let j = 0; j < 6; j++) newIndices.push(indices[offset + j]);
                    }
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', position);
                geo.setAttribute('normal', normal);
                geo.setAttribute('uv', uv);
                geo.setIndex(newIndices);
                geometryCache.set(mask, geo);
            }
        }
        const DIRS = [{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1}];
        function getVisibilityMask(x, y, z, myMatIndex) {
            let mask = 0;
            for (let i = 0; i < 6; i++) {
                const d = DIRS[i];
                const neighbor = voxels.get(`${x+d.x},${y+d.y},${z+d.z}`);
                if (!neighbor || neighbor.userData.colorIndex !== myMatIndex) mask |= (1 << i);
            }
            return mask;
        }
        function updateVoxelGeometry(voxel) {
            const { x, y, z } = voxel.position;
            const mask = getVisibilityMask(x, y, z, voxel.userData.colorIndex);
            const geo = geometryCache.get(mask);
            if (geo) voxel.geometry = geo;
        }
        function updateNeighbors(x, y, z) {
            for (let i = 0; i < 6; i++) {
                const d = DIRS[i];
                const neighbor = voxels.get(`${x+d.x},${y+d.y},${z+d.z}`);
                if (neighbor) updateVoxelGeometry(neighbor);
            }
        }
        function safeLock() {
            const now = performance.now();
            if (isLocking || controls.isLocked || (now - lastLockTime < 1200)) return;
            if (!document.hasFocus()) return;
            isLocking = true; lastLockTime = now;
            try { controls.lock(); } catch (e) { console.warn("Lock failed:", e); isLocking = false; }
            setTimeout(() => { if(isLocking && !controls.isLocked) isLocking = false; }, 2000); 
        }

        // --- TRACKER SYNC ---
        function syncTokensFromTracker() {
            const raw = localStorage.getItem('dm-tracker-monsters');
            combatantList = raw ? JSON.parse(raw) : [];
            const savedPositions = JSON.parse(localStorage.getItem('dm-tracker-map-positions') || '{}');
            const currentIds = new Set();
            combatantList.forEach((c, index) => {
                currentIds.add(c.id);
                if (tokens.has(c.id)) { updateTokenVisuals(tokens.get(c.id), c); } 
                else {
                    const isMonster = c.type === 'monster';
                    const color = isMonster ? 0xF43F5E : 0x6366f1; 
                    const mesh = new THREE.Mesh(tokenGeometry, new THREE.MeshLambertMaterial({ color }));
                    if (savedPositions[c.id]) mesh.position.set(savedPositions[c.id].x, savedPositions[c.id].y, savedPositions[c.id].z);
                    else mesh.position.set(index * 2 + 0.5, 1, 0.5); 
                    mesh.userData = { isToken: true, id: c.id, name: c.name, hp: c.currentHp, maxHp: c.maxHp, conditions: c.conditions || [] };
                    mesh.name = "token"; 
                    scene.add(mesh); objects.push(mesh); tokens.set(c.id, mesh); updateTokenVisuals(mesh, c);
                }
            });
            tokens.forEach((mesh, id) => { if (!currentIds.has(id)) { scene.remove(mesh); objects.splice(objects.indexOf(mesh), 1); tokens.delete(id); } });
            saveTokenPositions(); updateBlockCount(); renderTokenBar(); 
        }
        function updateTokenVisuals(mesh, data) {
            mesh.userData.hp = data.currentHp; mesh.userData.maxHp = data.maxHp;
            mesh.userData.name = data.name; mesh.userData.conditions = data.conditions || [];
            if (data.currentHp <= 0 && data.type === 'monster') { mesh.rotation.x = Math.PI / 2; mesh.position.y = 0.2; mesh.material.color.setHex(0x334155); } 
            else { mesh.rotation.x = 0; const color = data.type === 'monster' ? 0xF43F5E : 0x6366f1; mesh.material.color.setHex(color); if (mesh.position.y < 0.6) mesh.position.y = 1; }
        }
        function saveTokenPositions() {
            const posData = {};
            tokens.forEach((mesh, id) => { posData[id] = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z }; });
            localStorage.setItem('dm-tracker-map-positions', JSON.stringify(posData));
        }

        // --- INTERACTION ---
        function onMouseMove(event) { if (controls.isLocked) { tooltip.style.display = 'none'; return; } }
        function getVoxelPos(point, normal, mode) {
            const pos = new THREE.Vector3().copy(point);
            if (mode === 'build') { pos.addScaledVector(normal, 0.5); } 
            else { if (Math.abs(point.y) < 0.01) pos.addScaledVector(normal, 0.5); else pos.addScaledVector(normal, -0.1); }
            return pos.divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
        }
        function focusOnToken(tokenMesh) {
            focusedToken = tokenMesh;
            controls.getObject().position.copy(tokenMesh.position).add(new THREE.Vector3(0, 3, 5));
            updateRangeIndicator(tokenMesh);
        }
        function updateRangeIndicator(tokenMesh) {
            while(rangeGroup.children.length > 0) rangeGroup.remove(rangeGroup.children[0]); 
            rangeGroup.visible = true; rangeGroup.position.copy(tokenMesh.position); rangeGroup.position.y = tokenMesh.position.y - 0.55; 
            const conditions = tokenMesh.userData.conditions || [];
            const innerR = 2.9, outerR = 3.0, segments = 64;
            if (conditions.length === 0) {
                const geo = new THREE.RingGeometry(innerR, outerR, segments); geo.rotateX(-Math.PI / 2);
                const mat = new THREE.MeshBasicMaterial({ color: CONDITION_COLORS["Default"], side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                rangeGroup.add(new THREE.Mesh(geo, mat));
            } else {
                const arcLength = (Math.PI * 2) / conditions.length;
                conditions.forEach((cond, i) => {
                    const colorHex = CONDITION_COLORS[cond] || CONDITION_COLORS["Default"];
                    const geo = new THREE.RingGeometry(innerR, outerR, Math.max(8, Math.floor(segments/conditions.length)), 1, i * arcLength, arcLength);
                    geo.rotateX(-Math.PI / 2);
                    const mat = new THREE.MeshBasicMaterial({ color: colorHex, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
                    rangeGroup.add(new THREE.Mesh(geo, mat));
                });
            }
        }
        function updateInteraction() {
            if (!controls.isLocked && !isTabMode) return;
            if (focusedToken && rangeGroup.visible) { rangeGroup.position.copy(focusedToken.position); rangeGroup.position.y = focusedToken.position.y - 0.55; }
            if (!isTabMode) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(objects, false);
                if (intersects.length > 0) {
                    const intersect = intersects[0]; const obj = intersect.object; const hitPoint = intersect.point; const normal = intersect.face.normal;
                    const dist = controls.getObject().position.distanceTo(hitPoint); const feet = Math.round(dist * 5); 
                    if (obj.userData.isToken && heldTokenId === null && !isDragging && !isDeleting) {
                        tooltip.style.display = 'block'; tooltip.style.left = '50%'; tooltip.style.top = '50%';
                        let condStr = ""; if (obj.userData.conditions && obj.userData.conditions.length > 0) condStr = `<br><span style="color:#f87171; font-size:10px;">${obj.userData.conditions.join(", ")}</span>`;
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong><br>HP: ${obj.userData.hp}/${obj.userData.maxHp}${condStr}<br><span style="color:#fbbf24">Dist: ${feet} ft</span><br><span style="font-size:10px; color:#cbd5e1;">Shift+RClick to Focus</span>`;
                        rollOverMesh.visible = false; tokenRollOverMesh.visible = false; return;
                    } else if (obj.name === "voxel" || obj.name === "ground") {
                        if (!isDragging && !isDeleting) { tooltip.style.display = 'block'; tooltip.style.left = '50%'; tooltip.style.top = '55%'; tooltip.innerHTML = `<span style="color:#fbbf24; font-size: 10px;">Target: ${feet} ft</span>`; } else tooltip.style.display = 'none';
                    } else tooltip.style.display = 'none';
                    if (heldTokenId !== null) {
                        rollOverMesh.visible = false; tokenRollOverMesh.visible = true; tokenRollOverMesh.position.copy(hitPoint).add(normal);
                        tokenRollOverMesh.position.divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2); tokenRollOverMesh.position.y = Math.floor(hitPoint.y + 0.1) + 0.6; 
                    } else if ((isDragging && buildStartPoint) || (isDeleting && deleteStartPoint)) {
                        const activeStartPoint = isDragging ? buildStartPoint : deleteStartPoint;
                        rollOverMesh.visible = true; tokenRollOverMesh.visible = false; rollOverMesh.material.color.setHex(isDeleting ? 0xEF4444 : 0x38BDF8);
                        const currentPos = getVoxelPos(hitPoint, normal, isDeleting ? 'delete' : 'build');
                        const minX = Math.min(activeStartPoint.x, currentPos.x), maxX = Math.max(activeStartPoint.x, currentPos.x);
                        const minY = Math.min(activeStartPoint.y, currentPos.y), maxY = Math.max(activeStartPoint.y, currentPos.y);
                        const minZ = Math.min(activeStartPoint.z, currentPos.z), maxZ = Math.max(activeStartPoint.z, currentPos.z);
                        const width = maxX - minX + BLOCK_SIZE, height = maxY - minY + BLOCK_SIZE, depth = maxZ - minZ + BLOCK_SIZE;
                        rollOverMesh.scale.set(width, height, depth); rollOverMesh.position.set(minX + width/2 - 0.5, minY + height/2 - 0.5, minZ + depth/2 - 0.5);
                    } else {
                        tokenRollOverMesh.visible = false; rollOverMesh.visible = true; rollOverMesh.scale.set(1, 1, 1); rollOverMesh.material.color.setHex(0x38BDF8);
                        rollOverMesh.position.copy(hitPoint).addScaledVector(normal, 0.5).divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
                    }
                } else { rollOverMesh.visible = false; tokenRollOverMesh.visible = false; tooltip.style.display = 'none'; }
            }
        }
        function onMouseDown(event) {
            if (event.target.closest('#ui-layer')) return;
            if (isTabMode && !event.target.closest('button') && !event.target.closest('.token-slot')) { safeLock(); return; }
            if (!controls.isLocked && !isTabMode) { safeLock(); return; }
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);
            if (intersects.length > 0) {
                const intersect = intersects[0]; const obj = intersect.object;
                if (event.button === 2) {
                    if (isShiftDown && obj.userData.isToken) { focusOnToken(obj); return; }
                    if (heldTokenId !== null) {
                        const tokenMesh = tokens.get(heldTokenId);
                        if (tokenMesh) { tokenMesh.position.copy(tokenRollOverMesh.position); saveTokenPositions(); heldTokenId = null; renderTokenBar(); }
                        return; 
                    }
                    if (obj.userData.isToken) { heldTokenId = obj.userData.id; if (focusedToken && focusedToken !== obj) { focusedToken = null; rangeGroup.visible = false; } renderTokenBar(); return; }
                    if (!isDragging) { isDragging = true; buildStartPoint = getVoxelPos(intersect.point, intersect.face.normal, 'build'); }
                }
                if (event.button === 0) {
                    if (heldTokenId !== null) { heldTokenId = null; renderTokenBar(); }
                    else if (!obj.userData.isToken) {
                        if (focusedToken) { focusedToken = null; rangeGroup.visible = false; }
                        if (!isDeleting) { isDeleting = true; deleteStartPoint = getVoxelPos(intersect.point, intersect.face.normal, 'delete'); }
                    }
                }
            }
        }
        function onMouseUp(event) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);
            const intersect = intersects.length > 0 ? intersects[0] : null;
            if (event.button === 2 && isDragging) {
                if (intersect && buildStartPoint) { const endPoint = getVoxelPos(intersect.point, intersect.face.normal, 'build'); executeBoxAction(buildStartPoint, endPoint, 'build'); }
                isDragging = false; buildStartPoint = null; if (rollOverMesh) { rollOverMesh.scale.set(1,1,1); rollOverMesh.material.color.setHex(0x38BDF8); }
            }
            if (event.button === 0 && isDeleting) {
                if (intersect && deleteStartPoint) { const endPoint = getVoxelPos(intersect.point, intersect.face.normal, 'delete'); executeBoxAction(deleteStartPoint, endPoint, 'delete'); }
                isDeleting = false; deleteStartPoint = null; if (rollOverMesh) { rollOverMesh.scale.set(1,1,1); rollOverMesh.material.color.setHex(0x38BDF8); }
            }
        }
        function executeBoxAction(start, end, action) {
            if (!start || !end) return; 
            const minX = Math.min(start.x, end.x), maxX = Math.max(start.x, end.x);
            const minY = Math.min(start.y, end.y), maxY = Math.max(start.y, end.y);
            const minZ = Math.min(start.z, end.z), maxZ = Math.max(start.z, end.z);
            let changeCount = 0; const playerPos = controls.getObject().position;
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        if (action === 'build') {
                            const dist = new THREE.Vector3(x, y, z).distanceTo(playerPos);
                            if (dist < 1.5) continue; 
                            addBlock(x, y, z, selectedMaterialIndex, false); changeCount++;
                        } else if (action === 'delete') {
                            const key = `${x},${y},${z}`; const voxel = voxels.get(key);
                            if (voxel) { scene.remove(voxel); objects.splice(objects.indexOf(voxel), 1); voxels.delete(key); updateNeighbors(x, y, z); changeCount++; }
                        }
                    }
                }
            }
            if (changeCount > 0) { saveMap(); updateBlockCount(); }
        }

        // --- VOXEL LOGIC (Restored) ---
        function addBlock(x, y, z, matIndex, save = true) {
            const key = `${x},${y},${z}`;
            if (voxels.has(key)) return;

            const mesh = new THREE.Mesh(voxelGeometry, threeMaterials[matIndex]);
            mesh.position.set(x, y, z);
            mesh.name = "voxel";
            mesh.userData.colorIndex = matIndex;
            
            scene.add(mesh);
            objects.push(mesh);
            voxels.set(key, mesh);

            // Update self and neighbors for culling
            updateVoxelGeometry(mesh);
            updateNeighbors(x, y, z);

            if (save) saveMap();
            updateBlockCount();
        }

        function removeBlock(object) {
            const { x, y, z } = object.position;
            scene.remove(object);
            objects.splice(objects.indexOf(object), 1);
            voxels.delete(`${x},${y},${z}`);
            
            // Neighbors might now have visible faces
            updateNeighbors(x, y, z);
            
            saveMap();
            updateBlockCount();
        }

        function saveMap() {
            const data = [];
            voxels.forEach(v => {
                data.push({ x: v.position.x, y: v.position.y, z: v.position.z, c: v.userData.colorIndex });
            });
            localStorage.setItem('dnd-voxel-map', JSON.stringify(data));
        }

        function loadMap() {
            const raw = localStorage.getItem('dnd-voxel-map');
            if (raw) {
                const data = JSON.parse(raw);
                data.forEach(b => addBlock(b.x, b.y, b.z, b.c, false));
            }
        }

        function initToolbar() {
            const solidsContainer = document.createElement('div');
            solidsContainer.className = 'toolbar-group';
            solidsContainer.innerHTML = '<div class="group-label">SOLIDS (1)</div>';
            SOLID_IDXS.forEach(i => { const div = createSlotElement(i); solidsContainer.appendChild(div); });
            toolbar.appendChild(solidsContainer);
            const liquidsContainer = document.createElement('div');
            liquidsContainer.className = 'toolbar-group';
            liquidsContainer.innerHTML = '<div class="group-label">LIQUIDS (2)</div>';
            LIQUID_IDXS.forEach(i => { const div = createSlotElement(i); liquidsContainer.appendChild(div); });
            toolbar.appendChild(liquidsContainer);
            updateToolbarUI();
        }
        function createSlotElement(index) {
            const m = MATERIALS[index]; const div = document.createElement('div'); div.className = 'slot'; div.setAttribute('data-index', index); div.style.backgroundColor = '#' + m.color.toString(16).padStart(6,'0'); div.title = m.name;
            div.onclick = () => {
                selectedMaterialIndex = index;
                if (SOLID_IDXS.includes(index)) { isKey1Down = true; isKey2Down = false; group1Index = SOLID_IDXS.indexOf(index); } 
                else if (LIQUID_IDXS.includes(index)) { isKey1Down = false; isKey2Down = true; group2Index = LIQUID_IDXS.indexOf(index); }
                updateToolbarUI();
            };
            return div;
        }
        function renderTokenBar() {
            tokenBar.innerHTML = '';
            combatantList.forEach((c, i) => {
                const div = document.createElement('div'); const isSelected = c.id === heldTokenId; div.className = `token-slot ${isSelected ? 'active' : ''}`;
                const dotColor = c.type === 'monster' ? '#F43F5E' : '#6366f1';
                div.innerHTML = `<div style="width:8px; height:8px; border-radius:50%; background:${dotColor};"></div><span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${c.name}</span>${i < 9 ? `<span class="key-hint">Shift+${i+1}</span>` : ''}`;
                div.onclick = () => { heldTokenId = c.id; renderTokenBar(); };
                tokenBar.appendChild(div);
            });
        }
        function initButtons() {
            document.getElementById('btn-sync').onclick = () => { syncTokensFromTracker(); alert("Synced!"); };
            document.getElementById('btn-atmosphere').onclick = toggleAtmosphere;
            document.getElementById('btn-clear').onclick = () => { if(confirm("Clear Map Blocks?")) { voxels.forEach(v => scene.remove(v)); voxels.clear(); objects.length = 0; objects.push(scene.getObjectByName("ground")); tokens.forEach(t => objects.push(t)); saveMap(); updateBlockCount(); } };
            document.getElementById('btn-save').onclick = () => { const data = localStorage.getItem('dnd-voxel-map'); const blob = new Blob([data], {type: 'application/json'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'akashic-map.json'; a.click(); };
        }
        function updateBlockCount() { document.getElementById('block-count').innerText = voxels.size; }
        function toggleAtmosphere() {
            isNight = !isNight;
            if (isNight) { scene.background = new THREE.Color(0x020617); scene.fog = new THREE.Fog(0x020617, 10, 60); ambientLight.intensity = 0.2; dirLight.intensity = 0.5; torchLight.intensity = 1.5; } 
            else { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 30, 150); ambientLight.intensity = 0.7; dirLight.intensity = 0.8; torchLight.intensity = 0; }
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onKeyDown(e) {
            if (e.key === 'Shift') isShiftDown = true;
            if (e.code === 'Tab') { e.preventDefault(); if (controls.isLocked) { isTabMode = true; controls.unlock(); } else { safeLock(); } return; }
            switch(e.code) {
                case 'KeyW': moveForward = true; break; case 'KeyA': moveLeft = true; break; case 'KeyS': moveBackward = true; break; case 'KeyD': moveRight = true; break;
                case 'Space': if (!e.repeat) { if (Date.now() - lastSpaceKeyTime < 300) { isFlying = !isFlying; velocity.y=0; } else if (isFlying) moveUp = true; else if (canJump) { velocity.y += 10; canJump = false; } lastSpaceKeyTime = Date.now(); } break;
                case 'KeyC': if(isFlying) moveDown = true; break;
            }
            if (e.key === '1') { if (isShiftDown) { if (combatantList[0]) { heldTokenId = combatantList[0].id; renderTokenBar(); } } else { isKey1Down = true; isKey2Down = false; selectedMaterialIndex = SOLID_IDXS[group1Index]; updateToolbarUI(); } }
            if (e.key === '2') { if (isShiftDown) { if (combatantList[1]) { heldTokenId = combatantList[1].id; renderTokenBar(); } } else { isKey2Down = true; isKey1Down = false; selectedMaterialIndex = LIQUID_IDXS[group2Index]; updateToolbarUI(); } }
            if (isShiftDown && e.code.startsWith('Digit')) { const idx = parseInt(e.key) - 1; if (idx >= 2 && idx < 9 && combatantList[idx]) { heldTokenId = combatantList[idx].id; renderTokenBar(); } }
        }
        function onKeyUp(e) {
            if (e.key === 'Shift') isShiftDown = false;
            if (e.key === '1') isKey1Down = false; if (e.key === '2') isKey2Down = false;
            switch(e.code) { case 'KeyW': moveForward = false; break; case 'KeyA': moveLeft = false; break; case 'KeyS': moveBackward = false; break; case 'KeyD': moveRight = false; break; case 'Space': moveUp = false; break; case 'KeyC': moveDown = false; break; }
        }
        function onScroll(e) {
            if (isKey1Down) { if (e.deltaY > 0) group1Index = (group1Index + 1) % SOLID_IDXS.length; else group1Index = (group1Index - 1 + SOLID_IDXS.length) % SOLID_IDXS.length; selectedMaterialIndex = SOLID_IDXS[group1Index]; updateToolbarUI(); }
            else if (isKey2Down) { if (e.deltaY > 0) group2Index = (group2Index + 1) % LIQUID_IDXS.length; else group2Index = (group2Index - 1 + LIQUID_IDXS.length) % LIQUID_IDXS.length; selectedMaterialIndex = LIQUID_IDXS[group2Index]; updateToolbarUI(); }
        }
        function updateToolbarUI() { document.querySelectorAll('.slot').forEach(s => { const idx = parseInt(s.getAttribute('data-index')); if(idx === selectedMaterialIndex) s.classList.add('active'); else s.classList.remove('active'); }); }
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            if (controls.isLocked) {
                const delta = (time - prevTime) / 1000;
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
                if (isFlying) { velocity.y -= velocity.y * 5.0 * delta; if(moveUp) velocity.y += 30 * delta; if(moveDown) velocity.y -= 30 * delta; } else { velocity.y -= 9.8 * 2.0 * delta; }
                direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;
                controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta); controls.getObject().position.y += (velocity.y * delta);
                if (controls.getObject().position.y < 2) { velocity.y = 0; controls.getObject().position.y = 2; if(!isFlying) canJump = true; }
                const p = controls.getObject().position; document.getElementById('coords').innerText = `${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;
                updateInteraction();
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
